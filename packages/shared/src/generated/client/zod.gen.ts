// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * Required configuration for workspace bootstrap
 */
export const zBootstrapRequest = z.object({
    workspaceName: z.string().min(1).max(255).regex(/.*\S.*/)
});

/**
 * Capability keys for the workspace (use these with API or web URLs)
 */
export const zBootstrapKeys = z.object({
    read: z.string(),
    append: z.string(),
    write: z.string()
});

/**
 * API endpoint URLs (for curl/CLI usage)
 */
export const zBootstrapApiUrls = z.object({
    read: z.string().url(),
    append: z.string().url(),
    write: z.string().url()
});

/**
 * Web UI URLs (for browser access)
 */
export const zBootstrapWebUrls = z.object({
    read: z.string().url(),
    claim: z.string().url()
});

/**
 * Pre-built URLs for API and web access
 */
export const zBootstrapUrls = z.object({
    api: zBootstrapApiUrls,
    web: zBootstrapWebUrls
});

/**
 * Response from bootstrap endpoint with workspace details
 */
export const zBootstrapResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        keys: zBootstrapKeys,
        urls: zBootstrapUrls,
        createdAt: z.string().datetime()
    })
});

export const zError = z.object({
    ok: z.literal(false),
    error: z.object({
        code: z.enum([
            'FILE_NOT_FOUND',
            'FOLDER_NOT_FOUND',
            'FOLDER_ALREADY_EXISTS',
            'FOLDER_EXISTS',
            'SOURCE_NOT_FOUND',
            'APPEND_NOT_FOUND',
            'WEBHOOK_NOT_FOUND',
            'WORKSPACE_NOT_FOUND',
            'FILE_DELETED',
            'FILE_ALREADY_EXISTS',
            'FOLDER_NOT_EMPTY',
            'INVALID_REQUEST',
            'SERVER_ERROR',
            'INVALID_APPEND_TYPE',
            'INVALID_REF',
            'INVALID_VOTE_VALUE',
            'INVALID_AUTHOR',
            'INVALID_TOKEN',
            'INVALID_WEBHOOK_URL',
            'INVALID_PATH',
            'INVALID_CONTENT',
            'INVALID_TARGET',
            'INVALID_KEY',
            'INVALID_FILENAME',
            'INVALID_APPEND_ID',
            'SECTION_NOT_FOUND',
            'UNSUPPORTED_MEDIA_TYPE',
            'TASK_ALREADY_COMPLETE',
            'TASK_CANCELLED',
            'CLAIM_EXPIRED',
            'ALREADY_CLAIMED',
            'AUTHOR_MISMATCH',
            'CANNOT_RENEW_OTHERS_CLAIM',
            'CANNOT_CANCEL_OTHERS_CLAIM',
            'TYPE_NOT_ALLOWED',
            'KEY_EXPIRED',
            'KEY_REVOKED',
            'KEY_NOT_FOUND',
            'NOT_FOUND',
            'PERMISSION_DENIED',
            'FORBIDDEN',
            'NOT_ASSIGNED',
            'CONFLICT',
            'PAYLOAD_TOO_LARGE',
            'WORKSPACE_TOO_LARGE',
            'QUOTA_EXCEEDED',
            'RATE_LIMITED',
            'WIP_LIMIT_EXCEEDED',
            'AUTHOR_RATE_LIMITED',
            'BULK_LIMIT_EXCEEDED',
            'WEBHOOK_LIMIT_EXCEEDED',
            'WEBHOOK_SUSPENDED',
            'UNAUTHORIZED',
            'CONFIRM_PATH_MISMATCH',
            'JOB_NOT_FOUND',
            'JOB_NOT_READY',
            'INVALID_PATTERN',
            'QUERY_TOO_LONG',
            'QUERY_TOO_BROAD',
            'INVALID_TIMEOUT',
            'SCOPE_DENIED'
        ]),
        message: z.string(),
        details: z.record(z.unknown()).optional()
    })
});

/**
 * User-facing append types that can be created via API or CLI
 */
export const zUserAppendType = z.enum([
    'task',
    'claim',
    'response',
    'comment',
    'blocked',
    'answer',
    'renew',
    'cancel',
    'vote'
]);

/**
 * System-only append types (heartbeat, etc.) - not user-creatable
 */
export const zSystemAppendType = z.enum(['heartbeat']);

/**
 * All possible append types (user + system)
 */
export const zAppendType = z.union([
    zUserAppendType,
    zSystemAppendType
]);

/**
 * Computed status of a task or claim
 */
export const zAppendStatus = z.enum([
    'pending',
    'open',
    'claimed',
    'completed',
    'done',
    'expired',
    'cancelled',
    'active'
]);

/**
 * Task priority level
 */
export const zPriority = z.enum([
    'low',
    'medium',
    'high',
    'critical'
]);

/**
 * Full append object returned in parsed file responses
 */
export const zAppend = z.object({
    id: z.string().regex(/^a[0-9]+$/),
    author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/),
    ts: z.string().datetime(),
    type: zAppendType,
    status: zAppendStatus.optional(),
    content: z.string().optional(),
    priority: zPriority.optional(),
    labels: z.array(z.string()).optional(),
    ref: z.string().regex(/^a[0-9]+$/).optional(),
    expiresAt: z.string().datetime().optional(),
    dueAt: z.string().datetime().optional(),
    claimedBy: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    completedAt: z.string().datetime().optional(),
    value: z.enum(['+1', '-1']).optional(),
    relatedTo: z.array(z.string().regex(/^a[0-9]+$/)).optional(),
    stale: z.boolean().optional()
});

export const zTaskStats = z.object({
    pending: z.number().int().optional(),
    claimed: z.number().int().optional(),
    completed: z.number().int().optional(),
    activeClaims: z.number().int().optional()
});

export const zFileStats = z.object({
    appendCount: z.number().int().optional(),
    taskStats: zTaskStats.optional()
});

/**
 * Workspace metadata included in capability URL responses
 */
export const zWorkspaceContext = z.object({
    id: z.string().regex(/^ws_[A-Za-z0-9_]{12,}$/),
    name: z.string().optional(),
    claimed: z.boolean()
});

export const zFileReadResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        filename: z.string(),
        content: z.string(),
        etag: z.string(),
        createdAt: z.string().datetime(),
        updatedAt: z.string().datetime(),
        appendCount: z.number().int(),
        size: z.number().int(),
        frontmatter: z.record(z.unknown()).optional(),
        appends: z.array(zAppend).optional(),
        stats: zFileStats.optional(),
        webUrl: z.string().url().optional(),
        workspace: zWorkspaceContext.optional()
    })
});

export const zFileUpdateRequest = z.object({
    content: z.string()
});

export const zFileUpdateResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        etag: z.string(),
        updatedAt: z.string().datetime(),
        size: z.number().int(),
        appendsStale: z.number().int().optional(),
        webUrl: z.string().url().optional()
    })
});

export const zFileDeleteResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        deleted: z.literal(true),
        recoverable: z.boolean().optional(),
        expiresAt: z.string().datetime().optional()
    })
});

export const zFileRenameRequest = z.object({
    filename: z.string().max(255)
});

export const zFileRenameResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        filename: z.string()
    })
});

export const zFileMetaResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        filename: z.string(),
        folder: z.string(),
        size: z.number().int(),
        createdAt: z.string().datetime(),
        updatedAt: z.string().datetime(),
        appendCount: z.number().int(),
        taskStats: zTaskStats,
        hasWebhook: z.boolean(),
        webUrl: z.string().url().optional()
    })
});

export const zFileTailResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        content: z.string(),
        bytesReturned: z.number().int(),
        truncated: z.boolean()
    })
});

export const zFileStructureResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        headings: z.array(z.object({
            level: z.number().int().gte(1).lte(6),
            text: z.string(),
            line: z.number().int().gte(1)
        })),
        appendCount: z.number().int(),
        hasTaskAppends: z.boolean()
    })
});

export const zFileSectionResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        heading: z.string(),
        level: z.number().int().gte(1).lte(6),
        content: z.string(),
        startLine: z.number().int().gte(1),
        endLine: z.number().int().gte(1)
    })
});

export const zAppendGetResponse = z.object({
    ok: z.literal(true),
    data: zAppend
});

/**
 * Capability URLs for different permission levels.
 * URL fields are nullable - null indicates the current key lacks permission for that tier.
 *
 */
export const zCapabilityUrls = z.object({
    read: z.union([
        z.string().url(),
        z.null()
    ]),
    append: z.union([
        z.string().url(),
        z.null()
    ]),
    write: z.union([
        z.string().url(),
        z.null()
    ])
});

export const zFileRecoverResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        recovered: z.literal(true),
        path: z.string(),
        urls: zCapabilityUrls,
        webUrl: z.string().url().optional()
    })
});

export const zFileMoveRequest = z.object({
    source: z.string(),
    destination: z.string()
});

export const zFileMoveResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        previousPath: z.string(),
        newPath: z.string(),
        webUrl: z.string().url().optional()
    })
});

export const zFileRotateUrlsResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        urls: zCapabilityUrls,
        previousUrlsInvalidated: z.literal(true),
        webUrl: z.string().url().optional()
    })
});

export const zFileSettings = z.object({
    claimDurationSeconds: z.number().int().gte(60).optional(),
    maxAppendSize: z.number().int().gte(1).lte(1048576).optional(),
    allowedAppendTypes: z.array(zUserAppendType).optional(),
    wipLimit: z.number().int().gte(1).optional(),
    labels: z.array(z.string()).optional()
});

export const zFileSettingsResponse = z.object({
    ok: z.literal(true),
    data: zFileSettings
});

/**
 * Partial update for file settings
 */
export const zFileSettingsUpdateRequest = z.object({
    claimDurationSeconds: z.number().int().gte(60).optional(),
    maxAppendSize: z.number().int().gte(1).lte(1048576).optional(),
    allowedAppendTypes: z.array(zUserAppendType).optional(),
    wipLimit: z.number().int().gte(1).optional(),
    labels: z.array(z.string()).optional()
});

/**
 * Request body for creating a single append
 */
export const zAppendRequest = z.object({
    path: z.string().optional(),
    author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    type: zUserAppendType,
    content: z.string().optional(),
    ref: z.string().regex(/^a[0-9]+$/).optional(),
    priority: zPriority.optional(),
    labels: z.array(z.string()).optional(),
    dueAt: z.string().datetime().optional(),
    assigned: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    value: z.enum(['+1', '-1']).optional(),
    relatedTo: z.array(z.string().regex(/^a[0-9]+$/)).optional(),
    expiresInSeconds: z.number().int().gte(60).lte(86400).optional()
});

/**
 * Single append item for atomic multi-append (author inherited from parent)
 */
export const zAppendItem = z.object({
    type: zUserAppendType,
    content: z.string().optional(),
    ref: z.string().regex(/^a[0-9]+$/).optional(),
    priority: zPriority.optional(),
    labels: z.array(z.string()).optional(),
    dueAt: z.string().datetime().optional(),
    assigned: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    value: z.enum(['+1', '-1']).optional(),
    relatedTo: z.array(z.string().regex(/^a[0-9]+$/)).optional(),
    expiresInSeconds: z.number().int().gte(60).lte(86400).optional()
});

/**
 * Request body for atomic multi-append operation
 */
export const zMultiAppendRequest = z.object({
    path: z.string().optional(),
    author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/),
    appends: z.array(zAppendItem).max(100)
});

/**
 * Result of a single append operation
 */
export const zSingleAppendResult = z.object({
    id: z.string().regex(/^a[0-9]+$/),
    author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/),
    ts: z.string().datetime(),
    type: zAppendType,
    ref: z.string().regex(/^a[0-9]+$/).optional(),
    expiresAt: z.string().datetime().optional(),
    expiresInSeconds: z.number().int().optional(),
    status: zAppendStatus.optional(),
    priority: zPriority.optional(),
    labels: z.array(z.string()).optional(),
    dueAt: z.string().datetime().optional(),
    taskStatus: z.enum(['open', 'done']).optional(),
    value: z.enum(['+1', '-1']).optional()
});

/**
 * Result of atomic multi-append operation
 */
export const zMultiAppendResult = z.object({
    appends: z.array(z.object({
        id: z.string().regex(/^a[0-9]+$/),
        type: zAppendType,
        ref: z.string().regex(/^a[0-9]+$/).optional(),
        expiresAt: z.string().datetime().optional(),
        expiresInSeconds: z.number().int().optional()
    }))
});

/**
 * Response for append operations
 */
export const zAppendResponse = z.object({
    ok: z.literal(true),
    serverTime: z.string().datetime(),
    data: z.union([
        zSingleAppendResult,
        zMultiAppendResult
    ]),
    webUrl: z.string().url().optional()
});

/**
 * Request body for scoped path-based append
 */
export const zScopedAppendRequest = z.object({
    author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    type: z.string().optional(),
    content: z.string().optional()
});

/**
 * Result of a scoped append operation
 */
export const zScopedAppendResult = z.object({
    appendId: z.string().regex(/^a[0-9]+$/),
    type: z.string().optional(),
    author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    createdAt: z.string().datetime()
});

/**
 * Response for scoped path-based append operations
 */
export const zScopedAppendResponse = z.object({
    ok: z.literal(true),
    data: zScopedAppendResult
});

/**
 * Type of item in folder listing
 */
export const zFolderItemType = z.enum(['file', 'folder']);

/**
 * An item in a folder listing (file or subfolder)
 */
export const zFolderItem: z.AnyZodObject = z.object({
    name: z.string(),
    type: zFolderItemType,
    size: z.number().int().optional(),
    updatedAt: z.string().datetime().optional(),
    appendCount: z.number().int().optional(),
    childCount: z.number().int().optional(),
    urls: zCapabilityUrls.optional(),
    items: z.array(z.lazy(() => zFolderItem)).optional()
});

export const zPaginatedResponse = z.object({
    cursor: z.string().optional(),
    hasMore: z.boolean().optional(),
    total: z.number().int().optional()
});

export const zFolderListResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        path: z.string(),
        items: z.array(zFolderItem),
        webUrl: z.string().url().optional(),
        workspace: zWorkspaceContext.optional()
    }),
    pagination: zPaginatedResponse.optional()
});

export const zCreateFileRequest = z.object({
    filename: z.string().max(255),
    content: z.string().optional()
});

export const zCreateFileResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        filename: z.string(),
        path: z.string(),
        urls: zCapabilityUrls,
        createdAt: z.string().datetime(),
        webUrl: z.string().url().optional()
    })
});

/**
 * Request body for cascade delete of non-empty folders
 */
export const zFolderDeleteRequest = z.object({
    cascade: z.boolean().optional(),
    confirmPath: z.string().optional()
});

export const zFolderDeleteResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        deleted: z.literal(true),
        path: z.string(),
        filesDeleted: z.number().int().optional(),
        foldersDeleted: z.number().int().optional(),
        recoverable: z.boolean().optional(),
        expiresAt: z.string().datetime().optional()
    })
});

export const zFolderRenameRequest = z.object({
    name: z.string().max(255)
});

export const zFolderMoveResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        previousPath: z.string(),
        newPath: z.string(),
        filesUpdated: z.number().int().optional(),
        webUrl: z.string().url().optional()
    })
});

export const zFolderCreateRequest = z.object({
    name: z.string().max(255),
    path: z.string().optional()
});

export const zFolderCreateResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        path: z.string(),
        urls: zCapabilityUrls,
        createdAt: z.string().datetime(),
        webUrl: z.string().url().optional()
    })
});

/**
 * Request body for copying a file into a folder
 */
export const zCopyFileToFolderRequest = z.object({
    sourceKey: z.string(),
    filename: z.string().optional()
});

/**
 * Single file to create in bulk operation
 */
export const zFolderBulkCreateItem = z.object({
    filename: z.string().max(255),
    content: z.string().optional()
});

/**
 * Request body for bulk file creation
 */
export const zFolderBulkCreateRequest = z.object({
    files: z.array(zFolderBulkCreateItem).max(100)
});

/**
 * Result for a single file in bulk create
 */
export const zFolderBulkCreateResultItem = z.object({
    filename: z.string(),
    id: z.string(),
    urls: zCapabilityUrls,
    webUrl: z.string().url().optional()
});

export const zFolderBulkCreateResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        created: z.array(zFolderBulkCreateResultItem),
        webUrl: z.string().url().optional()
    })
});

/**
 * Response for async bulk file creation (202 Accepted)
 */
export const zFolderBulkCreateJobResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        jobId: z.string()
    })
});

export const zFolderMoveRequest = z.object({
    destination: z.string()
});

/**
 * Folder-level settings
 */
export const zFolderSettings = z.object({
    inheritSettings: z.boolean().optional(),
    defaultLabels: z.array(z.string()).optional(),
    allowedTypes: z.array(z.enum([
        'task',
        'claim',
        'response',
        'comment',
        'blocked',
        'answer',
        'renew',
        'cancel',
        'vote'
    ])).optional()
});

export const zFolderSettingsResponse = z.object({
    ok: z.literal(true),
    data: zFolderSettings
});

/**
 * Partial update for folder settings
 */
export const zFolderSettingsUpdateRequest = z.object({
    inheritSettings: z.boolean().optional(),
    defaultLabels: z.array(z.string()).optional(),
    allowedTypes: z.array(z.enum([
        'task',
        'claim',
        'response',
        'comment',
        'blocked',
        'answer',
        'renew',
        'cancel',
        'vote'
    ])).optional()
});

export const zFolderStatsResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        path: z.string(),
        fileCount: z.number().int(),
        folderCount: z.number().int(),
        totalSize: z.number().int(),
        updatedAt: z.string().datetime().optional(),
        taskStats: zTaskStats.optional()
    })
});

/**
 * Reference to a file with ID and path
 */
export const zFileReference = z.object({
    id: z.string(),
    path: z.string()
});

/**
 * Capability URLs for file access (only includes URLs the key has access to)
 */
export const zFileUrls = z.object({
    read: z.string().url().optional(),
    append: z.string().url().optional(),
    write: z.string().url().optional()
});

/**
 * Single match within a file for folder search
 */
export const zFolderSearchMatch = z.object({
    appendId: z.string(),
    type: z.string(),
    content: z.string(),
    priority: z.string().optional(),
    status: z.string().optional(),
    labels: z.array(z.string()).optional(),
    author: z.string().optional(),
    createdAt: z.string().datetime().optional()
});

/**
 * Search results grouped by file
 */
export const zFolderSearchResult = z.object({
    file: zFileReference,
    fileUrls: zFileUrls.optional(),
    matches: z.array(zFolderSearchMatch).optional()
});

/**
 * Response from folder search endpoint
 */
export const zFolderSearchResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        results: z.array(zFolderSearchResult),
        truncated: z.boolean().optional()
    }),
    pagination: zPaginatedResponse.optional()
});

/**
 * Task result from task query endpoint
 */
export const zTaskQueryResult = z.object({
    id: z.string(),
    file: zFileReference,
    fileUrls: zFileUrls.optional(),
    content: z.string(),
    author: z.string().optional(),
    status: z.enum([
        'pending',
        'claimed',
        'completed',
        'cancelled'
    ]),
    priority: z.enum([
        'low',
        'medium',
        'high',
        'critical'
    ]).optional(),
    labels: z.array(z.string()).optional(),
    claimedBy: z.string().optional(),
    expiresAt: z.string().datetime().optional(),
    createdAt: z.string().datetime()
});

/**
 * Summary counts of tasks by status
 */
export const zTaskSummary = z.object({
    pending: z.number().int(),
    claimed: z.number().int(),
    completed: z.number().int()
});

/**
 * Response from task query endpoint
 */
export const zTaskQueryResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        tasks: z.array(zTaskQueryResult),
        summary: zTaskSummary,
        webUrl: z.string().url()
    }),
    pagination: zPaginatedResponse.optional()
});

/**
 * Event types that can trigger webhooks
 */
export const zWebhookEvent = z.enum([
    'append',
    'append.created',
    'task.created',
    'task.claimed',
    'task.completed',
    'task.cancelled',
    'task.blocked',
    'task.unblocked',
    'task.overdue',
    'task.escalated',
    'task.recurred',
    'task.expired',
    'claim.created',
    'claim.expired',
    'claim.renewed',
    'claim.released',
    'file.created',
    'file.updated',
    'file.deleted',
    'heartbeat',
    'webhook.failed',
    'settings.changed'
]);

/**
 * Webhook status
 */
export const zWebhookStatus = z.enum([
    'active',
    'paused',
    'suspended',
    'disabled'
]);

/**
 * Webhook configuration
 */
export const zWebhook = z.object({
    id: z.string(),
    url: z.string().url(),
    events: z.array(zWebhookEvent),
    status: zWebhookStatus,
    includeUrls: z.boolean().optional(),
    createdAt: z.string().datetime(),
    lastTriggeredAt: z.string().datetime().optional(),
    failureCount: z.number().int().optional(),
    successRate: z.number().gte(0).lte(1).optional()
});

export const zWebhookListResponse = z.object({
    ok: z.literal(true),
    data: z.array(zWebhook),
    webUrl: z.string().url().optional()
});

/**
 * Request to register a new webhook
 */
export const zWebhookCreateRequest = z.object({
    url: z.string().url(),
    events: z.array(zWebhookEvent),
    secret: z.string().min(32).optional(),
    headers: z.record(z.string()).optional(),
    includeUrls: z.boolean().optional().default(true),
    filters: z.object({
        types: z.array(z.string()).optional(),
        labels: z.array(z.string()).optional(),
        priority: z.array(z.string()).optional()
    }).optional(),
    recursive: z.boolean().optional()
});

export const zWebhookCreateResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        url: z.string().url(),
        events: z.array(zWebhookEvent),
        status: zWebhookStatus,
        secret: z.string().optional(),
        includeUrls: z.boolean().optional(),
        createdAt: z.string().datetime(),
        webUrl: z.string().url().optional()
    })
});

export const zWebhookDeleteResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        deleted: z.literal(true)
    })
});

/**
 * Partial update for webhook configuration
 */
export const zWebhookUpdateRequest = z.object({
    url: z.string().url().optional(),
    events: z.array(zWebhookEvent).optional(),
    active: z.boolean().optional(),
    secret: z.string().min(32).optional(),
    headers: z.record(z.string()).optional(),
    includeUrls: z.boolean().optional(),
    filters: z.object({
        types: z.array(z.string()).optional(),
        labels: z.array(z.string()).optional(),
        priority: z.array(z.string()).optional()
    }).optional(),
    recursive: z.boolean().optional()
});

export const zWebhookUpdateResponse = z.object({
    ok: z.literal(true),
    data: zWebhook
});

/**
 * File information for a claim
 */
export const zFolderClaimFileInfo = z.object({
    id: z.string(),
    path: z.string()
});

/**
 * A single claim in a folder
 */
export const zFolderClaimItem = z.object({
    taskId: z.string(),
    claimId: z.string(),
    file: zFolderClaimFileInfo,
    taskContent: z.string(),
    status: z.enum(['active', 'expired']),
    expiresAt: z.string().datetime(),
    expiresInSeconds: z.number().int()
});

export const zFolderClaimsResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        claims: z.array(zFolderClaimItem),
        count: z.number().int(),
        webUrl: z.string().url()
    })
});

/**
 * Permission level for scoped keys
 */
export const zKeyPermission = z.enum([
    'read',
    'append',
    'write'
]);

/**
 * Scoped key metadata (key itself is partially redacted)
 */
export const zScopedKey = z.object({
    id: z.string(),
    key: z.string().optional(),
    permission: zKeyPermission,
    boundAuthor: z.string().optional(),
    displayName: z.string().optional(),
    wipLimit: z.number().int().optional(),
    allowedTypes: z.array(z.string()).optional(),
    createdAt: z.string().datetime(),
    expiresAt: z.string().datetime().optional(),
    lastUsedAt: z.string().datetime().optional(),
    revoked: z.boolean().optional()
});

export const zScopedKeyListResponse = z.object({
    ok: z.literal(true),
    data: z.array(zScopedKey),
    webUrl: z.string().url().optional()
});

/**
 * Request to create a scoped capability key
 */
export const zScopedKeyCreateRequest = z.object({
    permission: zKeyPermission,
    boundAuthor: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    displayName: z.string().max(64).optional(),
    wipLimit: z.number().int().gte(1).optional(),
    allowedTypes: z.array(z.enum([
        'task',
        'claim',
        'response',
        'comment',
        'blocked',
        'answer',
        'renew',
        'cancel',
        'vote'
    ])).optional(),
    expiresAt: z.string().datetime().optional(),
    paths: z.array(z.string()).optional()
});

export const zScopedKeyCreateResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        key: z.string().regex(/^(r|a|w)_[A-Za-z0-9]{20,}$/),
        permission: zKeyPermission,
        boundAuthor: z.string().optional(),
        displayName: z.string().optional(),
        wipLimit: z.number().int().optional(),
        allowedTypes: z.array(z.string()).optional(),
        expiresAt: z.string().datetime().optional(),
        createdAt: z.string().datetime(),
        webUrl: z.string().url().optional()
    })
});

export const zKeyRevokeResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        revoked: z.literal(true)
    })
});

export const zCapabilitiesCheckRequest = z.object({
    keys: z.array(z.string()).max(100)
});

export const zCapabilityCheckResult = z.object({
    key: z.string(),
    valid: z.boolean(),
    permission: z.enum([
        'read',
        'append',
        'write'
    ]).optional(),
    scope: z.enum([
        'file',
        'folder',
        'workspace'
    ]).optional(),
    scopeId: z.string().optional(),
    error: z.string().optional()
});

export const zCapabilitiesCheckResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        results: z.array(zCapabilityCheckResult)
    })
});

/**
 * Workspace summary for user
 */
export const zWorkspace = z.object({
    id: z.string(),
    name: z.string()
});

/**
 * Current authenticated user information
 */
export const zMeResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        email: z.string().email(),
        name: z.string().optional(),
        image: z.string().url().optional(),
        workspaces: z.array(zWorkspace),
        createdAt: z.string().datetime().optional(),
        webUrl: z.string().url().optional()
    })
});

export const zLogoutResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        status: z.literal('logged_out').optional()
    })
});

/**
 * Response from claim workspace endpoint (always instant with OAuth)
 */
export const zClaimWorkspaceResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        claimed: z.literal(true),
        message: z.string(),
        webUrl: z.string().url().optional()
    })
});

export const zWorkspaceRenameRequest = z.object({
    name: z.string().min(1).max(255).regex(/.*\S.*/)
});

export const zWorkspaceRenameResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        workspaceId: z.string(),
        name: z.string(),
        updatedAt: z.string().datetime()
    })
});

export const zSuccessResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        message: z.string().optional()
    }).optional()
});

export const zRotateAllResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        workspaceId: z.string(),
        message: z.string(),
        rotatedCount: z.number().int(),
        keys: zBootstrapKeys,
        urls: zBootstrapUrls,
        keyCustodyWarning: z.string()
    })
});

/**
 * API key metadata (returned in list operations)
 */
export const zApiKey = z.object({
    id: z.string(),
    name: z.string(),
    permissions: z.array(z.enum([
        'read',
        'append',
        'write',
        'export'
    ])),
    createdAt: z.string().datetime(),
    expiresAt: z.string().datetime().optional(),
    lastUsedAt: z.string().datetime().optional(),
    prefix: z.string().regex(/^sk_(live|test)_[A-Za-z0-9]{4}\.\.\.$/)
});

/**
 * Response containing list of API keys
 */
export const zApiKeyListResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        keys: z.array(zApiKey),
        webUrl: z.string().url().optional()
    })
});

/**
 * Request to create a new API key
 */
export const zApiKeyCreateRequest = z.object({
    name: z.string().max(64),
    permissions: z.array(z.enum([
        'read',
        'append',
        'write',
        'export'
    ])).min(1),
    expiresInSeconds: z.number().int().gte(3600).optional()
});

/**
 * Response from API key creation (key shown only once)
 */
export const zApiKeyCreateResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        key: z.string().regex(/^sk_(live|test)_[A-Za-z0-9]{20,}$/),
        name: z.string(),
        permissions: z.array(z.enum([
            'read',
            'append',
            'write',
            'export'
        ])),
        createdAt: z.string().datetime(),
        expiresAt: z.string().datetime().optional(),
        webUrl: z.string().url().optional()
    })
});

/**
 * Response from API key revocation
 */
export const zApiKeyRevokeResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        revoked: z.literal(true)
    })
});

/**
 * Delivery status
 */
export const zWebhookLogStatus = z.enum([
    'ok',
    'failed',
    'timeout',
    'error'
]);

/**
 * Single webhook delivery log entry
 */
export const zWebhookLogEntry = z.object({
    id: z.string(),
    event: zWebhookEvent,
    status: zWebhookLogStatus,
    responseCode: z.number().int().optional(),
    timestamp: z.string().datetime(),
    durationMs: z.number().int().optional(),
    error: z.string().optional()
});

export const zWebhookLogsResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        logs: z.array(zWebhookLogEntry),
        pagination: zPaginatedResponse.optional()
    })
});

/**
 * Request to send a test webhook
 */
export const zWebhookTestRequest = z.object({
    event: zWebhookEvent.optional()
});

export const zWebhookTestResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        delivered: z.boolean(),
        responseCode: z.number().int().optional(),
        durationMs: z.number().int(),
        error: z.string().optional()
    })
});

/**
 * Type of search result
 */
export const zSearchResultType = z.enum([
    'file',
    'append',
    'task'
]);

/**
 * Highlighted match position in content
 */
export const zSearchHighlight = z.object({
    start: z.number().int(),
    end: z.number().int()
});

/**
 * Single search result item
 */
export const zSearchResult = z.object({
    type: zSearchResultType,
    id: z.string(),
    file: zFileReference.optional(),
    content: z.string(),
    highlights: z.array(zSearchHighlight),
    score: z.number().gte(0).lte(1),
    status: z.string().optional(),
    author: z.string().optional(),
    createdAt: z.string().datetime().optional(),
    frontmatter: z.record(z.unknown()).optional()
});

/**
 * Response from workspace/scoped search endpoints
 */
export const zSearchResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        results: z.array(zSearchResult),
        total: z.number().int().gte(0).optional()
    }),
    pagination: zPaginatedResponse.optional()
});

/**
 * Agent liveness status
 */
export const zHeartbeatStatus = z.enum([
    'alive',
    'idle',
    'busy',
    'error',
    'stale'
]);

/**
 * Request to send agent heartbeat
 */
export const zHeartbeatRequest = z.object({
    author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/),
    status: zHeartbeatStatus,
    currentTask: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    metadata: z.record(z.unknown()).optional()
});

/**
 * Response from heartbeat endpoint
 */
export const zHeartbeatResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/),
        ts: z.string().datetime(),
        expiresAt: z.string().datetime(),
        nextHeartbeatBy: z.string().datetime()
    })
});

export const zStatsScope = z.object({
    type: z.enum([
        'file',
        'folder',
        'workspace'
    ]),
    id: z.string()
});

export const zStatsCounts = z.object({
    files: z.number().int(),
    appends: z.number().int(),
    tasks: z.number().int(),
    claims: z.number().int(),
    agents: z.number().int()
});

export const zStatsActivity = z.object({
    lastAppendAt: z.union([
        z.string().datetime(),
        z.null()
    ]),
    appendsToday: z.number().int(),
    appendsThisWeek: z.number().int()
});

export const zStatsViaWriteKeyResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        scope: zStatsScope,
        counts: zStatsCounts,
        activity: zStatsActivity
    })
});

export const zStatsErrorResponse = z.object({
    ok: z.literal(false).optional(),
    error: z.object({
        code: z.enum([
            'INVALID_KEY',
            'KEY_EXPIRED',
            'KEY_REVOKED',
            'PERMISSION_DENIED'
        ]).optional()
    }).optional()
});

export const zFileStatsResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        appendCount: z.number().int(),
        taskStats: zTaskStats
    })
});

export const zWorkspaceStatsResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        fileCount: z.number().int(),
        folderCount: z.number().int(),
        totalSize: z.number().int(),
        appendCount: z.number().int(),
        taskStats: zTaskStats,
        storageUsed: z.number().int(),
        storageLimit: z.number().int()
    })
});

/**
 * Status of an async job
 */
export const zJobStatus = z.enum([
    'pending',
    'processing',
    'completed',
    'failed'
]);

/**
 * Response containing job status and details
 */
export const zJobResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        status: zJobStatus,
        progress: z.object({
            current: z.number().int().optional(),
            total: z.number().int().optional(),
            message: z.string().optional()
        }).optional(),
        result: z.record(z.unknown()).optional(),
        error: z.object({
            code: z.string().optional(),
            message: z.string().optional()
        }).optional(),
        createdAt: z.string().datetime(),
        completedAt: z.string().datetime().optional()
    })
});

export const zExportJobCreateResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        jobId: z.string(),
        status: z.enum(['queued', 'processing']),
        statusUrl: z.string(),
        estimatedSize: z.string().optional(),
        position: z.number().int().optional()
    })
});

export const zExportJobStatusResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        status: z.enum([
            'queued',
            'processing',
            'ready',
            'failed',
            'expired'
        ]),
        progress: z.object({
            filesProcessed: z.number().int().optional(),
            totalFiles: z.number().int().optional(),
            bytesWritten: z.string().optional()
        }).optional(),
        startedAt: z.string().datetime().optional(),
        downloadUrl: z.string().optional(),
        expiresAt: z.string().datetime().optional(),
        checksum: z.string().optional(),
        size: z.string().optional(),
        error: z.object({
            code: z.string().optional(),
            message: z.string().optional()
        }).optional()
    })
});

export const zDeletedFileEntry = z.object({
    id: z.string(),
    path: z.string(),
    deletedAt: z.string().datetime(),
    expiresAt: z.string().datetime(),
    deletedBy: z.string().optional(),
    size: z.number().int().optional()
});

export const zDeletedFilesListResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        files: z.array(zDeletedFileEntry)
    }),
    pagination: z.object({
        cursor: z.string().optional(),
        hasMore: z.boolean().optional(),
        total: z.number().int().optional()
    }).optional()
});

/**
 * Current liveness state of an agent
 */
export const zAgentLiveness = z.object({
    author: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/),
    status: zHeartbeatStatus,
    lastSeen: z.string().datetime(),
    stale: z.boolean().optional(),
    currentTask: z.string().regex(/^[a-zA-Z0-9_-]{1,64}$/).optional(),
    metadata: z.record(z.unknown()).optional()
});

/**
 * Response containing agent liveness information
 */
export const zAgentLivenessResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        agents: z.array(zAgentLiveness),
        staleThresholdSeconds: z.number().int(),
        webUrl: z.string().url().optional()
    })
});

export const zOrchestrationSummary = z.object({
    pending: z.number().int(),
    claimed: z.number().int(),
    completed: z.number().int(),
    stalled: z.number().int(),
    cancelled: z.number().int()
});

export const zOrchestrationTask = z.object({
    id: z.string(),
    file: z.object({
        id: z.string(),
        path: z.string()
    }),
    content: z.string(),
    author: z.string(),
    status: z.enum([
        'pending',
        'claimed',
        'stalled',
        'completed',
        'cancelled'
    ]),
    priority: z.enum([
        'low',
        'medium',
        'high',
        'critical'
    ]).optional(),
    labels: z.array(z.string()).optional(),
    createdAt: z.string().datetime(),
    due: z.string().datetime().optional(),
    claim: z.object({
        id: z.string().optional(),
        author: z.string().optional(),
        expiresAt: z.string().datetime().optional(),
        blocked: z.boolean().optional(),
        blockReason: z.string().optional()
    }).optional()
});

export const zOrchestrationClaim = z.object({
    id: z.string(),
    taskId: z.string(),
    file: z.object({
        id: z.string(),
        path: z.string()
    }),
    author: z.string(),
    expiresAt: z.string().datetime(),
    expiresInSeconds: z.number().int().optional(),
    status: z.enum([
        'active',
        'blocked',
        'expired'
    ]),
    blocked: z.boolean().optional(),
    blockReason: z.string().optional()
});

export const zOrchestrationAgentStatus = z.object({
    author: z.string().optional(),
    status: z.enum([
        'alive',
        'idle',
        'busy',
        'stale'
    ]).optional(),
    lastSeen: z.string().datetime().optional(),
    currentTask: z.string().optional()
});

export const zOrchestrationWorkload = z.object({
    activeClaims: z.number().int().optional(),
    completedToday: z.number().int().optional()
});

export const zOrchestrationReadOnlyResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        summary: zOrchestrationSummary,
        tasks: z.array(zOrchestrationTask),
        claims: z.array(zOrchestrationClaim),
        agents: z.array(zOrchestrationAgentStatus),
        workload: z.record(zOrchestrationWorkload),
        pagination: z.object({
            cursor: z.string().optional(),
            hasMore: z.boolean().optional()
        }).optional(),
        webUrl: z.string().url().optional()
    })
});

export const zOrchestrationAdminResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        summary: zOrchestrationSummary,
        tasks: z.array(zOrchestrationTask),
        claims: z.array(zOrchestrationClaim.and(z.object({
            canForceExpire: z.literal(true).optional()
        }))),
        agents: z.array(zOrchestrationAgentStatus),
        workload: z.record(zOrchestrationWorkload),
        pagination: z.object({
            cursor: z.string().optional(),
            hasMore: z.boolean().optional()
        }).optional(),
        webUrl: z.string().url().optional()
    })
});

export const zRenewClaimRequest = z.object({
    expiresInSeconds: z.number().int().gte(60).lte(86400).optional().default(300)
});

/**
 * Claim data formatted for control view display
 */
export const zControlClaim = z.object({
    id: z.string(),
    taskId: z.string(),
    taskTitle: z.string().optional(),
    path: z.string(),
    appendKey: z.string().optional(),
    author: z.string(),
    status: z.enum([
        'active',
        'expired',
        'completed',
        'cancelled',
        'blocked'
    ]),
    claimedAt: z.string().datetime().optional(),
    expiresAt: z.string().datetime(),
    expiresInSeconds: z.number().int().optional(),
    completedAt: z.string().datetime().optional(),
    blockedReason: z.string().optional()
});

export const zClaimMutationResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        claim: zControlClaim,
        appendId: z.string().optional(),
        webUrl: z.string().url().optional()
    })
});

export const zCompleteClaimRequest = z.object({
    content: z.string().optional()
});

export const zCancelClaimRequest = z.object({
    reason: z.string().optional()
});

export const zBlockClaimRequest = z.object({
    reason: z.string().min(1).max(500)
});

export const zFileCreateResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        id: z.string(),
        path: z.string(),
        urls: zCapabilityUrls,
        createdAt: z.string().datetime(),
        webUrl: z.string().url().optional()
    })
});

/**
 * Simple health check response for liveness probes
 */
export const zHealthCheckSimpleResponse = z.object({
    ok: z.literal(true),
    status: z.enum(['healthy']),
    timestamp: z.string().datetime().optional(),
    uptimeSeconds: z.number().int().optional(),
    version: z.string().optional()
});

/**
 * Type of changelog entry
 */
export const zChangeType = z.enum([
    'added',
    'changed',
    'deprecated',
    'removed',
    'fixed',
    'security'
]);

/**
 * Single changelog entry
 */
export const zChangelogEntry = z.object({
    version: z.string(),
    date: z.string().date(),
    changes: z.array(z.object({
        type: zChangeType,
        description: z.string()
    }))
});

/**
 * Response containing changelog entries
 */
export const zChangelogResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        currentVersion: z.string(),
        releasedAt: z.string().datetime(),
        entries: z.array(zChangelogEntry)
    })
});

/**
 * Status of a deployment region
 */
export const zRegionStatus = z.object({
    name: z.string(),
    status: z.enum([
        'operational',
        'degraded',
        'down'
    ])
});

/**
 * Response from status endpoint with system information
 */
export const zStatusResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        status: z.enum([
            'operational',
            'degraded',
            'partial_outage',
            'major_outage'
        ]),
        timestamp: z.string().datetime(),
        environment: z.enum([
            'development',
            'test',
            'production'
        ]),
        uptimeSeconds: z.number().int(),
        version: z.string(),
        database: z.object({
            status: z.enum([
                'operational',
                'degraded',
                'down'
            ]),
            latencyMs: z.number().optional()
        }),
        storage: z.object({
            status: z.enum([
                'operational',
                'degraded',
                'down'
            ]),
            latencyMs: z.number().optional()
        }),
        websocket: z.object({
            status: z.enum([
                'operational',
                'degraded',
                'down'
            ]),
            latencyMs: z.number().optional(),
            activeConnections: z.number().int().gte(0).optional()
        }),
        regions: z.array(zRegionStatus)
    })
});

export const zCapabilityCheckInWorkspaceResult = z.object({
    key: z.string(),
    valid: z.boolean(),
    permission: z.enum([
        'read',
        'append',
        'write'
    ]).optional(),
    scope: z.enum([
        'file',
        'folder',
        'workspace'
    ]).optional(),
    scopeId: z.string().optional(),
    path: z.string().optional(),
    status: z.enum([
        'active',
        'expired',
        'revoked'
    ]).optional(),
    error: z.string().optional()
});

export const zCapabilitiesCheckInWorkspaceResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        results: z.array(zCapabilityCheckInWorkspaceResult)
    })
});

export const zAuditLogEntry = z.object({
    id: z.string(),
    action: z.string(),
    resourceType: z.string(),
    resourceId: z.string().optional(),
    resourcePath: z.string().optional(),
    actor: z.string().optional(),
    actorType: z.enum([
        'capability_url',
        'api_key',
        'session'
    ]).optional(),
    metadata: z.record(z.unknown()).optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    createdAt: z.string().datetime()
});

export const zAuditLogPagination = z.object({
    total: z.number().int(),
    limit: z.number().int(),
    cursor: z.union([
        z.string(),
        z.null()
    ]),
    hasMore: z.boolean()
});

export const zAuditLogsResponse = z.object({
    ok: z.literal(true),
    data: z.array(zAuditLogEntry),
    pagination: zAuditLogPagination
});

export const zAdminMetricsResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        storage: z.object({
            databaseSizeBytes: z.number().int(),
            databaseSizeMB: z.number(),
            maxSizeBytes: z.number().int().optional(),
            maxSizeMB: z.number().optional(),
            usagePercent: z.number()
        }),
        counts: z.object({
            workspaces: z.number().int(),
            files: z.number().int(),
            folders: z.number().int(),
            users: z.number().int(),
            activeSessions: z.number().int(),
            capabilityKeys: z.number().int()
        }),
        quotas: z.object({
            maxWorkspaceStorageBytes: z.number().int(),
            maxFileSizeBytes: z.number().int()
        }),
        uptime: z.object({
            seconds: z.number().int(),
            formatted: z.string()
        })
    })
});

export const zFolderUrls = z.object({
    path: z.string(),
    urls: zCapabilityUrls
});

/**
 * User information
 */
export const zUser = z.object({
    id: z.string(),
    email: z.string().email(),
    createdAt: z.string().datetime().optional()
});

/**
 * Request to claim a workspace (OAuth session provides identity)
 */
export const zClaimWorkspaceRequest = z.record(z.never());

/**
 * Type of WebSocket message type
 */
export const zSubscribeMessageType = z.enum(['connected', 'error']);

/**
 * WebSocket control message
 */
export const zSubscribeMessage = z.object({
    type: zSubscribeMessageType,
    data: z.record(z.unknown())
});

/**
 * Overall system health status
 */
export const zHealthStatus = z.enum([
    'healthy',
    'degraded',
    'unhealthy'
]);

/**
 * Response from health check endpoint
 */
export const zHealthResponse = z.object({
    ok: z.literal(true),
    status: zHealthStatus,
    version: z.string(),
    checks: z.record(z.object({
        status: zHealthStatus.optional(),
        latencyMs: z.number().int().optional(),
        message: z.string().optional()
    }))
});

export const zTransferWorkspaceRequest = z.object({
    newOwnerEmail: z.string().email()
});

export const zFolderClaimEntry = z.object({
    id: z.string(),
    fileId: z.string(),
    path: z.string(),
    taskId: z.string(),
    taskContent: z.string().optional(),
    author: z.string(),
    expiresAt: z.string().datetime(),
    expiresInSeconds: z.number().int().optional(),
    status: z.enum([
        'active',
        'blocked',
        'expired'
    ]),
    blockedAt: z.string().datetime().optional(),
    blockReason: z.string().optional()
});

export const zFolderClaimsViaAppendKeyResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        claims: z.array(zFolderClaimEntry),
        count: z.number().int(),
        webUrl: z.string().url().optional()
    })
});

export const zListWorkspaceClaimsResponse = z.object({
    ok: z.literal(true),
    data: z.object({
        claims: z.array(zControlClaim),
        webUrl: z.string().url().optional()
    })
});

/**
 * Capability key (20+ chars, base62 with underscore)
 */
export const zCapabilityKey = z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/);

/**
 * Response format
 */
export const zFormat = z.enum([
    'raw',
    'parsed',
    'structure'
]);

/**
 * Return items modified after this timestamp (ISO 8601)
 */
export const zSince = z.string().datetime();

/**
 * Append identifier (e.g., a1, a42)
 */
export const zAppendId = z.string().regex(/^a[0-9]+$/);

/**
 * URL-encoded folder path
 */
export const zFolderPath = z.string();

/**
 * Maximum number of items to return
 */
export const zLimit = z.number().int().gte(1).lte(1000).default(50);

/**
 * Pagination cursor for fetching next page
 */
export const zCursor = z.string();

/**
 * URL-encoded folder path (omit for workspace root)
 */
export const zFolderPathQuery = z.string();

/**
 * Filter by author identifier
 */
export const zAuthor = z.string();

/**
 * Scoped key identifier
 */
export const zKeyId = z.string();

/**
 * Workspace identifier
 */
export const zWorkspaceId = z.string().regex(/^ws_[A-Za-z0-9]{12,}$/);

/**
 * Webhook identifier
 */
export const zWebhookId = z.string();

/**
 * Background job identifier
 */
export const zJobId = z.string();

/**
 * The claim's append ID
 */
export const zClaimId = z.string();

export const zCreateWorkspaceData = z.object({
    body: zBootstrapRequest,
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Workspace created successfully
 */
export const zCreateWorkspaceResponse = zBootstrapResponse;

export const zReadFileData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        format: z.enum([
            'raw',
            'parsed',
            'structure'
        ]).optional(),
        since: z.string().datetime().optional(),
        appends: z.number().int().gte(0).lte(1000).optional(),
        include: z.enum(['stats']).optional()
    }).optional()
});

/**
 * File content retrieved successfully
 */
export const zReadFileResponse = zFileReadResponse;

export const zDeleteFileData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        permanent: z.boolean().optional().default(false)
    }).optional()
});

/**
 * File deleted successfully
 */
export const zDeleteFileResponse = zFileDeleteResponse;

export const zReadFileViaWriteKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        format: z.enum([
            'raw',
            'parsed',
            'structure'
        ]).optional(),
        since: z.string().datetime().optional(),
        appends: z.number().int().gte(0).lte(1000).optional(),
        include: z.enum(['stats']).optional()
    }).optional()
});

/**
 * File content retrieved successfully
 */
export const zReadFileViaWriteKeyResponse = zFileReadResponse;

export const zRenameFileData = z.object({
    body: zFileRenameRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * File renamed successfully
 */
export const zRenameFileResponse = zFileRenameResponse;

export const zUpdateFileData = z.object({
    body: zFileUpdateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional(),
    headers: z.object({
        'If-Match': z.string().optional()
    }).optional()
});

/**
 * File updated successfully
 */
export const zUpdateFileResponse = zFileUpdateResponse;

export const zReadFileRawData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Raw markdown content
 */
export const zReadFileRawResponse = z.string();

export const zReadFileMetaData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * File metadata retrieved successfully
 */
export const zReadFileMetaResponse = zFileMetaResponse;

export const zReadFileTailData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        bytes: z.number().int().lte(100000).optional().default(10000),
        lines: z.number().int().lte(1000).optional()
    }).optional()
});

/**
 * Tail content retrieved successfully
 */
export const zReadFileTailResponse = zFileTailResponse;

export const zReadFileStructureData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * File structure retrieved successfully
 */
export const zReadFileStructureResponse = zFileStructureResponse;

export const zReadFileSectionData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        heading: z.string()
    }),
    query: z.never().optional()
});

/**
 * Section content retrieved successfully
 */
export const zReadFileSectionResponse = zFileSectionResponse;

export const zReadAppendData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        appendId: z.string().regex(/^a[0-9]+$/)
    }),
    query: z.never().optional()
});

/**
 * Append retrieved successfully
 */
export const zReadAppendResponse = zAppendGetResponse;

export const zRecoverFileData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        rotateUrls: z.boolean().optional().default(false)
    }).optional()
});

/**
 * File recovered successfully
 */
export const zRecoverFileResponse = zFileRecoverResponse;

export const zMoveFileData = z.object({
    body: zFileMoveRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * File moved successfully
 */
export const zMoveFileResponse = zFileMoveResponse;

export const zRotateCapabilityUrlsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * URLs rotated successfully
 */
export const zRotateCapabilityUrlsResponse = zFileRotateUrlsResponse;

export const zGetFileSettingsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * File settings retrieved successfully
 */
export const zGetFileSettingsResponse = zFileSettingsResponse;

export const zUpdateFileSettingsData = z.object({
    body: zFileSettingsUpdateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * File settings updated successfully
 */
export const zUpdateFileSettingsResponse = zFileSettingsResponse;

export const zCreateAppendData = z.object({
    body: z.union([
        zAppendRequest,
        zMultiAppendRequest
    ]),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Append created successfully
 */
export const zCreateAppendResponse = zAppendResponse;

export const zCreateScopedAppendData = z.object({
    body: zScopedAppendRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Append created successfully
 */
export const zCreateScopedAppendResponse = zScopedAppendResponse;

export const zListFolderContentsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.object({
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional(),
        action: z.enum(['export']).optional(),
        format: z.enum(['zip', 'tar.gz']).optional(),
        recursive: z.boolean().optional().default(false),
        sort: z.enum([
            'name',
            'modified',
            'size'
        ]).optional(),
        order: z.enum(['asc', 'desc']).optional(),
        includeAppends: z.boolean().optional().default(false)
    }).optional()
});

/**
 * Folder contents retrieved successfully.
 *
 * When `action=export`, returns binary archive with Content-Disposition header.
 *
 */
export const zListFolderContentsResponse = zFolderListResponse;

export const zListFolderContentsViaAppendKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.object({
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional(),
        recursive: z.boolean().optional().default(false),
        sort: z.enum([
            'name',
            'modified',
            'size'
        ]).optional(),
        order: z.enum(['asc', 'desc']).optional()
    }).optional()
});

/**
 * Folder contents retrieved successfully
 */
export const zListFolderContentsViaAppendKeyResponse = zFolderListResponse;

export const zCreateFileInFolderData = z.object({
    body: zCreateFileRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * File created successfully
 */
export const zCreateFileInFolderResponse = zCreateFileResponse;

export const zDeleteFolderData = z.object({
    body: zFolderDeleteRequest.optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Folder deleted successfully
 */
export const zDeleteFolderResponse = zFolderDeleteResponse;

export const zListFolderContentsViaWriteKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.object({
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional(),
        recursive: z.boolean().optional().default(false),
        sort: z.enum([
            'name',
            'modified',
            'size'
        ]).optional(),
        order: z.enum(['asc', 'desc']).optional()
    }).optional()
});

/**
 * Folder contents retrieved successfully
 */
export const zListFolderContentsViaWriteKeyResponse = zFolderListResponse;

export const zRenameFolderData = z.object({
    body: zFolderRenameRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Folder renamed successfully
 */
export const zRenameFolderResponse = zFolderMoveResponse;

export const zCreateFolderData = z.object({
    body: zFolderCreateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Folder created successfully
 */
export const zCreateFolderResponse = zFolderCreateResponse;

export const zCopyFileToFolderData = z.object({
    body: zCopyFileToFolderRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * File copied successfully
 */
export const zCopyFileToFolderResponse = zCreateFileResponse;

export const zBulkCreateFilesData = z.object({
    body: zFolderBulkCreateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.object({
        async: z.boolean().optional().default(false)
    }).optional()
});

export const zBulkCreateFilesResponse = z.union([
    zFolderBulkCreateResponse,
    zFolderBulkCreateJobResponse
]);

export const zMoveFolderData = z.object({
    body: zFolderMoveRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Folder moved successfully
 */
export const zMoveFolderResponse = zFolderMoveResponse;

export const zGetFolderSettingsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Folder settings retrieved successfully
 */
export const zGetFolderSettingsResponse = zFolderSettingsResponse;

export const zUpdateFolderSettingsData = z.object({
    body: zFolderSettingsUpdateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Folder settings updated successfully
 */
export const zUpdateFolderSettingsResponse = zFolderSettingsResponse;

export const zGetFolderStatsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        path: z.string().optional()
    }).optional()
});

/**
 * Folder statistics retrieved successfully
 */
export const zGetFolderStatsResponse = zFolderStatsResponse;

export const zSearchInFolderData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        path: z.string().optional(),
        q: z.string().max(500).optional(),
        type: z.enum([
            'task',
            'comment',
            'response',
            'claim'
        ]).optional(),
        status: z.enum([
            'pending',
            'claimed',
            'completed',
            'failed'
        ]).optional(),
        author: z.string().optional(),
        labels: z.string().optional(),
        priority: z.string().optional(),
        since: z.string().datetime().optional(),
        timeout: z.string().optional().default('5s'),
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Search results
 */
export const zSearchInFolderResponse = zFolderSearchResponse;

export const zQueryFolderTasksData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        path: z.string().optional(),
        status: z.enum([
            'pending',
            'claimed',
            'completed',
            'cancelled'
        ]).optional(),
        author: z.string().optional(),
        priority: z.string().optional(),
        labels: z.string().optional(),
        claimedBy: z.string().optional(),
        claimable: z.boolean().optional(),
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Tasks retrieved successfully
 */
export const zQueryFolderTasksResponse = zTaskQueryResponse;

export const zSubscribeFolderEventsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        path: z.string().optional(),
        includeAppends: z.boolean().optional().default(false),
        recursive: z.boolean().optional().default(false)
    }).optional()
});

/**
 * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
 */
export const zSubscribeFolderEventsResponse = z.record(z.unknown());

export const zSubscribeFolderEventsViaAppendKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        path: z.string().optional(),
        includeAppends: z.boolean().optional().default(false),
        recursive: z.boolean().optional().default(false)
    }).optional()
});

/**
 * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
 */
export const zSubscribeFolderEventsViaAppendKeyResponse = z.record(z.unknown());

export const zSubscribeFolderEventsViaWriteKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        path: z.string().optional(),
        includeAppends: z.boolean().optional().default(false),
        recursive: z.boolean().optional().default(false)
    }).optional()
});

/**
 * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
 */
export const zSubscribeFolderEventsViaWriteKeyResponse = z.record(z.unknown());

export const zListFolderWebhooksData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Webhooks retrieved successfully
 */
export const zListFolderWebhooksResponse = zWebhookListResponse;

export const zCreateFolderWebhookData = z.object({
    body: zWebhookCreateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Webhook created successfully
 */
export const zCreateFolderWebhookResponse = zWebhookCreateResponse;

export const zDeleteFolderWebhookData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string(),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Webhook deleted successfully
 */
export const zDeleteFolderWebhookResponse = zWebhookDeleteResponse;

export const zUpdateFolderWebhookData = z.object({
    body: zWebhookUpdateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string(),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Webhook updated successfully
 */
export const zUpdateFolderWebhookResponse = zWebhookUpdateResponse;

export const zListFolderClaimsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        path: z.string()
    }),
    query: z.object({
        author: z.string().optional()
    }).optional()
});

/**
 * Claims retrieved successfully
 */
export const zListFolderClaimsResponse = zFolderClaimsResponse;

export const zListScopedKeysData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        includeRevoked: z.boolean().optional().default(false)
    }).optional()
});

/**
 * Scoped keys retrieved successfully
 */
export const zListScopedKeysResponse = zScopedKeyListResponse;

export const zCreateScopedKeyData = z.object({
    body: zScopedKeyCreateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Scoped key created successfully
 */
export const zCreateScopedKeyResponse = zScopedKeyCreateResponse;

export const zRevokeScopedKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        keyId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Scoped key revoked successfully
 */
export const zRevokeScopedKeyResponse = zKeyRevokeResponse;

export const zCheckCapabilitiesData = z.object({
    body: zCapabilitiesCheckRequest,
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Capabilities checked
 */
export const zCheckCapabilitiesResponse = zCapabilitiesCheckResponse;

export const zSignInWithGitHubData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * This endpoint redirects to OAuth provider. 200 is for OpenAPI compliance only.
 */
export const zSignInWithGitHubResponse = z.record(z.unknown());

export const zSignInWithGoogleData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * This endpoint redirects to OAuth provider. 200 is for OpenAPI compliance only.
 */
export const zSignInWithGoogleResponse = z.record(z.unknown());

export const zGetCurrentUserData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * User information retrieved
 */
export const zGetCurrentUserResponse = zMeResponse;

export const zLogoutData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Logged out successfully
 */
export const zLogoutResponse2 = zLogoutResponse;

export const zClaimWorkspaceData = z.object({
    body: z.record(z.unknown()).optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Workspace claimed successfully
 */
export const zClaimWorkspaceResponse2 = zClaimWorkspaceResponse;

export const zRenameWorkspaceViaWriteKeyData = z.object({
    body: zWorkspaceRenameRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Workspace renamed successfully
 */
export const zRenameWorkspaceViaWriteKeyResponse = zWorkspaceRenameResponse;

export const zDeleteWorkspaceData = z.object({
    body: z.never().optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/)
    }),
    query: z.never().optional()
});

/**
 * Workspace deleted successfully
 */
export const zDeleteWorkspaceResponse = zSuccessResponse;

export const zRenameWorkspaceData = z.object({
    body: zWorkspaceRenameRequest,
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/)
    }),
    query: z.never().optional()
});

/**
 * Workspace renamed successfully
 */
export const zRenameWorkspaceResponse = zWorkspaceRenameResponse;

export const zRotateAllUrlsData = z.object({
    body: z.never().optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/)
    }),
    query: z.never().optional()
});

/**
 * All URLs rotated successfully
 */
export const zRotateAllUrlsResponse = zRotateAllResponse;

export const zListApiKeysData = z.object({
    body: z.never().optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/)
    }),
    query: z.never().optional()
});

/**
 * API keys retrieved successfully
 */
export const zListApiKeysResponse = zApiKeyListResponse;

export const zCreateApiKeyData = z.object({
    body: zApiKeyCreateRequest,
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/)
    }),
    query: z.never().optional()
});

/**
 * API key created successfully
 */
export const zCreateApiKeyResponse = zApiKeyCreateResponse;

export const zRevokeApiKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        keyId: z.string()
    }),
    query: z.never().optional()
});

/**
 * API key revoked successfully
 */
export const zRevokeApiKeyResponse = zApiKeyRevokeResponse;

export const zListWebhooksData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Webhooks retrieved successfully
 */
export const zListWebhooksResponse = zWebhookListResponse;

export const zCreateWebhookData = z.object({
    body: zWebhookCreateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Webhook created successfully
 */
export const zCreateWebhookResponse = zWebhookCreateResponse;

export const zDeleteWebhookData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Webhook deleted successfully
 */
export const zDeleteWebhookResponse = zWebhookDeleteResponse;

export const zUpdateWebhookData = z.object({
    body: zWebhookUpdateRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Webhook updated successfully
 */
export const zUpdateWebhookResponse = zWebhookUpdateResponse;

export const zGetWebhookLogsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        webhookId: z.string()
    }),
    query: z.object({
        limit: z.number().int().gte(1).lte(200).optional().default(50),
        since: z.string().datetime().optional()
    }).optional()
});

/**
 * Webhook logs retrieved successfully
 */
export const zGetWebhookLogsResponse = zWebhookLogsResponse;

export const zTestWebhookData = z.object({
    body: zWebhookTestRequest.optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Test webhook delivered (or attempted)
 */
export const zTestWebhookResponse = zWebhookTestResponse;

export const zListWorkspaceWebhooksData = z.object({
    body: z.never().optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/)
    }),
    query: z.never().optional()
});

/**
 * Webhooks retrieved successfully
 */
export const zListWorkspaceWebhooksResponse = zWebhookListResponse;

export const zCreateWorkspaceWebhookData = z.object({
    body: zWebhookCreateRequest,
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/)
    }),
    query: z.never().optional()
});

/**
 * Webhook created successfully
 */
export const zCreateWorkspaceWebhookResponse = zWebhookCreateResponse;

export const zDeleteWorkspaceWebhookData = z.object({
    body: z.never().optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Webhook deleted successfully
 */
export const zDeleteWorkspaceWebhookResponse = zWebhookDeleteResponse;

export const zUpdateWorkspaceWebhookData = z.object({
    body: zWebhookUpdateRequest,
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Webhook updated successfully
 */
export const zUpdateWorkspaceWebhookResponse = zWebhookUpdateResponse;

export const zTestWorkspaceWebhookData = z.object({
    body: zWebhookTestRequest.optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Test delivery attempted
 */
export const zTestWorkspaceWebhookResponse = zWebhookTestResponse;

export const zSearchInFileViaReadKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        q: z.string().max(500).optional(),
        type: z.enum([
            'task',
            'claim',
            'response',
            'blocked',
            'answer',
            'renew',
            'cancel',
            'comment',
            'vote'
        ]).optional(),
        status: z.enum([
            'pending',
            'claimed',
            'completed',
            'cancelled'
        ]).optional(),
        author: z.string().optional(),
        labels: z.string().optional(),
        priority: z.string().optional(),
        since: z.string().datetime().optional(),
        limit: z.number().int().gte(1).lte(200).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Search results retrieved successfully
 */
export const zSearchInFileViaReadKeyResponse = zSearchResponse;

export const zSearchWorkspaceData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        q: z.string().max(500).optional(),
        type: z.enum([
            'task',
            'claim',
            'response',
            'blocked',
            'answer',
            'renew',
            'cancel',
            'comment',
            'vote'
        ]).optional(),
        folder: z.string().optional(),
        status: z.enum([
            'pending',
            'claimed',
            'completed',
            'cancelled'
        ]).optional(),
        author: z.string().optional(),
        labels: z.string().optional(),
        priority: z.string().optional(),
        since: z.string().datetime().optional(),
        limit: z.number().int().gte(1).lte(200).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Search results retrieved successfully
 */
export const zSearchWorkspaceResponse = zSearchResponse;

export const zSubscribeReadKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
 */
export const zSubscribeReadKeyResponse = z.record(z.unknown());

export const zSubscribeAppendKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
 */
export const zSubscribeAppendKeyResponse = z.record(z.unknown());

export const zSubscribeWriteKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
 */
export const zSubscribeWriteKeyResponse = z.record(z.unknown());

export const zRecordHeartbeatData = z.object({
    body: zHeartbeatRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Heartbeat recorded successfully
 */
export const zRecordHeartbeatResponse = zHeartbeatResponse;

export const zGetStatsViaWriteKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Statistics retrieved
 */
export const zGetStatsViaWriteKeyResponse = zStatsViaWriteKeyResponse;

export const zGetFileStatsViaReadKeyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * File statistics retrieved successfully
 */
export const zGetFileStatsViaReadKeyResponse = zFileStatsResponse;

export const zGetFileStatsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * File statistics retrieved successfully
 */
export const zGetFileStatsResponse = zFileStatsResponse;

export const zGetWorkspaceStatsData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Workspace statistics retrieved successfully
 */
export const zGetWorkspaceStatsResponse = zWorkspaceStatsResponse;

export const zPollJobStatusData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Job status retrieved successfully
 */
export const zPollJobStatusResponse = zJobResponse;

export const zExportWorkspaceData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        format: z.enum(['zip', 'tar.gz']).optional(),
        includeAppends: z.boolean().optional().default(false),
        includeDeleted: z.boolean().optional().default(false),
        paths: z.string().optional()
    }).optional()
});

/**
 * Binary file download
 */
export const zExportWorkspaceResponse = z.string();

export const zCreateExportJobData = z.object({
    body: z.object({
        format: z.enum(['zip', 'tar.gz']).optional(),
        includeAppends: z.boolean().optional().default(false),
        includeDeleted: z.boolean().optional().default(false),
        paths: z.array(z.string()).optional(),
        notifyEmail: z.string().email().optional()
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Export job created
 */
export const zCreateExportJobResponse = zExportJobCreateResponse;

export const zGetExportJobStatusData = z.object({
    body: z.never().optional(),
    path: z.object({
        jobId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Export job status
 */
export const zGetExportJobStatusResponse = zExportJobStatusResponse;

export const zDownloadExportJobData = z.object({
    body: z.never().optional(),
    path: z.object({
        jobId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Binary file download
 */
export const zDownloadExportJobResponse = z.string();

export const zListDeletedFilesData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * List of recoverable deleted files
 */
export const zListDeletedFilesResponse = zDeletedFilesListResponse;

export const zGetAgentLivenessData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        staleThresholdSeconds: z.number().int().gte(60).lte(3600).optional().default(300),
        folder: z.string().optional()
    }).optional()
});

/**
 * Agent liveness data retrieved successfully
 */
export const zGetAgentLivenessResponse = zAgentLivenessResponse;

export const zGetScopedAgentLivenessData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        staleThresholdSeconds: z.number().int().gte(60).lte(3600).optional().default(300)
    }).optional()
});

/**
 * Agent liveness data retrieved successfully
 */
export const zGetScopedAgentLivenessResponse = zAgentLivenessResponse;

export const zGetOrchestrationReadOnlyData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        status: z.string().regex(/^(pending|claimed|stalled|completed|cancelled)(,(pending|claimed|stalled|completed|cancelled))*$/).optional(),
        agent: z.string().optional(),
        file: z.string().optional(),
        folder: z.string().optional(),
        priority: z.string().regex(/^(low|medium|high|critical)(,(low|medium|high|critical))*$/).optional(),
        since: z.string().datetime().optional(),
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Orchestration data retrieved successfully
 */
export const zGetOrchestrationReadOnlyResponse = zOrchestrationReadOnlyResponse;

export const zGetOrchestrationAdminData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        status: z.string().regex(/^(pending|claimed|stalled|completed|cancelled)(,(pending|claimed|stalled|completed|cancelled))*$/).optional(),
        agent: z.string().optional(),
        file: z.string().optional(),
        folder: z.string().optional(),
        priority: z.string().regex(/^(low|medium|high|critical)(,(low|medium|high|critical))*$/).optional(),
        since: z.string().datetime().optional(),
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Orchestration data retrieved successfully
 */
export const zGetOrchestrationAdminResponse = zOrchestrationAdminResponse;

export const zGetWorkspaceOrchestrationData = z.object({
    body: z.never().optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/)
    }),
    query: z.object({
        status: z.string().regex(/^(pending|claimed|stalled|completed|cancelled)(,(pending|claimed|stalled|completed|cancelled))*$/).optional(),
        agent: z.string().optional(),
        file: z.string().optional(),
        folder: z.string().optional(),
        priority: z.string().regex(/^(low|medium|high|critical)(,(low|medium|high|critical))*$/).optional(),
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Orchestration data retrieved successfully
 */
export const zGetWorkspaceOrchestrationResponse = zOrchestrationReadOnlyResponse;

export const zRenewClaimWorkspaceData = z.object({
    body: zRenewClaimRequest.optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        claimId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Claim renewed successfully
 */
export const zRenewClaimWorkspaceResponse = zClaimMutationResponse;

export const zCompleteClaimWorkspaceData = z.object({
    body: zCompleteClaimRequest.optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        claimId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Task completed successfully
 */
export const zCompleteClaimWorkspaceResponse = zClaimMutationResponse;

export const zCancelClaimWorkspaceData = z.object({
    body: zCancelClaimRequest.optional(),
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        claimId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Claim cancelled successfully
 */
export const zCancelClaimWorkspaceResponse = zClaimMutationResponse;

export const zBlockClaimWorkspaceData = z.object({
    body: zBlockClaimRequest,
    path: z.object({
        workspaceId: z.string().regex(/^ws_[A-Za-z0-9]{12,}$/),
        claimId: z.string()
    }),
    query: z.never().optional()
});

/**
 * Claim marked as blocked
 */
export const zBlockClaimWorkspaceResponse = zClaimMutationResponse;

export const zApiDeleteFileByPathData = z.object({
    body: z.never().optional(),
    path: z.object({
        path: z.string()
    }),
    query: z.object({
        permanent: z.boolean().optional().default(false)
    }).optional()
});

/**
 * File deleted successfully
 */
export const zApiDeleteFileByPathResponse = zFileDeleteResponse;

export const zApiReadFileByPathData = z.object({
    body: z.never().optional(),
    path: z.object({
        path: z.string()
    }),
    query: z.object({
        format: z.enum([
            'raw',
            'parsed',
            'structure'
        ]).optional()
    }).optional()
});

/**
 * File content retrieved successfully
 */
export const zApiReadFileByPathResponse = zFileReadResponse;

export const zApiCreateFileByPathData = z.object({
    body: z.object({
        content: z.string(),
        initialAppends: z.array(zAppendRequest).optional()
    }),
    path: z.object({
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * File created successfully
 */
export const zApiCreateFileByPathResponse = zFileCreateResponse;

export const zApiUpdateFileByPathData = z.object({
    body: zFileUpdateRequest,
    path: z.object({
        path: z.string()
    }),
    query: z.never().optional(),
    headers: z.object({
        'If-Match': z.string().optional()
    }).optional()
});

/**
 * File updated successfully
 */
export const zApiUpdateFileByPathResponse = zFileUpdateResponse;

export const zApiAppendToFileByPathData = z.object({
    body: zAppendRequest,
    path: z.object({
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Append created successfully
 */
export const zApiAppendToFileByPathResponse = zAppendResponse;

export const zApiListRootFolderData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.object({
        recursive: z.boolean().optional().default(false),
        depth: z.number().int().gte(1).lte(5).optional().default(1),
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Folder contents retrieved successfully
 */
export const zApiListRootFolderResponse = zFolderListResponse;

export const zApiCreateRootFolderData = z.object({
    body: z.object({
        name: z.string().max(255)
    }),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Folder created successfully
 */
export const zApiCreateRootFolderResponse = zFolderCreateResponse;

export const zApiDeleteFolderByPathData = z.object({
    body: z.object({
        cascade: z.boolean().optional(),
        confirmPath: z.string().optional()
    }).optional(),
    path: z.object({
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Folder deleted successfully
 */
export const zApiDeleteFolderByPathResponse = zFolderDeleteResponse;

export const zApiListFolderByPathData = z.object({
    body: z.never().optional(),
    path: z.object({
        path: z.string()
    }),
    query: z.object({
        recursive: z.boolean().optional().default(false),
        depth: z.number().int().gte(1).lte(5).optional().default(1),
        limit: z.number().int().gte(1).lte(1000).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Folder contents retrieved successfully
 */
export const zApiListFolderByPathResponse = zFolderListResponse;

export const zApiCreateFolderByPathData = z.object({
    body: z.object({
        name: z.string().max(255)
    }),
    path: z.object({
        path: z.string()
    }),
    query: z.never().optional()
});

/**
 * Folder created successfully
 */
export const zApiCreateFolderByPathResponse = zFolderCreateResponse;

export const zHealthCheckData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Service is healthy
 */
export const zHealthCheckResponse = zHealthCheckSimpleResponse;

export const zGetOpenApiSpecData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * OpenAPI 3.1 specification document
 */
export const zGetOpenApiSpecResponse = z.record(z.unknown());

export const zGetApiDocsData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * HTML page with interactive API documentation
 */
export const zGetApiDocsResponse = z.string();

export const zGetChangelogData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * API changelog
 */
export const zGetChangelogResponse = zChangelogResponse;

export const zGetServiceStatusData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * Service status
 */
export const zGetServiceStatusResponse = zStatusResponse;

export const zCheckCapabilitiesInWorkspaceData = z.object({
    body: zCapabilitiesCheckRequest,
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.never().optional()
});

/**
 * Capability check results with extended information
 */
export const zCheckCapabilitiesInWorkspaceResponse = zCapabilitiesCheckInWorkspaceResponse;

export const zGetAuditLogsData = z.object({
    body: z.never().optional(),
    path: z.object({
        key: z.string().min(20).regex(/^[A-Za-z0-9_]{20,}$/)
    }),
    query: z.object({
        action: z.enum([
            'file.create',
            'file.update',
            'file.delete',
            'append',
            'claim',
            'key.create',
            'key.revoke',
            'webhook.create',
            'webhook.update',
            'webhook.delete',
            'workspace.claim'
        ]).optional(),
        resourceType: z.enum([
            'file',
            'folder',
            'key',
            'webhook',
            'workspace'
        ]).optional(),
        actor: z.string().optional(),
        since: z.string().datetime().optional(),
        until: z.string().datetime().optional(),
        limit: z.number().int().gte(1).lte(100).optional().default(50),
        cursor: z.string().optional()
    }).optional()
});

/**
 * Audit logs retrieved successfully
 */
export const zGetAuditLogsResponse = zAuditLogsResponse;

export const zGetAdminMetricsData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * System metrics retrieved successfully
 */
export const zGetAdminMetricsResponse = zAdminMetricsResponse;
