// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.mdplane.dev' | 'http://localhost:3000' | (string & {});
};

/**
 * Required configuration for workspace bootstrap
 */
export type BootstrapRequest = {
    /**
     * Human-friendly workspace name
     */
    workspaceName: string;
};

/**
 * Capability keys for the workspace (use these with API or web URLs)
 */
export type BootstrapKeys = {
    /**
     * Read capability key - grants read-only access
     */
    read: string;
    /**
     * Append capability key - grants read + append access
     */
    append: string;
    /**
     * Write capability key - grants full access (read + append + write)
     */
    write: string;
};

/**
 * API endpoint URLs (for curl/CLI usage)
 */
export type BootstrapApiUrls = {
    /**
     * Read API base URL
     */
    read: string;
    /**
     * Append API base URL
     */
    append: string;
    /**
     * Write API base URL
     */
    write: string;
};

/**
 * Web UI URLs (for browser access)
 */
export type BootstrapWebUrls = {
    /**
     * Read-only file browser
     */
    read: string;
    /**
     * Claim workspace page (requires login to complete)
     */
    claim: string;
};

/**
 * Pre-built URLs for API and web access
 */
export type BootstrapUrls = {
    api: BootstrapApiUrls;
    web: BootstrapWebUrls;
};

/**
 * Response from bootstrap endpoint with workspace details
 */
export type BootstrapResponse = {
    ok: true;
    data: {
        /**
         * Unique workspace identifier
         */
        workspaceId: string;
        keys: BootstrapKeys;
        urls: BootstrapUrls;
        /**
         * Workspace creation timestamp
         */
        createdAt: string;
    };
};

export type Error = {
    ok: false;
    error: {
        /**
         * Machine-readable error code
         */
        code: 'FILE_NOT_FOUND' | 'FOLDER_NOT_FOUND' | 'FOLDER_ALREADY_EXISTS' | 'FOLDER_EXISTS' | 'SOURCE_NOT_FOUND' | 'APPEND_NOT_FOUND' | 'WEBHOOK_NOT_FOUND' | 'WORKSPACE_NOT_FOUND' | 'FILE_DELETED' | 'FILE_ALREADY_EXISTS' | 'FOLDER_NOT_EMPTY' | 'INVALID_REQUEST' | 'SERVER_ERROR' | 'INVALID_APPEND_TYPE' | 'INVALID_REF' | 'INVALID_VOTE_VALUE' | 'INVALID_AUTHOR' | 'INVALID_TOKEN' | 'INVALID_WEBHOOK_URL' | 'INVALID_PATH' | 'INVALID_CONTENT' | 'INVALID_TARGET' | 'INVALID_KEY' | 'INVALID_FILENAME' | 'INVALID_APPEND_ID' | 'SECTION_NOT_FOUND' | 'UNSUPPORTED_MEDIA_TYPE' | 'TASK_ALREADY_COMPLETE' | 'TASK_CANCELLED' | 'CLAIM_EXPIRED' | 'ALREADY_CLAIMED' | 'AUTHOR_MISMATCH' | 'CANNOT_RENEW_OTHERS_CLAIM' | 'CANNOT_CANCEL_OTHERS_CLAIM' | 'TYPE_NOT_ALLOWED' | 'KEY_EXPIRED' | 'KEY_REVOKED' | 'KEY_NOT_FOUND' | 'NOT_FOUND' | 'PERMISSION_DENIED' | 'FORBIDDEN' | 'NOT_ASSIGNED' | 'CONFLICT' | 'PAYLOAD_TOO_LARGE' | 'WORKSPACE_TOO_LARGE' | 'QUOTA_EXCEEDED' | 'RATE_LIMITED' | 'WIP_LIMIT_EXCEEDED' | 'AUTHOR_RATE_LIMITED' | 'BULK_LIMIT_EXCEEDED' | 'WEBHOOK_LIMIT_EXCEEDED' | 'WEBHOOK_SUSPENDED' | 'UNAUTHORIZED' | 'CONFIRM_PATH_MISMATCH' | 'JOB_NOT_FOUND' | 'JOB_NOT_READY' | 'INVALID_PATTERN' | 'QUERY_TOO_LONG' | 'QUERY_TOO_BROAD' | 'INVALID_TIMEOUT' | 'SCOPE_DENIED';
        /**
         * Human-readable error message
         */
        message: string;
        /**
         * Additional error context
         */
        details?: {
            [key: string]: unknown;
        };
    };
};

/**
 * User-facing append types that can be created via API or CLI
 */
export type UserAppendType = 'task' | 'claim' | 'response' | 'comment' | 'blocked' | 'answer' | 'renew' | 'cancel' | 'vote';

/**
 * System-only append types (heartbeat, etc.) - not user-creatable
 */
export type SystemAppendType = 'heartbeat';

/**
 * All possible append types (user + system)
 */
export type AppendType = UserAppendType | SystemAppendType;

/**
 * Computed status of a task or claim
 */
export type AppendStatus = 'pending' | 'open' | 'claimed' | 'completed' | 'done' | 'expired' | 'cancelled' | 'active';

/**
 * Task priority level
 */
export type Priority = 'low' | 'medium' | 'high' | 'critical';

/**
 * Full append object returned in parsed file responses
 */
export type Append = {
    /**
     * Append ID (sequential per-file)
     */
    id: string;
    /**
     * Author identifier
     */
    author: string;
    /**
     * ISO 8601 timestamp when append was created
     */
    ts: string;
    type: AppendType;
    status?: AppendStatus;
    /**
     * Append content (markdown)
     */
    content?: string;
    priority?: Priority;
    /**
     * Labels array (tasks only)
     */
    labels?: Array<string>;
    /**
     * Referenced append ID
     */
    ref?: string;
    /**
     * Claim expiry timestamp (claims only)
     */
    expiresAt?: string;
    /**
     * Due date for tasks
     */
    dueAt?: string;
    /**
     * Current claim holder (tasks only, if claimed)
     */
    claimedBy?: string;
    /**
     * Completion timestamp (tasks only, if completed)
     */
    completedAt?: string;
    /**
     * Vote value (votes only)
     */
    value?: '+1' | '-1';
    /**
     * Informational linkage to other append IDs
     */
    relatedTo?: Array<string>;
    /**
     * True if content hash changed since append was created
     */
    stale?: boolean;
};

export type TaskStats = {
    /**
     * Number of pending tasks
     */
    pending?: number;
    /**
     * Number of claimed tasks
     */
    claimed?: number;
    /**
     * Number of completed tasks
     */
    completed?: number;
    /**
     * Number of currently active claims
     */
    activeClaims?: number;
};

export type FileStats = {
    /**
     * Total number of appends
     */
    appendCount?: number;
    taskStats?: TaskStats;
};

/**
 * Workspace metadata included in capability URL responses
 */
export type WorkspaceContext = {
    /**
     * Workspace ID
     */
    id: string;
    /**
     * Workspace name (if set)
     */
    name?: string;
    /**
     * Whether workspace has been claimed by a user
     */
    claimed: boolean;
};

export type FileReadResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        /**
         * File name
         */
        filename: string;
        /**
         * File content (markdown)
         */
        content: string;
        /**
         * Content version hash for optimistic concurrency
         */
        etag: string;
        /**
         * File creation timestamp
         */
        createdAt: string;
        /**
         * Last modification timestamp
         */
        updatedAt: string;
        /**
         * Total number of appends
         */
        appendCount: number;
        /**
         * File size in bytes
         */
        size: number;
        /**
         * Parsed YAML frontmatter (when format=parsed)
         */
        frontmatter?: {
            [key: string]: unknown;
        };
        /**
         * Parsed appends (when format=parsed or appends param specified)
         */
        appends?: Array<Append>;
        stats?: FileStats;
        /**
         * URL to view this file in the web app
         */
        webUrl?: string;
        /**
         * Workspace context for capability URL UI
         */
        workspace?: WorkspaceContext;
    };
};

export type FileUpdateRequest = {
    /**
     * New file content (replaces everything)
     */
    content: string;
};

export type FileUpdateResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        /**
         * New content version hash
         */
        etag: string;
        /**
         * New modification timestamp
         */
        updatedAt: string;
        /**
         * New file size in bytes
         */
        size: number;
        /**
         * Number of appends marked stale after content replacement
         */
        appendsStale?: number;
        /**
         * URL to view this file in the web app
         */
        webUrl?: string;
    };
};

export type FileDeleteResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        deleted: true;
        /**
         * Whether file can be recovered (soft delete)
         */
        recoverable?: boolean;
        /**
         * When soft-deleted file will be permanently deleted
         */
        expiresAt?: string;
    };
};

export type FileRenameRequest = {
    /**
     * New filename
     */
    filename: string;
};

export type FileRenameResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        /**
         * New filename after rename
         */
        filename: string;
    };
};

export type FileMetaResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        /**
         * File name
         */
        filename: string;
        /**
         * Parent folder path
         */
        folder: string;
        /**
         * File size in bytes
         */
        size: number;
        /**
         * File creation timestamp
         */
        createdAt: string;
        /**
         * Last modification timestamp
         */
        updatedAt: string;
        /**
         * Total number of appends
         */
        appendCount: number;
        taskStats: TaskStats;
        /**
         * Whether file has active webhooks
         */
        hasWebhook: boolean;
        /**
         * URL to view this file in the web app
         */
        webUrl?: string;
    };
};

export type FileTailResponse = {
    ok: true;
    data: {
        /**
         * Tail content (last N bytes/lines)
         */
        content: string;
        /**
         * Number of bytes returned
         */
        bytesReturned: number;
        /**
         * Whether content was truncated (file larger than requested)
         */
        truncated: boolean;
    };
};

export type FileStructureResponse = {
    ok: true;
    data: {
        headings: Array<{
            /**
             * Heading level (1-6)
             */
            level: number;
            /**
             * Heading text content
             */
            text: string;
            /**
             * Line number in file
             */
            line: number;
        }>;
        /**
         * Total number of appends in the file
         */
        appendCount: number;
        /**
         * Whether file has any task appends
         */
        hasTaskAppends: boolean;
    };
};

export type FileSectionResponse = {
    ok: true;
    data: {
        /**
         * Heading text that was matched
         */
        heading: string;
        /**
         * Heading level (1-6)
         */
        level: number;
        /**
         * Section content
         */
        content: string;
        /**
         * Starting line number
         */
        startLine: number;
        /**
         * Ending line number
         */
        endLine: number;
    };
};

export type AppendGetResponse = {
    ok: true;
    data: Append;
};

/**
 * Capability URLs for different permission levels.
 * URL fields are nullable - null indicates the current key lacks permission for that tier.
 *
 */
export type CapabilityUrls = {
    /**
     * Read-only capability URL (null if key lacks read permission)
     */
    read: string | null;
    /**
     * Append capability URL (null if key lacks append permission)
     */
    append: string | null;
    /**
     * Admin/write capability URL (null if key lacks write permission)
     */
    write: string | null;
};

export type FileRecoverResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        recovered: true;
        /**
         * File path after recovery
         */
        path: string;
        urls: CapabilityUrls;
        /**
         * URL to view this file in the web app
         */
        webUrl?: string;
    };
};

export type FileMoveRequest = {
    /**
     * Source file path (absolute from workspace root)
     */
    source: string;
    /**
     * Destination folder path (absolute from workspace root)
     */
    destination: string;
};

export type FileMoveResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        /**
         * Original file path
         */
        previousPath: string;
        /**
         * New file path after move
         */
        newPath: string;
        /**
         * URL to view this file in the web app at the new path
         */
        webUrl?: string;
    };
};

export type FileRotateUrlsResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        urls: CapabilityUrls;
        previousUrlsInvalidated: true;
        /**
         * URL to view this file in the web app
         */
        webUrl?: string;
    };
};

export type FileSettings = {
    /**
     * Default claim duration in seconds
     */
    claimDurationSeconds?: number;
    /**
     * Maximum append size in bytes
     */
    maxAppendSize?: number;
    /**
     * Allowed append types for this file
     */
    allowedAppendTypes?: Array<UserAppendType>;
    /**
     * Work-in-progress limit for claims
     */
    wipLimit?: number;
    /**
     * Allowed labels for this file
     */
    labels?: Array<string>;
};

export type FileSettingsResponse = {
    ok: true;
    data: FileSettings;
};

/**
 * Partial update for file settings
 */
export type FileSettingsUpdateRequest = {
    /**
     * Default claim duration in seconds
     */
    claimDurationSeconds?: number;
    /**
     * Maximum append size in bytes
     */
    maxAppendSize?: number;
    /**
     * Allowed append types for this file
     */
    allowedAppendTypes?: Array<UserAppendType>;
    /**
     * Work-in-progress limit for claims
     */
    wipLimit?: number;
    /**
     * Allowed labels for this file
     */
    labels?: Array<string>;
};

/**
 * Request body for creating a single append
 */
export type AppendRequest = {
    /**
     * Target file path for append operations that do not derive file scope from the key.
     * Required for workspace-scoped and folder-scoped keys when using `/a/{key}/append`.
     *
     */
    path?: string;
    /**
     * Author identifier (required for root keys)
     */
    author?: string;
    type: UserAppendType;
    /**
     * Append content
     */
    content?: string;
    /**
     * Referenced append ID (required for claim, response, blocked, answer, renew, cancel, vote)
     */
    ref?: string;
    priority?: Priority;
    /**
     * Labels (tasks only)
     */
    labels?: Array<string>;
    /**
     * Due date (tasks only)
     */
    dueAt?: string;
    /**
     * Assigned author (tasks only)
     */
    assigned?: string;
    /**
     * Vote value (votes only)
     */
    value?: '+1' | '-1';
    /**
     * Informational linkage to other append IDs
     */
    relatedTo?: Array<string>;
    /**
     * Custom claim expiry in seconds (claims only, default 1800)
     */
    expiresInSeconds?: number;
};

/**
 * Single append item for atomic multi-append (author inherited from parent)
 */
export type AppendItem = {
    type: UserAppendType;
    /**
     * Append content
     */
    content?: string;
    /**
     * Referenced append ID
     */
    ref?: string;
    priority?: Priority;
    labels?: Array<string>;
    dueAt?: string;
    assigned?: string;
    value?: '+1' | '-1';
    relatedTo?: Array<string>;
    /**
     * Custom claim expiry in seconds (claims only, default 1800)
     */
    expiresInSeconds?: number;
};

/**
 * Request body for atomic multi-append operation
 */
export type MultiAppendRequest = {
    /**
     * Target file path for append operations that do not derive file scope from the key.
     * Required for workspace-scoped and folder-scoped keys when using `/a/{key}/append`.
     *
     */
    path?: string;
    /**
     * Author for all appends in this request
     */
    author: string;
    /**
     * Array of append items (max 100)
     */
    appends: Array<AppendItem>;
};

/**
 * Result of a single append operation
 */
export type SingleAppendResult = {
    id: string;
    author: string;
    ts: string;
    type: AppendType;
    ref?: string;
    /**
     * Claim expiry timestamp (for claim type)
     */
    expiresAt?: string;
    /**
     * Seconds until claim expires
     */
    expiresInSeconds?: number;
    /**
     * Initial status (e.g., 'open' for tasks)
     */
    status?: AppendStatus;
    /**
     * Task priority level (tasks only)
     */
    priority?: Priority;
    /**
     * Labels array (tasks only)
     */
    labels?: Array<string>;
    /**
     * Due date (tasks only)
     */
    dueAt?: string;
    /**
     * Updated task status after operation (for response/cancel)
     */
    taskStatus?: 'open' | 'done';
    /**
     * Vote value (votes only)
     */
    value?: '+1' | '-1';
};

/**
 * Result of atomic multi-append operation
 */
export type MultiAppendResult = {
    appends: Array<{
        id: string;
        type: AppendType;
        ref?: string;
        /**
         * Claim expiry timestamp (for claim type)
         */
        expiresAt?: string;
        /**
         * Seconds until claim expires
         */
        expiresInSeconds?: number;
    }>;
};

/**
 * Response for append operations
 */
export type AppendResponse = {
    ok: true;
    /**
     * Server timestamp for synchronization
     */
    serverTime: string;
    data: SingleAppendResult | MultiAppendResult;
    /**
     * URL to view this file in the web app
     */
    webUrl?: string;
};

/**
 * Request body for scoped path-based append
 */
export type ScopedAppendRequest = {
    /**
     * Author identifier (may be enforced by boundAuthor on key)
     */
    author?: string;
    /**
     * Append type (may be restricted by allowedTypes on key)
     */
    type?: string;
    /**
     * Append content
     */
    content?: string;
};

/**
 * Result of a scoped append operation
 */
export type ScopedAppendResult = {
    /**
     * Append ID
     */
    appendId: string;
    /**
     * Append type (if provided)
     */
    type?: string;
    /**
     * Author identifier
     */
    author?: string;
    /**
     * ISO 8601 timestamp when append was created
     */
    createdAt: string;
};

/**
 * Response for scoped path-based append operations
 */
export type ScopedAppendResponse = {
    ok: true;
    data: ScopedAppendResult;
};

/**
 * Type of item in folder listing
 */
export type FolderItemType = 'file' | 'folder';

/**
 * An item in a folder listing (file or subfolder)
 */
export type FolderItem = {
    /**
     * Item name (filename or folder name)
     */
    name: string;
    type: FolderItemType;
    /**
     * File size in bytes (files only)
     */
    size?: number;
    /**
     * Last modification timestamp
     */
    updatedAt?: string;
    /**
     * Number of appends (files only)
     */
    appendCount?: number;
    /**
     * Number of child items (folders only)
     */
    childCount?: number;
    urls?: CapabilityUrls;
    /**
     * Nested items when depth > 1 (folders only)
     */
    items?: Array<FolderItem>;
};

export type PaginatedResponse = {
    /**
     * Opaque cursor for next page
     */
    cursor?: string;
    /**
     * Whether more results are available
     */
    hasMore?: boolean;
    /**
     * Total count of items (when available)
     */
    total?: number;
};

export type FolderListResponse = {
    ok: true;
    data: {
        /**
         * Folder path
         */
        path: string;
        items: Array<FolderItem>;
        /**
         * URL to view this folder in the web interface
         */
        webUrl?: string;
        /**
         * Workspace context for capability URL UI
         */
        workspace?: WorkspaceContext;
    };
    pagination?: PaginatedResponse;
};

export type CreateFileRequest = {
    /**
     * File name
     */
    filename: string;
    /**
     * Initial file content
     */
    content?: string;
};

export type CreateFileResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        /**
         * File name
         */
        filename: string;
        /**
         * Full file path
         */
        path: string;
        urls: CapabilityUrls;
        /**
         * Creation timestamp
         */
        createdAt: string;
        /**
         * URL to view this file in the web interface
         */
        webUrl?: string;
    };
};

/**
 * Request body for cascade delete of non-empty folders
 */
export type FolderDeleteRequest = {
    /**
     * Delete folder and all contents
     */
    cascade?: boolean;
    /**
     * Must match folder path exactly (without leading slash)
     */
    confirmPath?: string;
};

export type FolderDeleteResponse = {
    ok: true;
    data: {
        deleted: true;
        /**
         * Deleted folder path
         */
        path: string;
        /**
         * Number of files deleted (cascade only)
         */
        filesDeleted?: number;
        /**
         * Number of subfolders deleted (cascade only)
         */
        foldersDeleted?: number;
        /**
         * Whether deleted content can be recovered
         */
        recoverable?: boolean;
        /**
         * When soft-deleted content will be permanently deleted
         */
        expiresAt?: string;
    };
};

export type FolderRenameRequest = {
    /**
     * New folder name
     */
    name: string;
};

export type FolderMoveResponse = {
    ok: true;
    data: {
        /**
         * Original folder path
         */
        previousPath: string;
        /**
         * New folder path after move
         */
        newPath: string;
        /**
         * Number of files affected by the move
         */
        filesUpdated?: number;
        /**
         * URL to view this folder in the web interface at the new path
         */
        webUrl?: string;
    };
};

export type FolderCreateRequest = {
    /**
     * New folder name
     */
    name: string;
    /**
     * Parent folder path (defaults to root)
     */
    path?: string;
};

export type FolderCreateResponse = {
    ok: true;
    data: {
        /**
         * Full path of created folder
         */
        path: string;
        urls: CapabilityUrls;
        /**
         * Creation timestamp
         */
        createdAt: string;
        /**
         * URL to view this folder in the web interface
         */
        webUrl?: string;
    };
};

/**
 * Request body for copying a file into a folder
 */
export type CopyFileToFolderRequest = {
    /**
     * Read key of the source file to copy
     */
    sourceKey: string;
    /**
     * Optional new filename (defaults to source filename)
     */
    filename?: string;
};

/**
 * Single file to create in bulk operation
 */
export type FolderBulkCreateItem = {
    /**
     * File name
     */
    filename: string;
    /**
     * Initial file content
     */
    content?: string;
};

/**
 * Request body for bulk file creation
 */
export type FolderBulkCreateRequest = {
    /**
     * Array of files to create (max 100)
     */
    files: Array<FolderBulkCreateItem>;
};

/**
 * Result for a single file in bulk create
 */
export type FolderBulkCreateResultItem = {
    filename: string;
    id: string;
    urls: CapabilityUrls;
    /**
     * URL to view this file in the web interface
     */
    webUrl?: string;
};

export type FolderBulkCreateResponse = {
    ok: true;
    data: {
        created: Array<FolderBulkCreateResultItem>;
        /**
         * URL to view the parent folder in the web interface
         */
        webUrl?: string;
    };
};

/**
 * Response for async bulk file creation (202 Accepted)
 */
export type FolderBulkCreateJobResponse = {
    ok: true;
    data: {
        /**
         * Job ID for polling status
         */
        jobId: string;
    };
};

export type FolderMoveRequest = {
    /**
     * Destination folder path
     */
    destination: string;
};

/**
 * Folder-level settings
 */
export type FolderSettings = {
    /**
     * Whether to inherit settings from parent folder
     */
    inheritSettings?: boolean;
    /**
     * Default labels for files created in this folder
     */
    defaultLabels?: Array<string>;
    /**
     * Allowed append types for files in this folder
     */
    allowedTypes?: Array<'task' | 'claim' | 'response' | 'comment' | 'blocked' | 'answer' | 'renew' | 'cancel' | 'vote'>;
};

export type FolderSettingsResponse = {
    ok: true;
    data: FolderSettings;
};

/**
 * Partial update for folder settings
 */
export type FolderSettingsUpdateRequest = {
    /**
     * Whether to inherit settings from parent folder
     */
    inheritSettings?: boolean;
    /**
     * Default labels for files created in this folder
     */
    defaultLabels?: Array<string>;
    /**
     * Allowed append types for files in this folder
     */
    allowedTypes?: Array<'task' | 'claim' | 'response' | 'comment' | 'blocked' | 'answer' | 'renew' | 'cancel' | 'vote'>;
};

export type FolderStatsResponse = {
    ok: true;
    data: {
        /**
         * Folder path
         */
        path: string;
        /**
         * Total number of files
         */
        fileCount: number;
        /**
         * Total number of subfolders
         */
        folderCount: number;
        /**
         * Total size in bytes
         */
        totalSize: number;
        /**
         * Most recent modification timestamp
         */
        updatedAt?: string;
        taskStats?: TaskStats;
    };
};

/**
 * Reference to a file with ID and path
 */
export type FileReference = {
    /**
     * Unique file identifier
     */
    id: string;
    /**
     * File path relative to workspace root
     */
    path: string;
};

/**
 * Capability URLs for file access (only includes URLs the key has access to)
 */
export type FileUrls = {
    /**
     * Read-only capability URL
     */
    read?: string;
    /**
     * Append capability URL
     */
    append?: string;
    /**
     * Admin/write capability URL
     */
    write?: string;
};

/**
 * Single match within a file for folder search
 */
export type FolderSearchMatch = {
    /**
     * Unique append identifier
     */
    appendId: string;
    /**
     * Type of append (task, comment, etc.)
     */
    type: string;
    /**
     * Content snippet matching the search query
     */
    content: string;
    /**
     * Priority level (if applicable)
     */
    priority?: string;
    /**
     * Status (if applicable)
     */
    status?: string;
    /**
     * Labels attached to this append
     */
    labels?: Array<string>;
    /**
     * Author of the append
     */
    author?: string;
    /**
     * Creation timestamp
     */
    createdAt?: string;
};

/**
 * Search results grouped by file
 */
export type FolderSearchResult = {
    file: FileReference;
    fileUrls?: FileUrls;
    matches?: Array<FolderSearchMatch>;
};

/**
 * Response from folder search endpoint
 */
export type FolderSearchResponse = {
    ok: true;
    data: {
        results: Array<FolderSearchResult>;
        /**
         * Whether search was truncated due to timeout
         */
        truncated?: boolean;
    };
    pagination?: PaginatedResponse;
};

/**
 * Task result from task query endpoint
 */
export type TaskQueryResult = {
    /**
     * Append ID of the task
     */
    id: string;
    file: FileReference;
    fileUrls?: FileUrls;
    /**
     * Task content
     */
    content: string;
    /**
     * Task author
     */
    author?: string;
    /**
     * Task status
     */
    status: 'pending' | 'claimed' | 'completed' | 'cancelled';
    /**
     * Task priority
     */
    priority?: 'low' | 'medium' | 'high' | 'critical';
    /**
     * Labels attached to this task
     */
    labels?: Array<string>;
    /**
     * User who claimed the task (if claimed)
     */
    claimedBy?: string;
    /**
     * Claim expiration time (if claimed)
     */
    expiresAt?: string;
    /**
     * Task creation timestamp
     */
    createdAt: string;
};

/**
 * Summary counts of tasks by status
 */
export type TaskSummary = {
    /**
     * Count of pending tasks
     */
    pending: number;
    /**
     * Count of claimed tasks
     */
    claimed: number;
    /**
     * Count of completed tasks
     */
    completed: number;
};

/**
 * Response from task query endpoint
 */
export type TaskQueryResponse = {
    ok: true;
    data: {
        tasks: Array<TaskQueryResult>;
        summary: TaskSummary;
        /**
         * URL to view tasks in the web interface
         */
        webUrl: string;
    };
    pagination?: PaginatedResponse;
};

/**
 * Event types that can trigger webhooks
 */
export type WebhookEvent = 'append' | 'append.created' | 'task.created' | 'task.claimed' | 'task.completed' | 'task.cancelled' | 'task.blocked' | 'task.unblocked' | 'task.overdue' | 'task.escalated' | 'task.recurred' | 'task.expired' | 'claim.created' | 'claim.expired' | 'claim.renewed' | 'claim.released' | 'file.created' | 'file.updated' | 'file.deleted' | 'heartbeat' | 'webhook.failed' | 'settings.changed';

/**
 * Webhook status
 */
export type WebhookStatus = 'active' | 'paused' | 'suspended' | 'disabled';

/**
 * Webhook configuration
 */
export type Webhook = {
    /**
     * Webhook ID
     */
    id: string;
    /**
     * Webhook URL
     */
    url: string;
    events: Array<WebhookEvent>;
    status: WebhookStatus;
    /**
     * Whether capability URLs are included in payloads
     */
    includeUrls?: boolean;
    /**
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Last successful delivery timestamp
     */
    lastTriggeredAt?: string;
    /**
     * Consecutive failure count
     */
    failureCount?: number;
    /**
     * Success rate (0.0 to 1.0)
     */
    successRate?: number;
};

export type WebhookListResponse = {
    ok: true;
    data: Array<Webhook>;
    /**
     * URL to manage webhooks in the web interface
     */
    webUrl?: string;
};

/**
 * Request to register a new webhook
 */
export type WebhookCreateRequest = {
    /**
     * HTTPS URL to receive webhook payloads
     */
    url: string;
    /**
     * Events to subscribe to
     */
    events: Array<WebhookEvent>;
    /**
     * HMAC-SHA256 signing secret (min 32 chars). If omitted, server generates one.
     */
    secret?: string;
    /**
     * Custom headers to include in webhook requests
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * Whether to include capability URLs in payloads
     */
    includeUrls?: boolean;
    /**
     * Optional filters to narrow which events trigger the webhook
     */
    filters?: {
        /**
         * Filter by append types
         */
        types?: Array<string>;
        /**
         * Filter by labels
         */
        labels?: Array<string>;
        /**
         * Filter by priority levels
         */
        priority?: Array<string>;
    };
    /**
     * Whether the webhook should trigger for changes in subfolders (folder webhooks only)
     */
    recursive?: boolean;
};

export type WebhookCreateResponse = {
    ok: true;
    data: {
        /**
         * Webhook ID
         */
        id: string;
        /**
         * Webhook URL
         */
        url: string;
        events: Array<WebhookEvent>;
        status: WebhookStatus;
        /**
         * Generated secret (only returned once at creation if not provided)
         */
        secret?: string;
        includeUrls?: boolean;
        /**
         * Creation timestamp
         */
        createdAt: string;
        /**
         * URL to manage webhooks in the web interface
         */
        webUrl?: string;
    };
};

export type WebhookDeleteResponse = {
    ok: true;
    data: {
        /**
         * Deleted webhook ID
         */
        id: string;
        deleted: true;
    };
};

/**
 * Partial update for webhook configuration
 */
export type WebhookUpdateRequest = {
    /**
     * New webhook URL
     */
    url?: string;
    /**
     * Updated event subscriptions
     */
    events?: Array<WebhookEvent>;
    /**
     * Enable/disable webhook
     */
    active?: boolean;
    /**
     * New signing secret
     */
    secret?: string;
    /**
     * Updated custom headers
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * Whether to include capability URLs in payloads
     */
    includeUrls?: boolean;
    /**
     * Updated filters
     */
    filters?: {
        types?: Array<string>;
        labels?: Array<string>;
        priority?: Array<string>;
    };
    /**
     * Whether the webhook should trigger for changes in subfolders (folder webhooks only)
     */
    recursive?: boolean;
};

export type WebhookUpdateResponse = {
    ok: true;
    data: Webhook;
};

/**
 * File information for a claim
 */
export type FolderClaimFileInfo = {
    /**
     * File ID
     */
    id: string;
    /**
     * File path within folder
     */
    path: string;
};

/**
 * A single claim in a folder
 */
export type FolderClaimItem = {
    /**
     * ID of the claimed task
     */
    taskId: string;
    /**
     * ID of the claim append
     */
    claimId: string;
    file: FolderClaimFileInfo;
    /**
     * Content of the claimed task
     */
    taskContent: string;
    /**
     * Claim status
     */
    status: 'active' | 'expired';
    /**
     * Claim expiry timestamp
     */
    expiresAt: string;
    /**
     * Seconds until claim expires
     */
    expiresInSeconds: number;
};

export type FolderClaimsResponse = {
    ok: true;
    data: {
        claims: Array<FolderClaimItem>;
        /**
         * Total number of claims
         */
        count: number;
        /**
         * URL to view claims in the web interface
         */
        webUrl: string;
    };
};

/**
 * Permission level for scoped keys
 */
export type KeyPermission = 'read' | 'append' | 'write';

/**
 * Scoped key metadata (key itself is partially redacted)
 */
export type ScopedKey = {
    /**
     * Key ID for management operations
     */
    id: string;
    /**
     * Partially visible key (e.g., "a_x8k2...nR")
     */
    key?: string;
    permission: KeyPermission;
    /**
     * Bound author if set
     */
    boundAuthor?: string;
    /**
     * Human-readable name
     */
    displayName?: string;
    /**
     * WIP limit for this key
     */
    wipLimit?: number;
    /**
     * Allowed append types
     */
    allowedTypes?: Array<string>;
    /**
     * Key creation timestamp
     */
    createdAt: string;
    /**
     * Expiration timestamp if set
     */
    expiresAt?: string;
    /**
     * Last usage timestamp
     */
    lastUsedAt?: string;
    /**
     * Whether key has been revoked
     */
    revoked?: boolean;
};

export type ScopedKeyListResponse = {
    ok: true;
    data: Array<ScopedKey>;
    /**
     * URL to manage API keys in the web interface
     */
    webUrl?: string;
};

/**
 * Request to create a scoped capability key
 */
export type ScopedKeyCreateRequest = {
    permission: KeyPermission;
    /**
     * If set, all appends must use this author name
     */
    boundAuthor?: string;
    /**
     * Human-readable name for the key (e.g., "Alpha Research Agent")
     */
    displayName?: string;
    /**
     * Override WIP limit for this key
     */
    wipLimit?: number;
    /**
     * Restrict which append types this key can create
     */
    allowedTypes?: Array<'task' | 'claim' | 'response' | 'comment' | 'blocked' | 'answer' | 'renew' | 'cancel' | 'vote'>;
    /**
     * Key expiration timestamp
     */
    expiresAt?: string;
    /**
     * Restrict key to specific paths
     */
    paths?: Array<string>;
};

export type ScopedKeyCreateResponse = {
    ok: true;
    data: {
        /**
         * Unique identifier for the key (used for revocation)
         */
        id: string;
        /**
         * The scoped capability key (prefixed with r_/a_/w_)
         */
        key: string;
        permission: KeyPermission;
        /**
         * Bound author if set
         */
        boundAuthor?: string;
        /**
         * Human-readable name
         */
        displayName?: string;
        /**
         * WIP limit for this key
         */
        wipLimit?: number;
        /**
         * Allowed append types
         */
        allowedTypes?: Array<string>;
        /**
         * Expiration timestamp if set
         */
        expiresAt?: string;
        /**
         * Key creation timestamp
         */
        createdAt: string;
        /**
         * URL to manage API keys in the web interface
         */
        webUrl?: string;
    };
};

export type KeyRevokeResponse = {
    ok: true;
    data: {
        /**
         * Key ID
         */
        id: string;
        revoked: true;
    };
};

export type CapabilitiesCheckRequest = {
    /**
     * Array of capability keys to validate
     */
    keys: Array<string>;
};

export type CapabilityCheckResult = {
    /**
     * Truncated key (first 8 chars + "...")
     */
    key: string;
    /**
     * Whether the key is valid
     */
    valid: boolean;
    /**
     * Permission level (only present if valid)
     */
    permission?: 'read' | 'append' | 'write';
    /**
     * Scope type (only present if valid)
     */
    scope?: 'file' | 'folder' | 'workspace';
    /**
     * Workspace, folder, or file ID (only present if valid)
     */
    scopeId?: string;
    /**
     * Error code (NOT_FOUND, EXPIRED, REVOKED) - only present if invalid
     */
    error?: string;
};

export type CapabilitiesCheckResponse = {
    ok: true;
    data: {
        results: Array<CapabilityCheckResult>;
    };
};

/**
 * Workspace summary for user
 */
export type Workspace = {
    /**
     * Workspace ID
     */
    id: string;
    /**
     * Workspace name
     */
    name: string;
};

/**
 * Current authenticated user information
 */
export type MeResponse = {
    ok: true;
    data: {
        /**
         * User ID
         */
        id: string;
        /**
         * User email address
         */
        email: string;
        /**
         * User display name (from OAuth provider)
         */
        name?: string;
        /**
         * User avatar URL (from OAuth provider)
         */
        image?: string;
        /**
         * Workspaces the user has access to
         */
        workspaces: Array<Workspace>;
        /**
         * Account creation timestamp
         */
        createdAt?: string;
        /**
         * URL to access the user's control panel
         */
        webUrl?: string;
    };
};

export type LogoutResponse = {
    ok: true;
    data: {
        status?: 'logged_out';
    };
};

/**
 * Response from claim workspace endpoint (always instant with OAuth)
 */
export type ClaimWorkspaceResponse = {
    ok: true;
    data: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * Whether the workspace was successfully claimed
         */
        claimed: true;
        /**
         * Status message
         */
        message: string;
        /**
         * URL to access the workspace control panel
         */
        webUrl?: string;
    };
};

export type WorkspaceRenameRequest = {
    /**
     * New workspace name
     */
    name: string;
};

export type WorkspaceRenameResponse = {
    ok: true;
    data: {
        /**
         * Workspace ID
         */
        workspaceId: string;
        /**
         * Updated workspace name
         */
        name: string;
        /**
         * Time when the workspace name was updated
         */
        updatedAt: string;
    };
};

export type SuccessResponse = {
    ok: true;
    /**
     * Optional success data
     */
    data?: {
        /**
         * Success message
         */
        message?: string;
    };
};

export type RotateAllResponse = {
    ok: true;
    data: {
        /**
         * Workspace ID
         */
        workspaceId: string;
        message: string;
        /**
         * Number of files/folders that had URLs rotated
         */
        rotatedCount: number;
        keys: BootstrapKeys;
        urls: BootstrapUrls;
        /**
         * Warning that newly generated keys are shown once and must be stored now
         */
        keyCustodyWarning: string;
    };
};

/**
 * API key metadata (returned in list operations)
 */
export type ApiKey = {
    /**
     * Unique key identifier
     */
    id: string;
    /**
     * Human-readable key name
     */
    name: string;
    /**
     * Key permission scopes
     */
    permissions: Array<'read' | 'append' | 'write' | 'export'>;
    /**
     * Key creation timestamp
     */
    createdAt: string;
    /**
     * Key expiration timestamp (optional)
     */
    expiresAt?: string;
    /**
     * Last usage timestamp (optional)
     */
    lastUsedAt?: string;
    /**
     * Key prefix for identification (sk_live_ or sk_test_)
     */
    prefix: string;
};

/**
 * Response containing list of API keys
 */
export type ApiKeyListResponse = {
    ok: true;
    data: {
        /**
         * List of API keys (without full key values)
         */
        keys: Array<ApiKey>;
        /**
         * URL to manage API keys in the web app
         */
        webUrl?: string;
    };
};

/**
 * Request to create a new API key
 */
export type ApiKeyCreateRequest = {
    /**
     * Human-readable name for the key
     */
    name: string;
    /**
     * Permission scopes for the key
     */
    permissions: Array<'read' | 'append' | 'write' | 'export'>;
    /**
     * Time until expiration in seconds (optional)
     */
    expiresInSeconds?: number;
};

/**
 * Response from API key creation (key shown only once)
 */
export type ApiKeyCreateResponse = {
    ok: true;
    data: {
        /**
         * Unique key identifier
         */
        id: string;
        /**
         * Full API key (shown only once, store securely)
         */
        key: string;
        /**
         * Key name
         */
        name: string;
        permissions: Array<'read' | 'append' | 'write' | 'export'>;
        /**
         * Key creation timestamp
         */
        createdAt: string;
        /**
         * Key expiration timestamp (optional)
         */
        expiresAt?: string;
        /**
         * URL to manage API keys in the web app
         */
        webUrl?: string;
    };
};

/**
 * Response from API key revocation
 */
export type ApiKeyRevokeResponse = {
    ok: true;
    data: {
        /**
         * Key identifier
         */
        id: string;
        revoked: true;
    };
};

/**
 * Delivery status
 */
export type WebhookLogStatus = 'ok' | 'failed' | 'timeout' | 'error';

/**
 * Single webhook delivery log entry
 */
export type WebhookLogEntry = {
    /**
     * Log entry ID
     */
    id: string;
    event: WebhookEvent;
    status: WebhookLogStatus;
    /**
     * HTTP response code from webhook endpoint
     */
    responseCode?: number;
    /**
     * Delivery attempt timestamp
     */
    timestamp: string;
    /**
     * Request duration in milliseconds
     */
    durationMs?: number;
    /**
     * Error message if delivery failed
     */
    error?: string;
};

export type WebhookLogsResponse = {
    ok: true;
    data: {
        logs: Array<WebhookLogEntry>;
        pagination?: PaginatedResponse;
    };
};

/**
 * Request to send a test webhook
 */
export type WebhookTestRequest = {
    /**
     * Event type to simulate (defaults to 'append')
     */
    event?: WebhookEvent;
};

export type WebhookTestResponse = {
    ok: true;
    data: {
        /**
         * Whether test was successfully delivered
         */
        delivered: boolean;
        /**
         * HTTP response code from webhook endpoint
         */
        responseCode?: number;
        /**
         * Request duration in milliseconds
         */
        durationMs: number;
        /**
         * Error message if delivery failed
         */
        error?: string;
    };
};

/**
 * Type of search result
 */
export type SearchResultType = 'file' | 'append' | 'task';

/**
 * Highlighted match position in content
 */
export type SearchHighlight = {
    /**
     * Start position of highlight (0-indexed)
     */
    start: number;
    /**
     * End position of highlight (0-indexed, exclusive)
     */
    end: number;
};

/**
 * Single search result item
 */
export type SearchResult = {
    type: SearchResultType;
    /**
     * Unique identifier for the result (file ID or append ID)
     */
    id: string;
    file?: FileReference;
    /**
     * Content snippet matching the search query
     */
    content: string;
    /**
     * Array of highlighted match positions
     */
    highlights: Array<SearchHighlight>;
    /**
     * Relevance score for the result
     */
    score: number;
    /**
     * Status (for task/claim types)
     */
    status?: string;
    /**
     * Author of the append
     */
    author?: string;
    /**
     * Creation timestamp
     */
    createdAt?: string;
    /**
     * Frontmatter fields (when filtering by frontmatter)
     */
    frontmatter?: {
        [key: string]: unknown;
    };
};

/**
 * Response from workspace/scoped search endpoints
 */
export type SearchResponse = {
    ok: true;
    data: {
        /**
         * Array of search results
         */
        results: Array<SearchResult>;
        /**
         * Total number of matching results
         */
        total?: number;
    };
    pagination?: PaginatedResponse;
};

/**
 * Agent liveness status
 */
export type HeartbeatStatus = 'alive' | 'idle' | 'busy' | 'error' | 'stale';

/**
 * Request to send agent heartbeat
 */
export type HeartbeatRequest = {
    /**
     * Agent identifier
     */
    author: string;
    status: HeartbeatStatus;
    /**
     * Currently active task reference (optional)
     */
    currentTask?: string;
    /**
     * Additional agent metadata (optional)
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Response from heartbeat endpoint
 */
export type HeartbeatResponse = {
    ok: true;
    data: {
        /**
         * Heartbeat ID
         */
        id: string;
        /**
         * Agent identifier
         */
        author: string;
        /**
         * Heartbeat timestamp
         */
        ts: string;
        /**
         * When this heartbeat expires
         */
        expiresAt: string;
        /**
         * Deadline for next heartbeat to maintain liveness
         */
        nextHeartbeatBy: string;
    };
};

export type StatsScope = {
    /**
     * The scope type of the write key
     */
    type: 'file' | 'folder' | 'workspace';
    /**
     * ID of the scoped resource (file ID, folder path, or workspace ID)
     */
    id: string;
};

export type StatsCounts = {
    /**
     * Number of files in scope
     */
    files: number;
    /**
     * Total number of appends
     */
    appends: number;
    /**
     * Number of task appends
     */
    tasks: number;
    /**
     * Number of claim appends
     */
    claims: number;
    /**
     * Number of unique agents/authors
     */
    agents: number;
};

export type StatsActivity = {
    /**
     * Timestamp of the most recent append
     */
    lastAppendAt: string | null;
    /**
     * Number of appends today
     */
    appendsToday: number;
    /**
     * Number of appends in the last 7 days
     */
    appendsThisWeek: number;
};

export type StatsViaWriteKeyResponse = {
    ok: true;
    data: {
        scope: StatsScope;
        counts: StatsCounts;
        activity: StatsActivity;
    };
};

export type StatsErrorResponse = {
    ok?: false;
    error?: {
        code?: 'INVALID_KEY' | 'KEY_EXPIRED' | 'KEY_REVOKED' | 'PERMISSION_DENIED';
    };
};

export type FileStatsResponse = {
    ok: true;
    data: {
        /**
         * Total number of appends on this file
         */
        appendCount: number;
        taskStats: TaskStats;
    };
};

export type WorkspaceStatsResponse = {
    ok: true;
    data: {
        /**
         * Total number of files in workspace
         */
        fileCount: number;
        /**
         * Total number of folders in workspace
         */
        folderCount: number;
        /**
         * Total size of all files in bytes
         */
        totalSize: number;
        /**
         * Total number of appends across all files
         */
        appendCount: number;
        taskStats: TaskStats;
        /**
         * Storage used in bytes
         */
        storageUsed: number;
        /**
         * Storage limit in bytes
         */
        storageLimit: number;
    };
};

/**
 * Status of an async job
 */
export type JobStatus = 'pending' | 'processing' | 'completed' | 'failed';

/**
 * Response containing job status and details
 */
export type JobResponse = {
    ok: true;
    data: {
        /**
         * Unique job identifier
         */
        id: string;
        status: JobStatus;
        /**
         * Progress information (for processing jobs)
         */
        progress?: {
            /**
             * Items processed so far
             */
            current?: number;
            /**
             * Total items to process
             */
            total?: number;
            /**
             * Human-readable progress message
             */
            message?: string;
        };
        /**
         * Job result data (for completed jobs)
         */
        result?: {
            [key: string]: unknown;
        };
        /**
         * Error details (for failed jobs)
         */
        error?: {
            code?: string;
            message?: string;
        };
        /**
         * Job creation timestamp
         */
        createdAt: string;
        /**
         * Job completion timestamp (optional)
         */
        completedAt?: string;
    };
};

export type ExportJobCreateResponse = {
    ok: true;
    data: {
        /**
         * Export job identifier
         */
        jobId: string;
        status: 'queued' | 'processing';
        /**
         * URL to poll for job status
         */
        statusUrl: string;
        /**
         * Estimated export size
         */
        estimatedSize?: string;
        /**
         * Position in queue (if queued)
         */
        position?: number;
    };
};

export type ExportJobStatusResponse = {
    ok: true;
    data: {
        /**
         * Export job identifier
         */
        id: string;
        status: 'queued' | 'processing' | 'ready' | 'failed' | 'expired';
        progress?: {
            filesProcessed?: number;
            totalFiles?: number;
            bytesWritten?: string;
        };
        startedAt?: string;
        /**
         * URL to download export (only when status is ready)
         */
        downloadUrl?: string;
        /**
         * When the download URL expires
         */
        expiresAt?: string;
        /**
         * SHA-256 checksum (only when status is ready)
         */
        checksum?: string;
        /**
         * Final export size (only when status is ready)
         */
        size?: string;
        /**
         * Error details (only when status is failed)
         */
        error?: {
            code?: string;
            message?: string;
        };
    };
};

export type DeletedFileEntry = {
    /**
     * File identifier
     */
    id: string;
    /**
     * Original file path
     */
    path: string;
    /**
     * When the file was deleted
     */
    deletedAt: string;
    /**
     * When the file becomes unrecoverable
     */
    expiresAt: string;
    /**
     * Author who deleted the file (if known)
     */
    deletedBy?: string;
    /**
     * File size in bytes
     */
    size?: number;
};

export type DeletedFilesListResponse = {
    ok: true;
    data: {
        files: Array<DeletedFileEntry>;
    };
    pagination?: {
        cursor?: string;
        hasMore?: boolean;
        total?: number;
    };
};

/**
 * Current liveness state of an agent
 */
export type AgentLiveness = {
    /**
     * Agent identifier
     */
    author: string;
    status: HeartbeatStatus;
    /**
     * Last heartbeat timestamp
     */
    lastSeen: string;
    /**
     * Whether agent is considered stale
     */
    stale?: boolean;
    /**
     * Currently active task reference (optional)
     */
    currentTask?: string;
    /**
     * Additional agent metadata (optional)
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Response containing agent liveness information
 */
export type AgentLivenessResponse = {
    ok: true;
    data: {
        /**
         * List of agents with their liveness status
         */
        agents: Array<AgentLiveness>;
        /**
         * Seconds after which an agent is considered stale
         */
        staleThresholdSeconds: number;
        /**
         * URL to view agents in the web interface
         */
        webUrl?: string;
    };
};

export type OrchestrationSummary = {
    pending: number;
    claimed: number;
    completed: number;
    stalled: number;
    cancelled: number;
};

export type OrchestrationTask = {
    /**
     * Task append ID
     */
    id: string;
    file: {
        id: string;
        path: string;
    };
    /**
     * Task content/description
     */
    content: string;
    /**
     * Task creator
     */
    author: string;
    /**
     * Current orchestration status for this task
     */
    status: 'pending' | 'claimed' | 'stalled' | 'completed' | 'cancelled';
    priority?: 'low' | 'medium' | 'high' | 'critical';
    labels?: Array<string>;
    createdAt: string;
    due?: string;
    /**
     * Current claim info (if claimed)
     */
    claim?: {
        id?: string;
        author?: string;
        expiresAt?: string;
        blocked?: boolean;
        blockReason?: string;
    };
};

export type OrchestrationClaim = {
    /**
     * Claim append ID
     */
    id: string;
    /**
     * Task being claimed
     */
    taskId: string;
    file: {
        id: string;
        path: string;
    };
    /**
     * Claiming agent
     */
    author: string;
    expiresAt: string;
    expiresInSeconds?: number;
    status: 'active' | 'blocked' | 'expired';
    blocked?: boolean;
    blockReason?: string;
};

export type OrchestrationAgentStatus = {
    author?: string;
    status?: 'alive' | 'idle' | 'busy' | 'stale';
    lastSeen?: string;
    currentTask?: string;
};

export type OrchestrationWorkload = {
    activeClaims?: number;
    completedToday?: number;
};

export type OrchestrationReadOnlyResponse = {
    ok: true;
    data: {
        summary: OrchestrationSummary;
        /**
         * Flat orchestration tasks list; group by task.status in consumers
         */
        tasks: Array<OrchestrationTask>;
        /**
         * Active claims across all files
         */
        claims: Array<OrchestrationClaim>;
        /**
         * Agent liveness status
         */
        agents: Array<OrchestrationAgentStatus>;
        /**
         * Workload distribution across agents
         */
        workload: {
            [key: string]: OrchestrationWorkload;
        };
        pagination?: {
            cursor?: string;
            hasMore?: boolean;
        };
        /**
         * URL to view orchestration in the web interface
         */
        webUrl?: string;
    };
};

export type OrchestrationAdminResponse = {
    ok: true;
    data: {
        summary: OrchestrationSummary;
        /**
         * Flat orchestration tasks list; group by task.status in consumers
         */
        tasks: Array<OrchestrationTask>;
        /**
         * Active claims with write-level actions
         */
        claims: Array<OrchestrationClaim & {
            /**
             * Whether this claim can be force-expired
             */
            canForceExpire?: true;
        }>;
        agents: Array<OrchestrationAgentStatus>;
        workload: {
            [key: string]: OrchestrationWorkload;
        };
        pagination?: {
            cursor?: string;
            hasMore?: boolean;
        };
        /**
         * URL to view orchestration in the web interface
         */
        webUrl?: string;
    };
};

export type RenewClaimRequest = {
    /**
     * New TTL in seconds (default 300)
     */
    expiresInSeconds?: number;
};

/**
 * Claim data formatted for control view display
 */
export type ControlClaim = {
    /**
     * Claim append ID
     */
    id: string;
    /**
     * The task being claimed
     */
    taskId: string;
    /**
     * Task title/content preview for display
     */
    taskTitle?: string;
    /**
     * File path where the task lives
     */
    path: string;
    /**
     * Append capability key for the file (for direct append access)
     */
    appendKey?: string;
    /**
     * Claiming agent/user
     */
    author: string;
    /**
     * Current claim status
     */
    status: 'active' | 'expired' | 'completed' | 'cancelled' | 'blocked';
    /**
     * When the claim was created
     */
    claimedAt?: string;
    /**
     * When the claim expires
     */
    expiresAt: string;
    /**
     * Seconds until expiry (convenience field)
     */
    expiresInSeconds?: number;
    /**
     * When the task was completed (if completed)
     */
    completedAt?: string;
    /**
     * Why the claim is blocked (if blocked)
     */
    blockedReason?: string;
};

export type ClaimMutationResponse = {
    ok: true;
    data: {
        claim: ControlClaim;
        /**
         * ID of the append created by this mutation
         */
        appendId?: string;
        /**
         * URL to view claims in the web interface
         */
        webUrl?: string;
    };
};

export type CompleteClaimRequest = {
    /**
     * Completion message/content
     */
    content?: string;
};

export type CancelClaimRequest = {
    /**
     * Why the claim is being cancelled
     */
    reason?: string;
};

export type BlockClaimRequest = {
    /**
     * Why the claim is blocked
     */
    reason: string;
};

export type FileCreateResponse = {
    ok: true;
    data: {
        /**
         * File ID
         */
        id: string;
        /**
         * Full file path
         */
        path: string;
        urls: CapabilityUrls;
        /**
         * Creation timestamp
         */
        createdAt: string;
        /**
         * URL to view this file in the web app
         */
        webUrl?: string;
    };
};

/**
 * Simple health check response for liveness probes
 */
export type HealthCheckSimpleResponse = {
    ok: true;
    /**
     * Always "healthy" when responding
     */
    status: 'healthy';
    /**
     * Current server time
     */
    timestamp?: string;
    /**
     * Server uptime in seconds
     */
    uptimeSeconds?: number;
    /**
     * API version
     */
    version?: string;
};

/**
 * Type of changelog entry
 */
export type ChangeType = 'added' | 'changed' | 'deprecated' | 'removed' | 'fixed' | 'security';

/**
 * Single changelog entry
 */
export type ChangelogEntry = {
    /**
     * Version number
     */
    version: string;
    /**
     * Release date
     */
    date: string;
    /**
     * List of changes in this version
     */
    changes: Array<{
        type: ChangeType;
        /**
         * Change description
         */
        description: string;
    }>;
};

/**
 * Response containing changelog entries
 */
export type ChangelogResponse = {
    ok: true;
    data: {
        /**
         * Current API version
         */
        currentVersion: string;
        /**
         * Release date of current version
         */
        releasedAt: string;
        /**
         * List of changelog entries (newest first)
         */
        entries: Array<ChangelogEntry>;
    };
};

/**
 * Status of a deployment region
 */
export type RegionStatus = {
    /**
     * Region name
     */
    name: string;
    /**
     * Region status
     */
    status: 'operational' | 'degraded' | 'down';
};

/**
 * Response from status endpoint with system information
 */
export type StatusResponse = {
    ok: true;
    data: {
        /**
         * Overall service status
         */
        status: 'operational' | 'degraded' | 'partial_outage' | 'major_outage';
        /**
         * Current server time in ISO-8601 format
         */
        timestamp: string;
        /**
         * Runtime environment
         */
        environment: 'development' | 'test' | 'production';
        /**
         * Server uptime in seconds
         */
        uptimeSeconds: number;
        /**
         * API version
         */
        version: string;
        /**
         * Database status
         */
        database: {
            /**
             * Database status
             */
            status: 'operational' | 'degraded' | 'down';
            /**
             * Database latency in milliseconds
             */
            latencyMs?: number;
        };
        /**
         * Storage status
         */
        storage: {
            /**
             * Storage service status
             */
            status: 'operational' | 'degraded' | 'down';
            /**
             * Storage check latency in milliseconds
             */
            latencyMs?: number;
        };
        /**
         * WebSocket subsystem status
         */
        websocket: {
            /**
             * WebSocket service status
             */
            status: 'operational' | 'degraded' | 'down';
            /**
             * WebSocket check latency in milliseconds
             */
            latencyMs?: number;
            /**
             * Number of active WebSocket connections
             */
            activeConnections?: number;
        };
        /**
         * Available regions and their status
         */
        regions: Array<RegionStatus>;
    };
};

export type CapabilityCheckInWorkspaceResult = {
    /**
     * Truncated key (first 8 chars + "...")
     */
    key: string;
    /**
     * Whether the key is valid
     */
    valid: boolean;
    /**
     * Permission level (only present if valid)
     */
    permission?: 'read' | 'append' | 'write';
    /**
     * Scope type (only present if valid)
     */
    scope?: 'file' | 'folder' | 'workspace';
    /**
     * Workspace, folder, or file ID (only present if valid)
     */
    scopeId?: string;
    /**
     * Resource path (only present if valid and belongs to workspace)
     */
    path?: string;
    /**
     * Key status (only present if valid and belongs to workspace)
     */
    status?: 'active' | 'expired' | 'revoked';
    /**
     * Error code (NOT_FOUND, EXPIRED, REVOKED) - only present if invalid
     */
    error?: string;
};

export type CapabilitiesCheckInWorkspaceResponse = {
    ok: true;
    data: {
        results: Array<CapabilityCheckInWorkspaceResult>;
    };
};

export type AuditLogEntry = {
    /**
     * Unique audit log ID
     */
    id: string;
    /**
     * The action that was performed
     */
    action: string;
    /**
     * Type of resource affected
     */
    resourceType: string;
    /**
     * ID of the affected resource
     */
    resourceId?: string;
    /**
     * Path of the affected resource
     */
    resourcePath?: string;
    /**
     * Actor who performed the action
     */
    actor?: string;
    /**
     * Type of actor
     */
    actorType?: 'capability_url' | 'api_key' | 'session';
    /**
     * Additional action-specific metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * IP address of the request
     */
    ipAddress?: string;
    /**
     * User agent of the request
     */
    userAgent?: string;
    /**
     * When the action occurred
     */
    createdAt: string;
};

export type AuditLogPagination = {
    /**
     * Total number of matching logs
     */
    total: number;
    /**
     * Maximum logs per page
     */
    limit: number;
    /**
     * Cursor for next page (opaque), null when no more results
     */
    cursor: string | null;
    /**
     * Whether more results are available
     */
    hasMore: boolean;
};

export type AuditLogsResponse = {
    ok: true;
    data: Array<AuditLogEntry>;
    pagination: AuditLogPagination;
};

export type AdminMetricsResponse = {
    ok: true;
    data: {
        storage: {
            /**
             * Current database file size in bytes
             */
            databaseSizeBytes: number;
            /**
             * Current database file size in megabytes
             */
            databaseSizeMB: number;
            /**
             * Maximum allowed database size (from config or volume)
             */
            maxSizeBytes?: number;
            /**
             * Maximum allowed database size in megabytes
             */
            maxSizeMB?: number;
            /**
             * Percentage of storage used (0-100)
             */
            usagePercent: number;
        };
        counts: {
            /**
             * Total number of workspaces (excluding deleted)
             */
            workspaces: number;
            /**
             * Total number of files (excluding deleted)
             */
            files: number;
            /**
             * Total number of folders (excluding deleted)
             */
            folders: number;
            /**
             * Total number of registered users
             */
            users: number;
            /**
             * Number of active user sessions
             */
            activeSessions: number;
            /**
             * Total number of capability keys (excluding revoked)
             */
            capabilityKeys: number;
        };
        quotas: {
            /**
             * Maximum storage per workspace in bytes
             */
            maxWorkspaceStorageBytes: number;
            /**
             * Maximum file size in bytes
             */
            maxFileSizeBytes: number;
        };
        uptime: {
            /**
             * Server uptime in seconds
             */
            seconds: number;
            /**
             * Human-readable uptime (e.g., "1d 2h 30m")
             */
            formatted: string;
        };
    };
};

export type FolderUrls = {
    /**
     * Folder path
     */
    path: string;
    urls: CapabilityUrls;
};

/**
 * User information
 */
export type User = {
    /**
     * User ID
     */
    id: string;
    /**
     * User email address
     */
    email: string;
    /**
     * Account creation timestamp
     */
    createdAt?: string;
};

/**
 * Request to claim a workspace (OAuth session provides identity)
 */
export type ClaimWorkspaceRequest = {
    [key: string]: never;
};

/**
 * Type of WebSocket message type
 */
export type SubscribeMessageType = 'connected' | 'error';

/**
 * WebSocket control message
 */
export type SubscribeMessage = {
    type: SubscribeMessageType;
    /**
     * Control message payload (structure varies by type)
     */
    data: {
        [key: string]: unknown;
    };
};

/**
 * Overall system health status
 */
export type HealthStatus = 'healthy' | 'degraded' | 'unhealthy';

/**
 * Response from health check endpoint
 */
export type HealthResponse = {
    ok: true;
    status: HealthStatus;
    /**
     * API version
     */
    version: string;
    /**
     * Individual health check results
     */
    checks: {
        [key: string]: {
            status?: HealthStatus;
            /**
             * Check latency in milliseconds
             */
            latencyMs?: number;
            /**
             * Additional status message
             */
            message?: string;
        };
    };
};

export type TransferWorkspaceRequest = {
    /**
     * Email of the new owner (must have an OAuth account)
     */
    newOwnerEmail: string;
};

export type FolderClaimEntry = {
    id: string;
    fileId: string;
    path: string;
    taskId: string;
    taskContent?: string;
    /**
     * Author who made the claim
     */
    author: string;
    expiresAt: string;
    expiresInSeconds?: number;
    status: 'active' | 'blocked' | 'expired';
    blockedAt?: string;
    blockReason?: string;
};

export type FolderClaimsViaAppendKeyResponse = {
    ok: true;
    data: {
        claims: Array<FolderClaimEntry>;
        count: number;
        /**
         * URL to view claims in the web interface
         */
        webUrl?: string;
    };
};

export type ListWorkspaceClaimsResponse = {
    ok: true;
    data: {
        claims: Array<ControlClaim>;
        /**
         * URL to view claims in the web interface
         */
        webUrl?: string;
    };
};

/**
 * Capability key (20+ chars, base62 with underscore)
 */
export type CapabilityKey = string;

/**
 * Response format
 */
export type Format = 'raw' | 'parsed' | 'structure';

/**
 * Return items modified after this timestamp (ISO 8601)
 */
export type Since = string;

/**
 * Append identifier (e.g., a1, a42)
 */
export type AppendId = string;

/**
 * URL-encoded folder path
 */
export type FolderPath = string;

/**
 * Maximum number of items to return
 */
export type Limit = number;

/**
 * Pagination cursor for fetching next page
 */
export type Cursor = string;

/**
 * URL-encoded folder path (omit for workspace root)
 */
export type FolderPathQuery = string;

/**
 * Filter by author identifier
 */
export type Author = string;

/**
 * Scoped key identifier
 */
export type KeyId = string;

/**
 * Workspace identifier
 */
export type WorkspaceId = string;

/**
 * Webhook identifier
 */
export type WebhookId = string;

/**
 * Background job identifier
 */
export type JobId = string;

/**
 * The claim's append ID
 */
export type ClaimId = string;

export type CreateWorkspaceData = {
    /**
     * Required workspace bootstrap configuration
     */
    body: BootstrapRequest;
    path?: never;
    query?: never;
    url: '/bootstrap';
};

export type CreateWorkspaceErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type CreateWorkspaceError = CreateWorkspaceErrors[keyof CreateWorkspaceErrors];

export type CreateWorkspaceResponses = {
    /**
     * Workspace created successfully
     */
    201: BootstrapResponse;
};

export type CreateWorkspaceResponse = CreateWorkspaceResponses[keyof CreateWorkspaceResponses];

export type ReadFileData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Response format
         */
        format?: 'raw' | 'parsed' | 'structure';
        /**
         * Return items modified after this timestamp (ISO 8601)
         */
        since?: string;
        /**
         * Number of recent appends to include
         */
        appends?: number;
        /**
         * Include additional data (e.g., stats)
         */
        include?: 'stats';
    };
    url: '/r/{key}';
};

export type ReadFileErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ReadFileError = ReadFileErrors[keyof ReadFileErrors];

export type ReadFileResponses = {
    /**
     * File content retrieved successfully
     */
    200: FileReadResponse;
};

export type ReadFileResponse = ReadFileResponses[keyof ReadFileResponses];

export type DeleteFileData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Hard delete (irreversible)
         */
        permanent?: boolean;
    };
    url: '/w/{key}';
};

export type DeleteFileErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type DeleteFileError = DeleteFileErrors[keyof DeleteFileErrors];

export type DeleteFileResponses = {
    /**
     * File deleted successfully
     */
    200: FileDeleteResponse;
};

export type DeleteFileResponse = DeleteFileResponses[keyof DeleteFileResponses];

export type ReadFileViaWriteKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Response format
         */
        format?: 'raw' | 'parsed' | 'structure';
        /**
         * Return items modified after this timestamp (ISO 8601)
         */
        since?: string;
        /**
         * Number of recent appends to include
         */
        appends?: number;
        /**
         * Include additional data (e.g., stats)
         */
        include?: 'stats';
    };
    url: '/w/{key}';
};

export type ReadFileViaWriteKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ReadFileViaWriteKeyError = ReadFileViaWriteKeyErrors[keyof ReadFileViaWriteKeyErrors];

export type ReadFileViaWriteKeyResponses = {
    /**
     * File content retrieved successfully
     */
    200: FileReadResponse;
};

export type ReadFileViaWriteKeyResponse = ReadFileViaWriteKeyResponses[keyof ReadFileViaWriteKeyResponses];

export type RenameFileData = {
    body: FileRenameRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}';
};

export type RenameFileErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type RenameFileError = RenameFileErrors[keyof RenameFileErrors];

export type RenameFileResponses = {
    /**
     * File renamed successfully
     */
    200: FileRenameResponse;
};

export type RenameFileResponse = RenameFileResponses[keyof RenameFileResponses];

export type UpdateFileData = {
    body: FileUpdateRequest;
    headers?: {
        /**
         * ETag from previous read for optimistic concurrency
         */
        'If-Match'?: string;
    };
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}';
};

export type UpdateFileErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * ETag mismatch - file was modified since last read
     */
    412: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type UpdateFileError = UpdateFileErrors[keyof UpdateFileErrors];

export type UpdateFileResponses = {
    /**
     * File updated successfully
     */
    200: FileUpdateResponse;
};

export type UpdateFileResponse = UpdateFileResponses[keyof UpdateFileResponses];

export type ReadFileRawData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/r/{key}/raw';
};

export type ReadFileRawErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ReadFileRawError = ReadFileRawErrors[keyof ReadFileRawErrors];

export type ReadFileRawResponses = {
    /**
     * Raw markdown content
     */
    200: string;
};

export type ReadFileRawResponse = ReadFileRawResponses[keyof ReadFileRawResponses];

export type ReadFileMetaData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/r/{key}/meta';
};

export type ReadFileMetaErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ReadFileMetaError = ReadFileMetaErrors[keyof ReadFileMetaErrors];

export type ReadFileMetaResponses = {
    /**
     * File metadata retrieved successfully
     */
    200: FileMetaResponse;
};

export type ReadFileMetaResponse = ReadFileMetaResponses[keyof ReadFileMetaResponses];

export type ReadFileTailData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Last N bytes to return (default 10000, max 100000)
         */
        bytes?: number;
        /**
         * Last N lines to return (approximate)
         */
        lines?: number;
    };
    url: '/r/{key}/tail';
};

export type ReadFileTailErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ReadFileTailError = ReadFileTailErrors[keyof ReadFileTailErrors];

export type ReadFileTailResponses = {
    /**
     * Tail content retrieved successfully
     */
    200: FileTailResponse;
};

export type ReadFileTailResponse = ReadFileTailResponses[keyof ReadFileTailResponses];

export type ReadFileStructureData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/r/{key}/structure';
};

export type ReadFileStructureErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ReadFileStructureError = ReadFileStructureErrors[keyof ReadFileStructureErrors];

export type ReadFileStructureResponses = {
    /**
     * File structure retrieved successfully
     */
    200: FileStructureResponse;
};

export type ReadFileStructureResponse = ReadFileStructureResponses[keyof ReadFileStructureResponses];

export type ReadFileSectionData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * Heading text to find (URL-encoded)
         */
        heading: string;
    };
    query?: never;
    url: '/r/{key}/section/{heading}';
};

export type ReadFileSectionErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ReadFileSectionError = ReadFileSectionErrors[keyof ReadFileSectionErrors];

export type ReadFileSectionResponses = {
    /**
     * Section content retrieved successfully
     */
    200: FileSectionResponse;
};

export type ReadFileSectionResponse = ReadFileSectionResponses[keyof ReadFileSectionResponses];

export type ReadAppendData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * Append identifier (e.g., a1, a42)
         */
        appendId: string;
    };
    query?: never;
    url: '/r/{key}/ops/file/append/{appendId}';
};

export type ReadAppendErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ReadAppendError = ReadAppendErrors[keyof ReadAppendErrors];

export type ReadAppendResponses = {
    /**
     * Append retrieved successfully
     */
    200: AppendGetResponse;
};

export type ReadAppendResponse = ReadAppendResponses[keyof ReadAppendResponses];

export type RecoverFileData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Generate new capability URLs (invalidates old ones)
         */
        rotateUrls?: boolean;
    };
    url: '/w/{key}/recover';
};

export type RecoverFileErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type RecoverFileError = RecoverFileErrors[keyof RecoverFileErrors];

export type RecoverFileResponses = {
    /**
     * File recovered successfully
     */
    200: FileRecoverResponse;
};

export type RecoverFileResponse = RecoverFileResponses[keyof RecoverFileResponses];

export type MoveFileData = {
    body: FileMoveRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/move';
};

export type MoveFileErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type MoveFileError = MoveFileErrors[keyof MoveFileErrors];

export type MoveFileResponses = {
    /**
     * File moved successfully
     */
    200: FileMoveResponse;
};

export type MoveFileResponse = MoveFileResponses[keyof MoveFileResponses];

export type RotateCapabilityUrlsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/rotate';
};

export type RotateCapabilityUrlsErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type RotateCapabilityUrlsError = RotateCapabilityUrlsErrors[keyof RotateCapabilityUrlsErrors];

export type RotateCapabilityUrlsResponses = {
    /**
     * URLs rotated successfully
     */
    200: FileRotateUrlsResponse;
};

export type RotateCapabilityUrlsResponse = RotateCapabilityUrlsResponses[keyof RotateCapabilityUrlsResponses];

export type GetFileSettingsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/settings';
};

export type GetFileSettingsErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetFileSettingsError = GetFileSettingsErrors[keyof GetFileSettingsErrors];

export type GetFileSettingsResponses = {
    /**
     * File settings retrieved successfully
     */
    200: FileSettingsResponse;
};

export type GetFileSettingsResponse = GetFileSettingsResponses[keyof GetFileSettingsResponses];

export type UpdateFileSettingsData = {
    body: FileSettingsUpdateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/settings';
};

export type UpdateFileSettingsErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type UpdateFileSettingsError = UpdateFileSettingsErrors[keyof UpdateFileSettingsErrors];

export type UpdateFileSettingsResponses = {
    /**
     * File settings updated successfully
     */
    200: FileSettingsResponse;
};

export type UpdateFileSettingsResponse = UpdateFileSettingsResponses[keyof UpdateFileSettingsResponses];

export type CreateAppendData = {
    body: AppendRequest | MultiAppendRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/a/{key}/append';
};

export type CreateAppendErrors = {
    /**
     * Invalid request. Possible error codes:
     * - `INVALID_APPEND_TYPE`: Unknown type value
     * - `INVALID_REF`: ref points to wrong append type or doesn't exist
     * - `INVALID_VOTE_VALUE`: vote type with value other than +1 or -1
     * - `INVALID_AUTHOR`: Author field fails validation
     * - `TASK_ALREADY_COMPLETE`: Trying to claim a completed task
     * - `TASK_CANCELLED`: Trying to claim, respond to, or renew a cancelled task
     * - `CLAIM_EXPIRED`: Trying to renew, respond to, or mark blocked a claim that has expired
     * - `AUTHOR_MISMATCH`: Append author doesn't match key's boundAuthor
     * - `TYPE_NOT_ALLOWED`: Append type not in key's allowedTypes
     *
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Conflict. Possible error codes:
     * - `ALREADY_CLAIMED`: Task already has active claim
     *
     */
    409: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limited. Possible error codes:
     * - `RATE_LIMITED`: Too many requests
     * - `WIP_LIMIT_EXCEEDED`: Author at max concurrent claims
     * - `AUTHOR_RATE_LIMITED`: Author exceeded per-file or per-workspace append limit
     *
     */
    429: Error;
};

export type CreateAppendError = CreateAppendErrors[keyof CreateAppendErrors];

export type CreateAppendResponses = {
    /**
     * Append created successfully
     */
    201: AppendResponse;
};

export type CreateAppendResponse = CreateAppendResponses[keyof CreateAppendResponses];

export type CreateScopedAppendData = {
    body: ScopedAppendRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * Path to the file within the workspace (relative to scopePath if set)
         */
        path: string;
    };
    query?: never;
    url: '/a/{key}/{path}';
};

export type CreateScopedAppendErrors = {
    /**
     * Invalid request. Possible error codes:
     * - `AUTHOR_MISMATCH`: Author does not match key's boundAuthor
     * - `TYPE_NOT_ALLOWED`: Append type not in key's allowedTypes
     *
     */
    400: Error;
    /**
     * Not found. Possible error codes:
     * - `KEY_NOT_FOUND`: Invalid capability key
     * - `FILE_NOT_FOUND`: File does not exist at the specified path
     * - `PERMISSION_DENIED`: Path outside of key's scopePath
     *
     */
    404: Error;
};

export type CreateScopedAppendError = CreateScopedAppendErrors[keyof CreateScopedAppendErrors];

export type CreateScopedAppendResponses = {
    /**
     * Append created successfully
     */
    201: ScopedAppendResponse;
};

export type CreateScopedAppendResponse = CreateScopedAppendResponses[keyof CreateScopedAppendResponses];

export type ListFolderContentsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: {
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
        /**
         * Special action to perform. When set to `export`, returns folder contents as
         * a downloadable archive instead of JSON listing.
         *
         */
        action?: 'export';
        /**
         * Archive format (only used when action=export)
         */
        format?: 'zip' | 'tar.gz';
        /**
         * Include all nested contents recursively
         */
        recursive?: boolean;
        /**
         * Sort field
         */
        sort?: 'name' | 'modified' | 'size';
        /**
         * Sort order
         */
        order?: 'asc' | 'desc';
        /**
         * Include append history in export metadata (only used when action=export)
         */
        includeAppends?: boolean;
    };
    url: '/r/{key}/folders/{path}';
};

export type ListFolderContentsErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ListFolderContentsError = ListFolderContentsErrors[keyof ListFolderContentsErrors];

export type ListFolderContentsResponses = {
    /**
     * Folder contents retrieved successfully.
     *
     * When `action=export`, returns binary archive with Content-Disposition header.
     *
     */
    200: FolderListResponse;
};

export type ListFolderContentsResponse = ListFolderContentsResponses[keyof ListFolderContentsResponses];

export type ListFolderContentsViaAppendKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: {
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
        /**
         * Include all nested contents recursively
         */
        recursive?: boolean;
        /**
         * Sort field
         */
        sort?: 'name' | 'modified' | 'size';
        /**
         * Sort order
         */
        order?: 'asc' | 'desc';
    };
    url: '/a/{key}/folders/{path}';
};

export type ListFolderContentsViaAppendKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ListFolderContentsViaAppendKeyError = ListFolderContentsViaAppendKeyErrors[keyof ListFolderContentsViaAppendKeyErrors];

export type ListFolderContentsViaAppendKeyResponses = {
    /**
     * Folder contents retrieved successfully
     */
    200: FolderListResponse;
};

export type ListFolderContentsViaAppendKeyResponse = ListFolderContentsViaAppendKeyResponses[keyof ListFolderContentsViaAppendKeyResponses];

export type CreateFileInFolderData = {
    body: CreateFileRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/a/{key}/folders/{path}/files';
};

export type CreateFileInFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type CreateFileInFolderError = CreateFileInFolderErrors[keyof CreateFileInFolderErrors];

export type CreateFileInFolderResponses = {
    /**
     * File created successfully
     */
    201: CreateFileResponse;
};

export type CreateFileInFolderResponse = CreateFileInFolderResponses[keyof CreateFileInFolderResponses];

export type DeleteFolderData = {
    body?: FolderDeleteRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}';
};

export type DeleteFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Folder not empty (use cascade delete)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type DeleteFolderError = DeleteFolderErrors[keyof DeleteFolderErrors];

export type DeleteFolderResponses = {
    /**
     * Folder deleted successfully
     */
    200: FolderDeleteResponse;
};

export type DeleteFolderResponse = DeleteFolderResponses[keyof DeleteFolderResponses];

export type ListFolderContentsViaWriteKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: {
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
        /**
         * Include all nested contents recursively
         */
        recursive?: boolean;
        /**
         * Sort field
         */
        sort?: 'name' | 'modified' | 'size';
        /**
         * Sort order
         */
        order?: 'asc' | 'desc';
    };
    url: '/w/{key}/folders/{path}';
};

export type ListFolderContentsViaWriteKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ListFolderContentsViaWriteKeyError = ListFolderContentsViaWriteKeyErrors[keyof ListFolderContentsViaWriteKeyErrors];

export type ListFolderContentsViaWriteKeyResponses = {
    /**
     * Folder contents retrieved successfully
     */
    200: FolderListResponse;
};

export type ListFolderContentsViaWriteKeyResponse = ListFolderContentsViaWriteKeyResponses[keyof ListFolderContentsViaWriteKeyResponses];

export type RenameFolderData = {
    body: FolderRenameRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}';
};

export type RenameFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type RenameFolderError = RenameFolderErrors[keyof RenameFolderErrors];

export type RenameFolderResponses = {
    /**
     * Folder renamed successfully
     */
    200: FolderMoveResponse;
};

export type RenameFolderResponse = RenameFolderResponses[keyof RenameFolderResponses];

export type CreateFolderData = {
    body: FolderCreateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/folders';
};

export type CreateFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type CreateFolderError = CreateFolderErrors[keyof CreateFolderErrors];

export type CreateFolderResponses = {
    /**
     * Folder created successfully
     */
    201: FolderCreateResponse;
};

export type CreateFolderResponse = CreateFolderResponses[keyof CreateFolderResponses];

export type CopyFileToFolderData = {
    body: CopyFileToFolderRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/a/{key}/folders/{path}/copy';
};

export type CopyFileToFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type CopyFileToFolderError = CopyFileToFolderErrors[keyof CopyFileToFolderErrors];

export type CopyFileToFolderResponses = {
    /**
     * File copied successfully
     */
    201: CreateFileResponse;
};

export type CopyFileToFolderResponse = CopyFileToFolderResponses[keyof CopyFileToFolderResponses];

export type BulkCreateFilesData = {
    body: FolderBulkCreateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: {
        /**
         * Return immediately with job ID for async processing
         */
        async?: boolean;
    };
    url: '/a/{key}/folders/{path}/bulk';
};

export type BulkCreateFilesErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type BulkCreateFilesError = BulkCreateFilesErrors[keyof BulkCreateFilesErrors];

export type BulkCreateFilesResponses = {
    /**
     * Files created successfully (sync mode)
     */
    201: FolderBulkCreateResponse;
    /**
     * Job accepted (async mode)
     */
    202: FolderBulkCreateJobResponse;
};

export type BulkCreateFilesResponse = BulkCreateFilesResponses[keyof BulkCreateFilesResponses];

export type MoveFolderData = {
    body: FolderMoveRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}/move';
};

export type MoveFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type MoveFolderError = MoveFolderErrors[keyof MoveFolderErrors];

export type MoveFolderResponses = {
    /**
     * Folder moved successfully
     */
    200: FolderMoveResponse;
};

export type MoveFolderResponse = MoveFolderResponses[keyof MoveFolderResponses];

export type GetFolderSettingsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}/settings';
};

export type GetFolderSettingsErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetFolderSettingsError = GetFolderSettingsErrors[keyof GetFolderSettingsErrors];

export type GetFolderSettingsResponses = {
    /**
     * Folder settings retrieved successfully
     */
    200: FolderSettingsResponse;
};

export type GetFolderSettingsResponse = GetFolderSettingsResponses[keyof GetFolderSettingsResponses];

export type UpdateFolderSettingsData = {
    body: FolderSettingsUpdateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}/settings';
};

export type UpdateFolderSettingsErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type UpdateFolderSettingsError = UpdateFolderSettingsErrors[keyof UpdateFolderSettingsErrors];

export type UpdateFolderSettingsResponses = {
    /**
     * Folder settings updated successfully
     */
    200: FolderSettingsResponse;
};

export type UpdateFolderSettingsResponse = UpdateFolderSettingsResponses[keyof UpdateFolderSettingsResponses];

export type GetFolderStatsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * URL-encoded folder path (omit for workspace root)
         */
        path?: string;
    };
    url: '/r/{key}/ops/folders/stats';
};

export type GetFolderStatsErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetFolderStatsError = GetFolderStatsErrors[keyof GetFolderStatsErrors];

export type GetFolderStatsResponses = {
    /**
     * Folder statistics retrieved successfully
     */
    200: FolderStatsResponse;
};

export type GetFolderStatsResponse = GetFolderStatsResponses[keyof GetFolderStatsResponses];

export type SearchInFolderData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * URL-encoded folder path (omit for workspace root)
         */
        path?: string;
        /**
         * Full-text search query
         */
        q?: string;
        /**
         * Filter by append type
         */
        type?: 'task' | 'comment' | 'response' | 'claim';
        /**
         * Filter by task status (comma-separated for multiple)
         */
        status?: 'pending' | 'claimed' | 'completed' | 'failed';
        /**
         * Filter by author identifier
         */
        author?: string;
        /**
         * Filter by labels (comma-separated, OR matching)
         */
        labels?: string;
        /**
         * Filter by priority (comma-separated for multiple)
         */
        priority?: string;
        /**
         * Modified after this date (ISO 8601)
         */
        since?: string;
        /**
         * Max search duration (default 5s, max 30s)
         */
        timeout?: string;
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
    };
    url: '/r/{key}/ops/folders/search';
};

export type SearchInFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type SearchInFolderError = SearchInFolderErrors[keyof SearchInFolderErrors];

export type SearchInFolderResponses = {
    /**
     * Search results
     */
    200: FolderSearchResponse;
};

export type SearchInFolderResponse = SearchInFolderResponses[keyof SearchInFolderResponses];

export type QueryFolderTasksData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * URL-encoded folder path (omit for workspace root)
         */
        path?: string;
        /**
         * Filter by task status (comma-separated for multiple)
         */
        status?: 'pending' | 'claimed' | 'completed' | 'cancelled';
        /**
         * Filter by author identifier
         */
        author?: string;
        /**
         * Filter by priority (comma-separated for multiple)
         */
        priority?: string;
        /**
         * Filter by labels (comma-separated, OR matching)
         */
        labels?: string;
        /**
         * Filter by claiming agent identifier
         */
        claimedBy?: string;
        /**
         * Only return unclaimed tasks when true
         */
        claimable?: boolean;
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
    };
    url: '/r/{key}/ops/folders/tasks';
};

export type QueryFolderTasksErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type QueryFolderTasksError = QueryFolderTasksErrors[keyof QueryFolderTasksErrors];

export type QueryFolderTasksResponses = {
    /**
     * Tasks retrieved successfully
     */
    200: TaskQueryResponse;
};

export type QueryFolderTasksResponse = QueryFolderTasksResponses[keyof QueryFolderTasksResponses];

export type SubscribeFolderEventsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * URL-encoded folder path (omit for workspace root)
         */
        path?: string;
        /**
         * Include append events for files in folder
         */
        includeAppends?: boolean;
        /**
         * Include events from nested subfolders
         */
        recursive?: boolean;
    };
    url: '/r/{key}/ops/folders/subscribe';
};

export type SubscribeFolderEventsErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type SubscribeFolderEventsError = SubscribeFolderEventsErrors[keyof SubscribeFolderEventsErrors];

export type SubscribeFolderEventsResponses = {
    /**
     * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
     */
    200: {
        [key: string]: unknown;
    };
};

export type SubscribeFolderEventsResponse = SubscribeFolderEventsResponses[keyof SubscribeFolderEventsResponses];

export type SubscribeFolderEventsViaAppendKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * URL-encoded folder path (omit for workspace root)
         */
        path?: string;
        /**
         * Include append events for files in folder
         */
        includeAppends?: boolean;
        /**
         * Include events from nested subfolders
         */
        recursive?: boolean;
    };
    url: '/a/{key}/ops/folders/subscribe';
};

export type SubscribeFolderEventsViaAppendKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type SubscribeFolderEventsViaAppendKeyError = SubscribeFolderEventsViaAppendKeyErrors[keyof SubscribeFolderEventsViaAppendKeyErrors];

export type SubscribeFolderEventsViaAppendKeyResponses = {
    /**
     * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
     */
    200: {
        [key: string]: unknown;
    };
};

export type SubscribeFolderEventsViaAppendKeyResponse = SubscribeFolderEventsViaAppendKeyResponses[keyof SubscribeFolderEventsViaAppendKeyResponses];

export type SubscribeFolderEventsViaWriteKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * URL-encoded folder path (omit for workspace root)
         */
        path?: string;
        /**
         * Include append events for files in folder
         */
        includeAppends?: boolean;
        /**
         * Include events from nested subfolders
         */
        recursive?: boolean;
    };
    url: '/w/{key}/ops/folders/subscribe';
};

export type SubscribeFolderEventsViaWriteKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type SubscribeFolderEventsViaWriteKeyError = SubscribeFolderEventsViaWriteKeyErrors[keyof SubscribeFolderEventsViaWriteKeyErrors];

export type SubscribeFolderEventsViaWriteKeyResponses = {
    /**
     * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
     */
    200: {
        [key: string]: unknown;
    };
};

export type SubscribeFolderEventsViaWriteKeyResponse = SubscribeFolderEventsViaWriteKeyResponses[keyof SubscribeFolderEventsViaWriteKeyResponses];

export type ListFolderWebhooksData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}/webhooks';
};

export type ListFolderWebhooksErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ListFolderWebhooksError = ListFolderWebhooksErrors[keyof ListFolderWebhooksErrors];

export type ListFolderWebhooksResponses = {
    /**
     * Webhooks retrieved successfully
     */
    200: WebhookListResponse;
};

export type ListFolderWebhooksResponse = ListFolderWebhooksResponses[keyof ListFolderWebhooksResponses];

export type CreateFolderWebhookData = {
    body: WebhookCreateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}/webhooks';
};

export type CreateFolderWebhookErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Webhook limit exceeded
     */
    429: Error;
};

export type CreateFolderWebhookError = CreateFolderWebhookErrors[keyof CreateFolderWebhookErrors];

export type CreateFolderWebhookResponses = {
    /**
     * Webhook created successfully
     */
    201: WebhookCreateResponse;
};

export type CreateFolderWebhookResponse = CreateFolderWebhookResponses[keyof CreateFolderWebhookResponses];

export type DeleteFolderWebhookData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
        /**
         * Webhook ID to delete
         */
        webhookId: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}/webhooks/{webhookId}';
};

export type DeleteFolderWebhookErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type DeleteFolderWebhookError = DeleteFolderWebhookErrors[keyof DeleteFolderWebhookErrors];

export type DeleteFolderWebhookResponses = {
    /**
     * Webhook deleted successfully
     */
    200: WebhookDeleteResponse;
};

export type DeleteFolderWebhookResponse = DeleteFolderWebhookResponses[keyof DeleteFolderWebhookResponses];

export type UpdateFolderWebhookData = {
    body: WebhookUpdateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
        /**
         * Webhook ID to update
         */
        webhookId: string;
    };
    query?: never;
    url: '/w/{key}/folders/{path}/webhooks/{webhookId}';
};

export type UpdateFolderWebhookErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type UpdateFolderWebhookError = UpdateFolderWebhookErrors[keyof UpdateFolderWebhookErrors];

export type UpdateFolderWebhookResponses = {
    /**
     * Webhook updated successfully
     */
    200: WebhookUpdateResponse;
};

export type UpdateFolderWebhookResponse = UpdateFolderWebhookResponses[keyof UpdateFolderWebhookResponses];

export type ListFolderClaimsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: {
        /**
         * Filter by author identifier
         */
        author?: string;
    };
    url: '/a/{key}/folders/{path}/claims';
};

export type ListFolderClaimsErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ListFolderClaimsError = ListFolderClaimsErrors[keyof ListFolderClaimsErrors];

export type ListFolderClaimsResponses = {
    /**
     * Claims retrieved successfully
     */
    200: FolderClaimsResponse;
};

export type ListFolderClaimsResponse = ListFolderClaimsResponses[keyof ListFolderClaimsResponses];

export type ListScopedKeysData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Include revoked keys in the response
         */
        includeRevoked?: boolean;
    };
    url: '/w/{key}/keys';
};

export type ListScopedKeysErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ListScopedKeysError = ListScopedKeysErrors[keyof ListScopedKeysErrors];

export type ListScopedKeysResponses = {
    /**
     * Scoped keys retrieved successfully
     */
    200: ScopedKeyListResponse;
};

export type ListScopedKeysResponse = ListScopedKeysResponses[keyof ListScopedKeysResponses];

export type CreateScopedKeyData = {
    body: ScopedKeyCreateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/keys';
};

export type CreateScopedKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type CreateScopedKeyError = CreateScopedKeyErrors[keyof CreateScopedKeyErrors];

export type CreateScopedKeyResponses = {
    /**
     * Scoped key created successfully
     */
    201: ScopedKeyCreateResponse;
};

export type CreateScopedKeyResponse = CreateScopedKeyResponses[keyof CreateScopedKeyResponses];

export type RevokeScopedKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * Scoped key identifier
         */
        keyId: string;
    };
    query?: never;
    url: '/w/{key}/keys/{keyId}';
};

export type RevokeScopedKeyErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type RevokeScopedKeyError = RevokeScopedKeyErrors[keyof RevokeScopedKeyErrors];

export type RevokeScopedKeyResponses = {
    /**
     * Scoped key revoked successfully
     */
    200: KeyRevokeResponse;
};

export type RevokeScopedKeyResponse = RevokeScopedKeyResponses[keyof RevokeScopedKeyResponses];

export type CheckCapabilitiesData = {
    body: CapabilitiesCheckRequest;
    path?: never;
    query?: never;
    url: '/capabilities/check';
};

export type CheckCapabilitiesErrors = {
    /**
     * Invalid request
     */
    400: Error;
};

export type CheckCapabilitiesError = CheckCapabilitiesErrors[keyof CheckCapabilitiesErrors];

export type CheckCapabilitiesResponses = {
    /**
     * Capabilities checked
     */
    200: CapabilitiesCheckResponse;
};

export type CheckCapabilitiesResponse = CheckCapabilitiesResponses[keyof CheckCapabilitiesResponses];

export type SignInWithGitHubData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/signin/github';
};

export type SignInWithGitHubErrors = {
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type SignInWithGitHubError = SignInWithGitHubErrors[keyof SignInWithGitHubErrors];

export type SignInWithGitHubResponses = {
    /**
     * This endpoint redirects to OAuth provider. 200 is for OpenAPI compliance only.
     */
    200: {
        [key: string]: unknown;
    };
};

export type SignInWithGitHubResponse = SignInWithGitHubResponses[keyof SignInWithGitHubResponses];

export type SignInWithGoogleData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/signin/google';
};

export type SignInWithGoogleErrors = {
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type SignInWithGoogleError = SignInWithGoogleErrors[keyof SignInWithGoogleErrors];

export type SignInWithGoogleResponses = {
    /**
     * This endpoint redirects to OAuth provider. 200 is for OpenAPI compliance only.
     */
    200: {
        [key: string]: unknown;
    };
};

export type SignInWithGoogleResponse = SignInWithGoogleResponses[keyof SignInWithGoogleResponses];

export type GetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/me';
};

export type GetCurrentUserErrors = {
    /**
     * Authentication required
     */
    401: Error;
};

export type GetCurrentUserError = GetCurrentUserErrors[keyof GetCurrentUserErrors];

export type GetCurrentUserResponses = {
    /**
     * User information retrieved
     */
    200: MeResponse;
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type LogoutData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/logout';
};

export type LogoutErrors = {
    /**
     * Authentication required
     */
    401: Error;
};

export type LogoutError = LogoutErrors[keyof LogoutErrors];

export type LogoutResponses = {
    /**
     * Logged out successfully
     */
    200: LogoutResponse;
};

export type LogoutResponse2 = LogoutResponses[keyof LogoutResponses];

export type ClaimWorkspaceData = {
    /**
     * Empty body - OAuth session provides identity
     */
    body?: {
        [key: string]: unknown;
    };
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/claim';
};

export type ClaimWorkspaceErrors = {
    /**
     * Workspace already claimed
     */
    400: Error;
    /**
     * OAuth session required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ClaimWorkspaceError = ClaimWorkspaceErrors[keyof ClaimWorkspaceErrors];

export type ClaimWorkspaceResponses = {
    /**
     * Workspace claimed successfully
     */
    200: ClaimWorkspaceResponse;
};

export type ClaimWorkspaceResponse2 = ClaimWorkspaceResponses[keyof ClaimWorkspaceResponses];

export type RenameWorkspaceViaWriteKeyData = {
    body: WorkspaceRenameRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/workspace';
};

export type RenameWorkspaceViaWriteKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Key is not allowed to rename workspace
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type RenameWorkspaceViaWriteKeyError = RenameWorkspaceViaWriteKeyErrors[keyof RenameWorkspaceViaWriteKeyErrors];

export type RenameWorkspaceViaWriteKeyResponses = {
    /**
     * Workspace renamed successfully
     */
    200: WorkspaceRenameResponse;
};

export type RenameWorkspaceViaWriteKeyResponse = RenameWorkspaceViaWriteKeyResponses[keyof RenameWorkspaceViaWriteKeyResponses];

export type DeleteWorkspaceData = {
    body?: never;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}';
};

export type DeleteWorkspaceErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type DeleteWorkspaceError = DeleteWorkspaceErrors[keyof DeleteWorkspaceErrors];

export type DeleteWorkspaceResponses = {
    /**
     * Workspace deleted successfully
     */
    200: SuccessResponse;
};

export type DeleteWorkspaceResponse = DeleteWorkspaceResponses[keyof DeleteWorkspaceResponses];

export type RenameWorkspaceData = {
    body: WorkspaceRenameRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/name';
};

export type RenameWorkspaceErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type RenameWorkspaceError = RenameWorkspaceErrors[keyof RenameWorkspaceErrors];

export type RenameWorkspaceResponses = {
    /**
     * Workspace renamed successfully
     */
    200: WorkspaceRenameResponse;
};

export type RenameWorkspaceResponse = RenameWorkspaceResponses[keyof RenameWorkspaceResponses];

export type RotateAllUrlsData = {
    body?: never;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/rotate-all';
};

export type RotateAllUrlsErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type RotateAllUrlsError = RotateAllUrlsErrors[keyof RotateAllUrlsErrors];

export type RotateAllUrlsResponses = {
    /**
     * All URLs rotated successfully
     */
    200: RotateAllResponse;
};

export type RotateAllUrlsResponse = RotateAllUrlsResponses[keyof RotateAllUrlsResponses];

export type ListApiKeysData = {
    body?: never;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/api-keys';
};

export type ListApiKeysErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type ListApiKeysError = ListApiKeysErrors[keyof ListApiKeysErrors];

export type ListApiKeysResponses = {
    /**
     * API keys retrieved successfully
     */
    200: ApiKeyListResponse;
};

export type ListApiKeysResponse = ListApiKeysResponses[keyof ListApiKeysResponses];

export type CreateApiKeyData = {
    body: ApiKeyCreateRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/api-keys';
};

export type CreateApiKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Internal server error
     */
    500: Error;
};

export type CreateApiKeyError = CreateApiKeyErrors[keyof CreateApiKeyErrors];

export type CreateApiKeyResponses = {
    /**
     * API key created successfully
     */
    201: ApiKeyCreateResponse;
};

export type CreateApiKeyResponse = CreateApiKeyResponses[keyof CreateApiKeyResponses];

export type RevokeApiKeyData = {
    body?: never;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * Scoped key identifier
         */
        keyId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/api-keys/{keyId}';
};

export type RevokeApiKeyErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type RevokeApiKeyError = RevokeApiKeyErrors[keyof RevokeApiKeyErrors];

export type RevokeApiKeyResponses = {
    /**
     * API key revoked successfully
     */
    200: ApiKeyRevokeResponse;
};

export type RevokeApiKeyResponse = RevokeApiKeyResponses[keyof RevokeApiKeyResponses];

export type ListWebhooksData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/webhooks';
};

export type ListWebhooksErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ListWebhooksError = ListWebhooksErrors[keyof ListWebhooksErrors];

export type ListWebhooksResponses = {
    /**
     * Webhooks retrieved successfully
     */
    200: WebhookListResponse;
};

export type ListWebhooksResponse = ListWebhooksResponses[keyof ListWebhooksResponses];

export type CreateWebhookData = {
    body: WebhookCreateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/webhooks';
};

export type CreateWebhookErrors = {
    /**
     * Invalid request. Possible error codes:
     * - `INVALID_WEBHOOK_URL`: URL must use HTTPS and resolve to public IP
     * - `INVALID_REQUEST`: Malformed request body
     *
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Webhook limit exceeded
     */
    402: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type CreateWebhookError = CreateWebhookErrors[keyof CreateWebhookErrors];

export type CreateWebhookResponses = {
    /**
     * Webhook created successfully
     */
    201: WebhookCreateResponse;
};

export type CreateWebhookResponse = CreateWebhookResponses[keyof CreateWebhookResponses];

export type DeleteWebhookData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * Webhook identifier
         */
        webhookId: string;
    };
    query?: never;
    url: '/w/{key}/webhooks/{webhookId}';
};

export type DeleteWebhookErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type DeleteWebhookError = DeleteWebhookErrors[keyof DeleteWebhookErrors];

export type DeleteWebhookResponses = {
    /**
     * Webhook deleted successfully
     */
    200: WebhookDeleteResponse;
};

export type DeleteWebhookResponse = DeleteWebhookResponses[keyof DeleteWebhookResponses];

export type UpdateWebhookData = {
    body: WebhookUpdateRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * Webhook identifier
         */
        webhookId: string;
    };
    query?: never;
    url: '/w/{key}/webhooks/{webhookId}';
};

export type UpdateWebhookErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type UpdateWebhookError = UpdateWebhookErrors[keyof UpdateWebhookErrors];

export type UpdateWebhookResponses = {
    /**
     * Webhook updated successfully
     */
    200: WebhookUpdateResponse;
};

export type UpdateWebhookResponse = UpdateWebhookResponses[keyof UpdateWebhookResponses];

export type GetWebhookLogsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * Webhook identifier
         */
        webhookId: string;
    };
    query?: {
        /**
         * Maximum number of log entries to return
         */
        limit?: number;
        /**
         * Return logs after this timestamp (ISO 8601)
         */
        since?: string;
    };
    url: '/w/{key}/webhooks/{webhookId}/logs';
};

export type GetWebhookLogsErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetWebhookLogsError = GetWebhookLogsErrors[keyof GetWebhookLogsErrors];

export type GetWebhookLogsResponses = {
    /**
     * Webhook logs retrieved successfully
     */
    200: WebhookLogsResponse;
};

export type GetWebhookLogsResponse = GetWebhookLogsResponses[keyof GetWebhookLogsResponses];

export type TestWebhookData = {
    body?: WebhookTestRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
        /**
         * Webhook identifier
         */
        webhookId: string;
    };
    query?: never;
    url: '/w/{key}/webhooks/{webhookId}/test';
};

export type TestWebhookErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type TestWebhookError = TestWebhookErrors[keyof TestWebhookErrors];

export type TestWebhookResponses = {
    /**
     * Test webhook delivered (or attempted)
     */
    200: WebhookTestResponse;
};

export type TestWebhookResponse = TestWebhookResponses[keyof TestWebhookResponses];

export type ListWorkspaceWebhooksData = {
    body?: never;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/webhooks';
};

export type ListWorkspaceWebhooksErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type ListWorkspaceWebhooksError = ListWorkspaceWebhooksErrors[keyof ListWorkspaceWebhooksErrors];

export type ListWorkspaceWebhooksResponses = {
    /**
     * Webhooks retrieved successfully
     */
    200: WebhookListResponse;
};

export type ListWorkspaceWebhooksResponse = ListWorkspaceWebhooksResponses[keyof ListWorkspaceWebhooksResponses];

export type CreateWorkspaceWebhookData = {
    body: WebhookCreateRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/webhooks';
};

export type CreateWorkspaceWebhookErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type CreateWorkspaceWebhookError = CreateWorkspaceWebhookErrors[keyof CreateWorkspaceWebhookErrors];

export type CreateWorkspaceWebhookResponses = {
    /**
     * Webhook created successfully
     */
    201: WebhookCreateResponse;
};

export type CreateWorkspaceWebhookResponse = CreateWorkspaceWebhookResponses[keyof CreateWorkspaceWebhookResponses];

export type DeleteWorkspaceWebhookData = {
    body?: never;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * Webhook identifier
         */
        webhookId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/webhooks/{webhookId}';
};

export type DeleteWorkspaceWebhookErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type DeleteWorkspaceWebhookError = DeleteWorkspaceWebhookErrors[keyof DeleteWorkspaceWebhookErrors];

export type DeleteWorkspaceWebhookResponses = {
    /**
     * Webhook deleted successfully
     */
    200: WebhookDeleteResponse;
};

export type DeleteWorkspaceWebhookResponse = DeleteWorkspaceWebhookResponses[keyof DeleteWorkspaceWebhookResponses];

export type UpdateWorkspaceWebhookData = {
    body: WebhookUpdateRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * Webhook identifier
         */
        webhookId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/webhooks/{webhookId}';
};

export type UpdateWorkspaceWebhookErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type UpdateWorkspaceWebhookError = UpdateWorkspaceWebhookErrors[keyof UpdateWorkspaceWebhookErrors];

export type UpdateWorkspaceWebhookResponses = {
    /**
     * Webhook updated successfully
     */
    200: WebhookUpdateResponse;
};

export type UpdateWorkspaceWebhookResponse = UpdateWorkspaceWebhookResponses[keyof UpdateWorkspaceWebhookResponses];

export type TestWorkspaceWebhookData = {
    body?: WebhookTestRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * Webhook identifier
         */
        webhookId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/webhooks/{webhookId}/test';
};

export type TestWorkspaceWebhookErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type TestWorkspaceWebhookError = TestWorkspaceWebhookErrors[keyof TestWorkspaceWebhookErrors];

export type TestWorkspaceWebhookResponses = {
    /**
     * Test delivery attempted
     */
    200: WebhookTestResponse;
};

export type TestWorkspaceWebhookResponse = TestWorkspaceWebhookResponses[keyof TestWorkspaceWebhookResponses];

export type SearchInFileViaReadKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Full-text search query
         */
        q?: string;
        /**
         * Filter by append type
         */
        type?: 'task' | 'claim' | 'response' | 'blocked' | 'answer' | 'renew' | 'cancel' | 'comment' | 'vote';
        /**
         * Filter by task status
         */
        status?: 'pending' | 'claimed' | 'completed' | 'cancelled';
        /**
         * Filter by author name
         */
        author?: string;
        /**
         * Filter by labels (comma-separated, OR matching)
         */
        labels?: string;
        /**
         * Filter by priority levels (comma-separated)
         */
        priority?: string;
        /**
         * Return results after this timestamp (ISO 8601)
         */
        since?: string;
        /**
         * Maximum number of results to return
         */
        limit?: number;
        /**
         * Pagination cursor from previous response
         */
        cursor?: string;
    };
    url: '/r/{key}/search';
};

export type SearchInFileViaReadKeyErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type SearchInFileViaReadKeyError = SearchInFileViaReadKeyErrors[keyof SearchInFileViaReadKeyErrors];

export type SearchInFileViaReadKeyResponses = {
    /**
     * Search results retrieved successfully
     */
    200: SearchResponse;
};

export type SearchInFileViaReadKeyResponse = SearchInFileViaReadKeyResponses[keyof SearchInFileViaReadKeyResponses];

export type SearchWorkspaceData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Full-text search query
         */
        q?: string;
        /**
         * Filter by append type
         */
        type?: 'task' | 'claim' | 'response' | 'blocked' | 'answer' | 'renew' | 'cancel' | 'comment' | 'vote';
        /**
         * Limit search to a specific folder path
         */
        folder?: string;
        /**
         * Filter by task status
         */
        status?: 'pending' | 'claimed' | 'completed' | 'cancelled';
        /**
         * Filter by author name
         */
        author?: string;
        /**
         * Filter by labels (comma-separated, OR matching)
         */
        labels?: string;
        /**
         * Filter by priority levels (comma-separated)
         */
        priority?: string;
        /**
         * Return results after this timestamp (ISO 8601)
         */
        since?: string;
        /**
         * Maximum number of results to return
         */
        limit?: number;
        /**
         * Pagination cursor from previous response
         */
        cursor?: string;
    };
    url: '/api/v1/search';
};

export type SearchWorkspaceErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type SearchWorkspaceError = SearchWorkspaceErrors[keyof SearchWorkspaceErrors];

export type SearchWorkspaceResponses = {
    /**
     * Search results retrieved successfully
     */
    200: SearchResponse;
};

export type SearchWorkspaceResponse = SearchWorkspaceResponses[keyof SearchWorkspaceResponses];

export type SubscribeReadKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/r/{key}/ops/subscribe';
};

export type SubscribeReadKeyErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type SubscribeReadKeyError = SubscribeReadKeyErrors[keyof SubscribeReadKeyErrors];

export type SubscribeReadKeyResponses = {
    /**
     * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
     */
    200: {
        [key: string]: unknown;
    };
};

export type SubscribeReadKeyResponse = SubscribeReadKeyResponses[keyof SubscribeReadKeyResponses];

export type SubscribeAppendKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/a/{key}/ops/subscribe';
};

export type SubscribeAppendKeyErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type SubscribeAppendKeyError = SubscribeAppendKeyErrors[keyof SubscribeAppendKeyErrors];

export type SubscribeAppendKeyResponses = {
    /**
     * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
     */
    200: {
        [key: string]: unknown;
    };
};

export type SubscribeAppendKeyResponse = SubscribeAppendKeyResponses[keyof SubscribeAppendKeyResponses];

export type SubscribeWriteKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/ops/subscribe';
};

export type SubscribeWriteKeyErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type SubscribeWriteKeyError = SubscribeWriteKeyErrors[keyof SubscribeWriteKeyErrors];

export type SubscribeWriteKeyResponses = {
    /**
     * This endpoint upgrades to WebSocket. 200 is for OpenAPI compliance only.
     */
    200: {
        [key: string]: unknown;
    };
};

export type SubscribeWriteKeyResponse = SubscribeWriteKeyResponses[keyof SubscribeWriteKeyResponses];

export type RecordHeartbeatData = {
    body: HeartbeatRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/a/{key}/heartbeat';
};

export type RecordHeartbeatErrors = {
    /**
     * Invalid request. Possible error codes:
     * - `INVALID_AUTHOR`: Author field fails validation
     * - `AUTHOR_MISMATCH`: Heartbeat author doesn't match scoped key's boundAuthor
     *
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type RecordHeartbeatError = RecordHeartbeatErrors[keyof RecordHeartbeatErrors];

export type RecordHeartbeatResponses = {
    /**
     * Heartbeat recorded successfully
     */
    201: HeartbeatResponse;
};

export type RecordHeartbeatResponse = RecordHeartbeatResponses[keyof RecordHeartbeatResponses];

export type GetStatsViaWriteKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/ops/stats';
};

export type GetStatsViaWriteKeyErrors = {
    /**
     * Invalid or insufficient permissions
     */
    403: StatsErrorResponse;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetStatsViaWriteKeyError = GetStatsViaWriteKeyErrors[keyof GetStatsViaWriteKeyErrors];

export type GetStatsViaWriteKeyResponses = {
    /**
     * Statistics retrieved
     */
    200: StatsViaWriteKeyResponse;
};

export type GetStatsViaWriteKeyResponse = GetStatsViaWriteKeyResponses[keyof GetStatsViaWriteKeyResponses];

export type GetFileStatsViaReadKeyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/r/{key}/ops/file/stats';
};

export type GetFileStatsViaReadKeyErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetFileStatsViaReadKeyError = GetFileStatsViaReadKeyErrors[keyof GetFileStatsViaReadKeyErrors];

export type GetFileStatsViaReadKeyResponses = {
    /**
     * File statistics retrieved successfully
     */
    200: FileStatsResponse;
};

export type GetFileStatsViaReadKeyResponse = GetFileStatsViaReadKeyResponses[keyof GetFileStatsViaReadKeyResponses];

export type GetFileStatsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/a/{key}/ops/file/stats';
};

export type GetFileStatsErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetFileStatsError = GetFileStatsErrors[keyof GetFileStatsErrors];

export type GetFileStatsResponses = {
    /**
     * File statistics retrieved successfully
     */
    200: FileStatsResponse;
};

export type GetFileStatsResponse = GetFileStatsResponses[keyof GetFileStatsResponses];

export type GetWorkspaceStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/stats';
};

export type GetWorkspaceStatsErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetWorkspaceStatsError = GetWorkspaceStatsErrors[keyof GetWorkspaceStatsErrors];

export type GetWorkspaceStatsResponses = {
    /**
     * Workspace statistics retrieved successfully
     */
    200: WorkspaceStatsResponse;
};

export type GetWorkspaceStatsResponse = GetWorkspaceStatsResponses[keyof GetWorkspaceStatsResponses];

export type PollJobStatusData = {
    body?: never;
    path: {
        /**
         * Job capability key (same format as file keys)
         */
        key: string;
    };
    query?: never;
    url: '/j/{key}';
};

export type PollJobStatusErrors = {
    /**
     * Job not found or expired
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type PollJobStatusError = PollJobStatusErrors[keyof PollJobStatusErrors];

export type PollJobStatusResponses = {
    /**
     * Job status retrieved successfully
     */
    200: JobResponse;
};

export type PollJobStatusResponse = PollJobStatusResponses[keyof PollJobStatusResponses];

export type ExportWorkspaceData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Archive format
         */
        format?: 'zip' | 'tar.gz';
        /**
         * Include append history in metadata
         */
        includeAppends?: boolean;
        /**
         * Include soft-deleted files
         */
        includeDeleted?: boolean;
        /**
         * Comma-separated folder paths to export (exports all if omitted)
         */
        paths?: string;
    };
    url: '/api/v1/export';
};

export type ExportWorkspaceErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Workspace too large for synchronous export
     */
    413: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ExportWorkspaceError = ExportWorkspaceErrors[keyof ExportWorkspaceErrors];

export type ExportWorkspaceResponses = {
    /**
     * Binary file download
     */
    200: Blob | File;
};

export type ExportWorkspaceResponse = ExportWorkspaceResponses[keyof ExportWorkspaceResponses];

export type CreateExportJobData = {
    body: {
        format?: 'zip' | 'tar.gz';
        /**
         * Include append history in metadata
         */
        includeAppends?: boolean;
        /**
         * Include soft-deleted files
         */
        includeDeleted?: boolean;
        /**
         * Folder paths to export (exports all if omitted)
         */
        paths?: Array<string>;
        /**
         * Email to notify when export is ready
         */
        notifyEmail?: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/export/jobs';
};

export type CreateExportJobErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Workspace exceeds maximum export size
     */
    413: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type CreateExportJobError = CreateExportJobErrors[keyof CreateExportJobErrors];

export type CreateExportJobResponses = {
    /**
     * Export job created
     */
    202: ExportJobCreateResponse;
};

export type CreateExportJobResponse = CreateExportJobResponses[keyof CreateExportJobResponses];

export type GetExportJobStatusData = {
    body?: never;
    path: {
        /**
         * Background job identifier
         */
        jobId: string;
    };
    query?: never;
    url: '/api/v1/export/jobs/{jobId}';
};

export type GetExportJobStatusErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetExportJobStatusError = GetExportJobStatusErrors[keyof GetExportJobStatusErrors];

export type GetExportJobStatusResponses = {
    /**
     * Export job status
     */
    200: ExportJobStatusResponse;
};

export type GetExportJobStatusResponse = GetExportJobStatusResponses[keyof GetExportJobStatusResponses];

export type DownloadExportJobData = {
    body?: never;
    path: {
        /**
         * Background job identifier
         */
        jobId: string;
    };
    query?: never;
    url: '/api/v1/export/jobs/{jobId}/download';
};

export type DownloadExportJobErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Job not ready for download
     */
    403: Error;
    /**
     * Export job not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type DownloadExportJobError = DownloadExportJobErrors[keyof DownloadExportJobErrors];

export type DownloadExportJobResponses = {
    /**
     * Binary file download
     */
    200: Blob | File;
};

export type DownloadExportJobResponse = DownloadExportJobResponses[keyof DownloadExportJobResponses];

export type ListDeletedFilesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
    };
    url: '/api/v1/deleted';
};

export type ListDeletedFilesErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ListDeletedFilesError = ListDeletedFilesErrors[keyof ListDeletedFilesErrors];

export type ListDeletedFilesResponses = {
    /**
     * List of recoverable deleted files
     */
    200: DeletedFilesListResponse;
};

export type ListDeletedFilesResponse = ListDeletedFilesResponses[keyof ListDeletedFilesResponses];

export type GetAgentLivenessData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Seconds before an agent is considered stale (default 300 = 5 minutes)
         */
        staleThresholdSeconds?: number;
        /**
         * Limit to agents active in a specific folder
         */
        folder?: string;
    };
    url: '/api/v1/agents/liveness';
};

export type GetAgentLivenessErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetAgentLivenessError = GetAgentLivenessErrors[keyof GetAgentLivenessErrors];

export type GetAgentLivenessResponses = {
    /**
     * Agent liveness data retrieved successfully
     */
    200: AgentLivenessResponse;
};

export type GetAgentLivenessResponse = GetAgentLivenessResponses[keyof GetAgentLivenessResponses];

export type GetScopedAgentLivenessData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Seconds before an agent is considered stale (default 300 = 5 minutes)
         */
        staleThresholdSeconds?: number;
    };
    url: '/r/{key}/agents/liveness';
};

export type GetScopedAgentLivenessErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetScopedAgentLivenessError = GetScopedAgentLivenessErrors[keyof GetScopedAgentLivenessErrors];

export type GetScopedAgentLivenessResponses = {
    /**
     * Agent liveness data retrieved successfully
     */
    200: AgentLivenessResponse;
};

export type GetScopedAgentLivenessResponse = GetScopedAgentLivenessResponses[keyof GetScopedAgentLivenessResponses];

export type GetOrchestrationReadOnlyData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Filter by task status (comma-separated; pending, claimed, stalled, completed, cancelled)
         */
        status?: string;
        /**
         * Filter by claiming agent
         */
        agent?: string;
        /**
         * Filter by filename (partial match)
         */
        file?: string;
        /**
         * Filter by folder path
         */
        folder?: string;
        /**
         * Filter by priority (comma-separated; low, medium, high, critical)
         */
        priority?: string;
        /**
         * Return items modified after this timestamp (ISO 8601)
         */
        since?: string;
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
    };
    url: '/r/{key}/orchestration';
};

export type GetOrchestrationReadOnlyErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetOrchestrationReadOnlyError = GetOrchestrationReadOnlyErrors[keyof GetOrchestrationReadOnlyErrors];

export type GetOrchestrationReadOnlyResponses = {
    /**
     * Orchestration data retrieved successfully
     */
    200: OrchestrationReadOnlyResponse;
};

export type GetOrchestrationReadOnlyResponse = GetOrchestrationReadOnlyResponses[keyof GetOrchestrationReadOnlyResponses];

export type GetOrchestrationAdminData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Filter by task status (comma-separated; pending, claimed, stalled, completed, cancelled)
         */
        status?: string;
        /**
         * Filter by claiming agent
         */
        agent?: string;
        /**
         * Filter by filename (partial match)
         */
        file?: string;
        /**
         * Filter by folder path
         */
        folder?: string;
        /**
         * Filter by priority (comma-separated; low, medium, high, critical)
         */
        priority?: string;
        /**
         * Return items modified after this timestamp (ISO 8601)
         */
        since?: string;
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
    };
    url: '/w/{key}/orchestration';
};

export type GetOrchestrationAdminErrors = {
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetOrchestrationAdminError = GetOrchestrationAdminErrors[keyof GetOrchestrationAdminErrors];

export type GetOrchestrationAdminResponses = {
    /**
     * Orchestration data retrieved successfully
     */
    200: OrchestrationAdminResponse;
};

export type GetOrchestrationAdminResponse = GetOrchestrationAdminResponses[keyof GetOrchestrationAdminResponses];

export type GetWorkspaceOrchestrationData = {
    body?: never;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
    };
    query?: {
        /**
         * Filter by task status (comma-separated; pending, claimed, stalled, completed, cancelled)
         */
        status?: string;
        /**
         * Filter by claiming agent
         */
        agent?: string;
        /**
         * Filter by filename (partial match)
         */
        file?: string;
        /**
         * Filter by folder path
         */
        folder?: string;
        /**
         * Filter by priority (comma-separated; low, medium, high, critical)
         */
        priority?: string;
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
    };
    url: '/workspaces/{workspaceId}/orchestration';
};

export type GetWorkspaceOrchestrationErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type GetWorkspaceOrchestrationError = GetWorkspaceOrchestrationErrors[keyof GetWorkspaceOrchestrationErrors];

export type GetWorkspaceOrchestrationResponses = {
    /**
     * Orchestration data retrieved successfully
     */
    200: OrchestrationReadOnlyResponse;
};

export type GetWorkspaceOrchestrationResponse = GetWorkspaceOrchestrationResponses[keyof GetWorkspaceOrchestrationResponses];

export type RenewClaimWorkspaceData = {
    body?: RenewClaimRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * The claim's append ID
         */
        claimId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/orchestration/claims/{claimId}/renew';
};

export type RenewClaimWorkspaceErrors = {
    /**
     * Cannot renew claim
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type RenewClaimWorkspaceError = RenewClaimWorkspaceErrors[keyof RenewClaimWorkspaceErrors];

export type RenewClaimWorkspaceResponses = {
    /**
     * Claim renewed successfully
     */
    200: ClaimMutationResponse;
};

export type RenewClaimWorkspaceResponse = RenewClaimWorkspaceResponses[keyof RenewClaimWorkspaceResponses];

export type CompleteClaimWorkspaceData = {
    body?: CompleteClaimRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * The claim's append ID
         */
        claimId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/orchestration/claims/{claimId}/complete';
};

export type CompleteClaimWorkspaceErrors = {
    /**
     * Cannot complete claim
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type CompleteClaimWorkspaceError = CompleteClaimWorkspaceErrors[keyof CompleteClaimWorkspaceErrors];

export type CompleteClaimWorkspaceResponses = {
    /**
     * Task completed successfully
     */
    200: ClaimMutationResponse;
};

export type CompleteClaimWorkspaceResponse = CompleteClaimWorkspaceResponses[keyof CompleteClaimWorkspaceResponses];

export type CancelClaimWorkspaceData = {
    body?: CancelClaimRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * The claim's append ID
         */
        claimId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/orchestration/claims/{claimId}/cancel';
};

export type CancelClaimWorkspaceErrors = {
    /**
     * Cannot cancel claim
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type CancelClaimWorkspaceError = CancelClaimWorkspaceErrors[keyof CancelClaimWorkspaceErrors];

export type CancelClaimWorkspaceResponses = {
    /**
     * Claim cancelled successfully
     */
    200: ClaimMutationResponse;
};

export type CancelClaimWorkspaceResponse = CancelClaimWorkspaceResponses[keyof CancelClaimWorkspaceResponses];

export type BlockClaimWorkspaceData = {
    body: BlockClaimRequest;
    path: {
        /**
         * Workspace identifier
         */
        workspaceId: string;
        /**
         * The claim's append ID
         */
        claimId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceId}/orchestration/claims/{claimId}/block';
};

export type BlockClaimWorkspaceErrors = {
    /**
     * Cannot block claim (missing reason or not active)
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Resource not found
     */
    404: Error;
};

export type BlockClaimWorkspaceError = BlockClaimWorkspaceErrors[keyof BlockClaimWorkspaceErrors];

export type BlockClaimWorkspaceResponses = {
    /**
     * Claim marked as blocked
     */
    200: ClaimMutationResponse;
};

export type BlockClaimWorkspaceResponse = BlockClaimWorkspaceResponses[keyof BlockClaimWorkspaceResponses];

export type ApiDeleteFileByPathData = {
    body?: never;
    path: {
        /**
         * URL-encoded file path
         */
        path: string;
    };
    query?: {
        /**
         * Hard delete (irreversible)
         */
        permanent?: boolean;
    };
    url: '/api/v1/files/{path}';
};

export type ApiDeleteFileByPathErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiDeleteFileByPathError = ApiDeleteFileByPathErrors[keyof ApiDeleteFileByPathErrors];

export type ApiDeleteFileByPathResponses = {
    /**
     * File deleted successfully
     */
    200: FileDeleteResponse;
};

export type ApiDeleteFileByPathResponse = ApiDeleteFileByPathResponses[keyof ApiDeleteFileByPathResponses];

export type ApiReadFileByPathData = {
    body?: never;
    path: {
        /**
         * URL-encoded file path (e.g., projects/alpha/notes.md)
         */
        path: string;
    };
    query?: {
        /**
         * Response format
         */
        format?: 'raw' | 'parsed' | 'structure';
    };
    url: '/api/v1/files/{path}';
};

export type ApiReadFileByPathErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiReadFileByPathError = ApiReadFileByPathErrors[keyof ApiReadFileByPathErrors];

export type ApiReadFileByPathResponses = {
    /**
     * File content retrieved successfully
     */
    200: FileReadResponse;
};

export type ApiReadFileByPathResponse = ApiReadFileByPathResponses[keyof ApiReadFileByPathResponses];

export type ApiCreateFileByPathData = {
    body: {
        /**
         * Initial file content (markdown)
         */
        content: string;
        /**
         * Optional initial appends to add after file creation
         */
        initialAppends?: Array<AppendRequest>;
    };
    path: {
        /**
         * URL-encoded file path for the new file
         */
        path: string;
    };
    query?: never;
    url: '/api/v1/files/{path}';
};

export type ApiCreateFileByPathErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiCreateFileByPathError = ApiCreateFileByPathErrors[keyof ApiCreateFileByPathErrors];

export type ApiCreateFileByPathResponses = {
    /**
     * File created successfully
     */
    201: FileCreateResponse;
};

export type ApiCreateFileByPathResponse = ApiCreateFileByPathResponses[keyof ApiCreateFileByPathResponses];

export type ApiUpdateFileByPathData = {
    body: FileUpdateRequest;
    headers?: {
        /**
         * ETag from previous read for optimistic concurrency
         */
        'If-Match'?: string;
    };
    path: {
        /**
         * URL-encoded file path
         */
        path: string;
    };
    query?: never;
    url: '/api/v1/files/{path}';
};

export type ApiUpdateFileByPathErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * ETag mismatch - file was modified since last read
     */
    412: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiUpdateFileByPathError = ApiUpdateFileByPathErrors[keyof ApiUpdateFileByPathErrors];

export type ApiUpdateFileByPathResponses = {
    /**
     * File updated successfully
     */
    200: FileUpdateResponse;
};

export type ApiUpdateFileByPathResponse = ApiUpdateFileByPathResponses[keyof ApiUpdateFileByPathResponses];

export type ApiAppendToFileByPathData = {
    body: AppendRequest;
    path: {
        /**
         * URL-encoded file path
         */
        path: string;
    };
    query?: never;
    url: '/api/v1/files/{path}/append';
};

export type ApiAppendToFileByPathErrors = {
    /**
     * Invalid request. Possible error codes:
     * - `INVALID_APPEND_TYPE`: Unknown type value
     * - `INVALID_REF`: ref points to wrong append type or doesn't exist
     * - `INVALID_AUTHOR`: Author field fails validation
     * - `TASK_ALREADY_COMPLETE`: Trying to claim a completed task
     * - `ALREADY_CLAIMED`: Task already has active claim
     *
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Resource deleted (recoverable)
     */
    410: Error;
    /**
     * Rate limited. Possible error codes:
     * - `RATE_LIMITED`: Too many requests
     * - `WIP_LIMIT_EXCEEDED`: Author at max concurrent claims
     *
     */
    429: Error;
};

export type ApiAppendToFileByPathError = ApiAppendToFileByPathErrors[keyof ApiAppendToFileByPathErrors];

export type ApiAppendToFileByPathResponses = {
    /**
     * Append created successfully
     */
    201: AppendResponse;
};

export type ApiAppendToFileByPathResponse = ApiAppendToFileByPathResponses[keyof ApiAppendToFileByPathResponses];

export type ApiListRootFolderData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Include all nested contents recursively
         */
        recursive?: boolean;
        /**
         * Return nested tree structure up to N levels deep (default 1, max 5)
         */
        depth?: number;
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
    };
    url: '/api/v1/folders';
};

export type ApiListRootFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiListRootFolderError = ApiListRootFolderErrors[keyof ApiListRootFolderErrors];

export type ApiListRootFolderResponses = {
    /**
     * Folder contents retrieved successfully
     */
    200: FolderListResponse;
};

export type ApiListRootFolderResponse = ApiListRootFolderResponses[keyof ApiListRootFolderResponses];

export type ApiCreateRootFolderData = {
    body: {
        /**
         * New folder name
         */
        name: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/folders';
};

export type ApiCreateRootFolderErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiCreateRootFolderError = ApiCreateRootFolderErrors[keyof ApiCreateRootFolderErrors];

export type ApiCreateRootFolderResponses = {
    /**
     * Folder created successfully
     */
    201: FolderCreateResponse;
};

export type ApiCreateRootFolderResponse = ApiCreateRootFolderResponses[keyof ApiCreateRootFolderResponses];

export type ApiDeleteFolderByPathData = {
    body?: {
        /**
         * Delete folder and all contents
         */
        cascade?: boolean;
        /**
         * Must match folder path exactly (without leading slash) for cascade delete
         */
        confirmPath?: string;
    };
    path: {
        /**
         * URL-encoded folder path
         */
        path: string;
    };
    query?: never;
    url: '/api/v1/folders/{path}';
};

export type ApiDeleteFolderByPathErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Folder not empty (use cascade delete)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiDeleteFolderByPathError = ApiDeleteFolderByPathErrors[keyof ApiDeleteFolderByPathErrors];

export type ApiDeleteFolderByPathResponses = {
    /**
     * Folder deleted successfully
     */
    200: FolderDeleteResponse;
};

export type ApiDeleteFolderByPathResponse = ApiDeleteFolderByPathResponses[keyof ApiDeleteFolderByPathResponses];

export type ApiListFolderByPathData = {
    body?: never;
    path: {
        /**
         * URL-encoded folder path (use empty string or "/" for root)
         */
        path: string;
    };
    query?: {
        /**
         * Include all nested contents recursively
         */
        recursive?: boolean;
        /**
         * Return nested tree structure up to N levels deep (default 1, max 5)
         */
        depth?: number;
        /**
         * Maximum number of items to return
         */
        limit?: number;
        /**
         * Pagination cursor for fetching next page
         */
        cursor?: string;
    };
    url: '/api/v1/folders/{path}';
};

export type ApiListFolderByPathErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiListFolderByPathError = ApiListFolderByPathErrors[keyof ApiListFolderByPathErrors];

export type ApiListFolderByPathResponses = {
    /**
     * Folder contents retrieved successfully
     */
    200: FolderListResponse;
};

export type ApiListFolderByPathResponse = ApiListFolderByPathResponses[keyof ApiListFolderByPathResponses];

export type ApiCreateFolderByPathData = {
    body: {
        /**
         * New folder name
         */
        name: string;
    };
    path: {
        /**
         * URL-encoded parent folder path
         */
        path: string;
    };
    query?: never;
    url: '/api/v1/folders/{path}';
};

export type ApiCreateFolderByPathErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
    /**
     * Conflict (e.g., concurrent edit, already claimed)
     */
    409: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type ApiCreateFolderByPathError = ApiCreateFolderByPathErrors[keyof ApiCreateFolderByPathErrors];

export type ApiCreateFolderByPathResponses = {
    /**
     * Folder created successfully
     */
    201: FolderCreateResponse;
};

export type ApiCreateFolderByPathResponse = ApiCreateFolderByPathResponses[keyof ApiCreateFolderByPathResponses];

export type HealthCheckData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type HealthCheckErrors = {
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type HealthCheckError = HealthCheckErrors[keyof HealthCheckErrors];

export type HealthCheckResponses = {
    /**
     * Service is healthy
     */
    200: HealthCheckSimpleResponse;
};

export type HealthCheckResponse = HealthCheckResponses[keyof HealthCheckResponses];

export type GetOpenApiSpecData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/openapi.json';
};

export type GetOpenApiSpecErrors = {
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetOpenApiSpecError = GetOpenApiSpecErrors[keyof GetOpenApiSpecErrors];

export type GetOpenApiSpecResponses = {
    /**
     * OpenAPI 3.1 specification document
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetOpenApiSpecResponse = GetOpenApiSpecResponses[keyof GetOpenApiSpecResponses];

export type GetApiDocsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/docs';
};

export type GetApiDocsErrors = {
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetApiDocsError = GetApiDocsErrors[keyof GetApiDocsErrors];

export type GetApiDocsResponses = {
    /**
     * HTML page with interactive API documentation
     */
    200: string;
};

export type GetApiDocsResponse = GetApiDocsResponses[keyof GetApiDocsResponses];

export type GetChangelogData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/changelog';
};

export type GetChangelogErrors = {
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetChangelogError = GetChangelogErrors[keyof GetChangelogErrors];

export type GetChangelogResponses = {
    /**
     * API changelog
     */
    200: ChangelogResponse;
};

export type GetChangelogResponse = GetChangelogResponses[keyof GetChangelogResponses];

export type GetServiceStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/status';
};

export type GetServiceStatusErrors = {
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetServiceStatusError = GetServiceStatusErrors[keyof GetServiceStatusErrors];

export type GetServiceStatusResponses = {
    /**
     * Service status
     */
    200: StatusResponse;
};

export type GetServiceStatusResponse = GetServiceStatusResponses[keyof GetServiceStatusResponses];

export type CheckCapabilitiesInWorkspaceData = {
    body: CapabilitiesCheckRequest;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: never;
    url: '/w/{key}/capabilities/check';
};

export type CheckCapabilitiesInWorkspaceErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type CheckCapabilitiesInWorkspaceError = CheckCapabilitiesInWorkspaceErrors[keyof CheckCapabilitiesInWorkspaceErrors];

export type CheckCapabilitiesInWorkspaceResponses = {
    /**
     * Capability check results with extended information
     */
    200: CapabilitiesCheckInWorkspaceResponse;
};

export type CheckCapabilitiesInWorkspaceResponse = CheckCapabilitiesInWorkspaceResponses[keyof CheckCapabilitiesInWorkspaceResponses];

export type GetAuditLogsData = {
    body?: never;
    path: {
        /**
         * Capability key (20+ chars, base62 with underscore)
         */
        key: string;
    };
    query?: {
        /**
         * Filter by action type
         */
        action?: 'file.create' | 'file.update' | 'file.delete' | 'append' | 'claim' | 'key.create' | 'key.revoke' | 'webhook.create' | 'webhook.update' | 'webhook.delete' | 'workspace.claim';
        /**
         * Filter by resource type
         */
        resourceType?: 'file' | 'folder' | 'key' | 'webhook' | 'workspace';
        /**
         * Filter by actor (key prefix or identifier)
         */
        actor?: string;
        /**
         * Filter logs from this date (ISO 8601 format)
         */
        since?: string;
        /**
         * Filter logs until this date (ISO 8601 format)
         */
        until?: string;
        /**
         * Maximum number of logs to return (default 50, max 100)
         */
        limit?: number;
        /**
         * Cursor for pagination (opaque)
         */
        cursor?: string;
    };
    url: '/w/{key}/audit';
};

export type GetAuditLogsErrors = {
    /**
     * Invalid request
     */
    400: Error;
    /**
     * Resource not found
     */
    404: Error;
    /**
     * Rate limit exceeded
     */
    429: Error;
};

export type GetAuditLogsError = GetAuditLogsErrors[keyof GetAuditLogsErrors];

export type GetAuditLogsResponses = {
    /**
     * Audit logs retrieved successfully
     */
    200: AuditLogsResponse;
};

export type GetAuditLogsResponse = GetAuditLogsResponses[keyof GetAuditLogsResponses];

export type GetAdminMetricsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/admin/metrics';
};

export type GetAdminMetricsErrors = {
    /**
     * Authentication required
     */
    401: Error;
    /**
     * Permission denied
     */
    403: Error;
};

export type GetAdminMetricsError = GetAdminMetricsErrors[keyof GetAdminMetricsErrors];

export type GetAdminMetricsResponses = {
    /**
     * System metrics retrieved successfully
     */
    200: AdminMetricsResponse;
};

export type GetAdminMetricsResponse = GetAdminMetricsResponses[keyof GetAdminMetricsResponses];
