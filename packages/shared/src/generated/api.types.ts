/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/bootstrap": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a new workspace
         * @description Zero-friction entry point. Creates a new workspace with a root folder immediately.
         *
         *     No authentication required. Users can start creating files right away using the
         *     returned capability URLs.
         *
         *     **Rate limit:** 10 workspaces per IP per hour.
         */
        post: operations["createWorkspace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read file content
         * @description Read file content with optional format and filtering options.
         *
         *     Supports multiple response formats via the `format` query parameter:
         *     - `raw`: Plain markdown content (use /r/{key}/raw endpoint for text/markdown response)
         *     - `parsed`: Structured parse with frontmatter, sections, and appends array
         *     - `structure`: File headings and metadata only
         *
         *     Use `since` parameter to get only appends after a sequence number (for WebSocket reconnection catch-up).
         */
        get: operations["readFile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read file content (write key)
         * @description Read file content using a write key. Write keys inherit all read capabilities.
         */
        get: operations["readFileViaWriteKey"];
        /**
         * Update file content
         * @description Replace entire file content. Requires write key.
         *
         *     Use `If-Match` header with ETag for optimistic concurrency control.
         *     If omitted, last-write-wins.
         *
         *     Existing appends are marked stale after content replacement.
         */
        put: operations["updateFile"];
        post?: never;
        /**
         * Delete file
         * @description Delete a file. Soft delete by default (recoverable for 7 days).
         *
         *     Use `?permanent=true` for hard delete (irreversible).
         */
        delete: operations["deleteFile"];
        options?: never;
        head?: never;
        /**
         * Rename file
         * @description Rename a file. Capability URLs remain unchanged.
         */
        patch: operations["renameFile"];
        trace?: never;
    };
    "/r/{key}/raw": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read raw file content
         * @description Returns raw markdown content with `Content-Type: text/markdown`. No JSON envelope.
         */
        get: operations["readFileRaw"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/meta": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read file metadata
         * @description Get file metadata without content. Includes filename, folder, size, timestamps,
         *     append count, task stats, and webhook status.
         */
        get: operations["readFileMeta"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/tail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read last N appends
         * @description Get the last N bytes or lines of file content. Efficient for tailing large files.
         *
         *     **Performance note:** Byte-based tail is O(1) via file seek. Line-based requires
         *     reading from end until N newlines found. For files >1MB, prefer `?bytes=`.
         */
        get: operations["readFileTail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/structure": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read file structure/headings
         * @description Get document structure including headings (level, text, line number),
         *     append count, and whether file has task appends.
         */
        get: operations["readFileStructure"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/section/{heading}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read specific section by heading
         * @description Get content of a specific section identified by its heading text.
         *     Returns the section content along with start and end line numbers.
         */
        get: operations["readFileSection"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/ops/file/append/{appendId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read specific append
         * @description Get a specific append by ID. Returns the full append object including
         *     author, timestamp, type, content, and any references.
         */
        get: operations["readAppend"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/recover": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Recover deleted file
         * @description Recover a soft-deleted file within the 7-day recovery window.
         *
         *     Use `?rotateUrls=true` to generate new capability URLs (invalidates old ones).
         *     Useful when recovering after a URL leak.
         */
        post: operations["recoverFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/move": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Move file to new folder
         * @description Move a file to a different folder. Capability URLs remain unchanged.
         */
        post: operations["moveFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/rotate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Rotate capability URLs
         * @description Generate new capability URLs for the file. Old URLs become invalid immediately.
         *
         *     Use this to revoke access for anyone who has the current URLs.
         */
        post: operations["rotateCapabilityUrls"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get file settings
         * @description Get file-specific settings including claim duration, max append size,
         *     allowed append types, WIP limit, and labels.
         */
        get: operations["getFileSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update file settings
         * @description Partially update file settings. Only provided fields are updated.
         */
        patch: operations["updateFileSettings"];
        trace?: never;
    };
    "/a/{key}/append": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create append
         * @description Append content to a file. Supports two modes:
         *
         *     **Single append:** Provide `type`, `content`, and optional fields directly.
         *
         *     **Atomic multi-append:** Provide `appends` array for operations that must succeed
         *     or fail together (e.g., complete task + create follow-up). If any append fails
         *     validation, all are rejected.
         *
         *     The `appends` array and single-append fields are mutually exclusive.
         *
         *     Key scope behavior:
         *     - **File-scoped key:** file path is derived from the key scope; `path` in body is optional.
         *     - **Workspace/folder-scoped key:** `path` in body is required.
         */
        post: operations["createAppend"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create scoped append
         * @description Append content to a file at a specific path using a scoped capability key.
         *
         *     This endpoint is used with scoped keys that have restrictions like:
         *     - `scopePath`: Key can only access files within a specific path prefix
         *     - `boundAuthor`: Key can only create appends with a specific author
         *     - `allowedTypes`: Key can only create appends of specific types
         *
         *     The file path is specified in the URL, and the append is created with the
         *     provided author, type, and content.
         */
        post: operations["createScopedAppend"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/folders/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List folder contents
         * @description List contents of a folder including files and subfolders.
         *
         *     Supports pagination and sorting.
         *
         *     **Permission inheritance:** Returned file URLs respect the folder's permission level:
         *     - Folder read key → returns file read URLs only
         *     - Folder append key → returns file append URLs
         *     - Folder write key → returns file write URLs
         *
         *     **Export mode:** Use `?action=export` to download folder contents as an archive.
         *     Same query params as workspace export, but scoped to this folder.
         */
        get: operations["listFolderContents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/folders/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List folder contents (append key)
         * @description List folder contents using an append key. Append keys inherit all read capabilities.
         *     Returns file append URLs in response.
         */
        get: operations["listFolderContentsViaAppendKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/folders/{path}/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create file in folder
         * @description Create a new file in the specified folder. Uses folder append key.
         *
         *     Creating files is a safe additive operation. The creator receives all 3 file URLs
         *     regardless of which folder key they used.
         *
         *     **Atomic creation:** If two clients attempt to create a file with the same name
         *     simultaneously, exactly one succeeds (409 FILE_ALREADY_EXISTS for the other).
         *
         *     Use `Idempotency-Key` header to safely retry file creation.
         */
        post: operations["createFileInFolder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/folders/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List folder contents (write key)
         * @description List folder contents using a write key. Write keys inherit all read capabilities.
         *     Returns file write URLs in response.
         */
        get: operations["listFolderContentsViaWriteKey"];
        put?: never;
        post?: never;
        /**
         * Delete folder
         * @description Delete a folder. Empty folders are deleted directly.
         *
         *     For non-empty folders, use cascade delete with confirmation:
         *     - Set `cascade: true` in request body
         *     - Set `confirmPath` to match the folder path exactly (without leading slash)
         *
         *     Cascade delete is **soft delete only** — all files remain recoverable for 7 days.
         */
        delete: operations["deleteFolder"];
        options?: never;
        head?: never;
        /**
         * Rename folder
         * @description Rename a folder. Capability URLs remain unchanged.
         */
        patch: operations["renameFolder"];
        trace?: never;
    };
    "/w/{key}/folders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create new folder
         * @description Create a new folder within the workspace or parent folder.
         *
         *     Returns capability URLs for the new folder.
         */
        post: operations["createFolder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/folders/{path}/copy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Copy file to folder
         * @description Copy a file from another location into this folder.
         *
         *     Requires a source file key (read access to source file).
         *     Optionally specify a new filename.
         */
        post: operations["copyFileToFolder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/folders/{path}/bulk": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Bulk create files in folder
         * @description Create multiple files in a folder in a single request.
         *
         *     **Async mode:** Use `?async=true` to return immediately with a job ID.
         *     Poll the job status endpoint to check completion.
         *
         *     **Limits:** Maximum 100 files per request.
         */
        post: operations["bulkCreateFiles"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/folders/{path}/move": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Move folder to new location
         * @description Move a folder to a new destination path.
         *
         *     Capability URLs remain unchanged after move.
         */
        post: operations["moveFolder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/folders/{path}/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get folder settings
         * @description Get settings for a folder including WIP limits, claim duration,
         *     and other coordination settings.
         *
         *     Settings are inherited by files in the folder unless overridden.
         */
        get: operations["getFolderSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update folder settings
         * @description Update settings for a folder. Only provided fields are updated.
         *
         *     **Inheritance:** Files inherit folder settings. File-level settings
         *     override folder settings.
         */
        patch: operations["updateFolderSettings"];
        trace?: never;
    };
    "/r/{key}/ops/folders/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get folder statistics
         * @description Get aggregate statistics for a folder including file count, folder count,
         *     total size, last modified timestamp, and task statistics.
         */
        get: operations["getFolderStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/ops/folders/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search within folder
         * @description Full-text search within a folder and its contents.
         *
         *     Supports filtering by labels, priority, status, and author.
         *
         *     **Performance note:** If search hits timeout, returns partial results with
         *     `truncated: true`. Increase `limit` or add filters to reduce search scope.
         */
        get: operations["searchInFolder"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/ops/folders/tasks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Query tasks across folder
         * @description Aggregate tasks across all files in a folder. Returns tasks with their
         *     file context and current status.
         *
         *     Useful for account controls views and orchestration views.
         */
        get: operations["queryFolderTasks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/ops/folders/subscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Subscribe to folder events (WebSocket)
         * @description WebSocket endpoint for real-time folder events.
         *
         *     **Connection:** Upgrade to WebSocket protocol.
         *
         *     **Events received:**
         *     - `file_created` - New file created in folder
         *     - `file_deleted` - File deleted from folder
         *     - `file_moved` - File moved into/out of folder
         *     - `folder_created` - Subfolder created
         *     - `folder_deleted` - Subfolder deleted
         *     - `append` - New append on any file in folder (if subscribed)
         *
         *     **Query parameters:**
         *     - `includeAppends=true` - Also receive append events for files
         *     - `recursive=true` - Include events from nested subfolders
         *
         *     **Heartbeat:** Server sends ping every 30s. Client must respond with pong
         *     within 10s or connection is closed.
         */
        get: operations["subscribeFolderEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/ops/folders/subscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Subscribe to folder events with append key (WebSocket)
         * @description WebSocket endpoint for real-time folder events using an append key.
         */
        get: operations["subscribeFolderEventsViaAppendKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/ops/folders/subscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Subscribe to folder events with write key (WebSocket)
         * @description WebSocket endpoint for real-time folder events using a write key.
         */
        get: operations["subscribeFolderEventsViaWriteKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/folders/{path}/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List folder webhooks
         * @description List all webhooks registered for a folder.
         */
        get: operations["listFolderWebhooks"];
        put?: never;
        /**
         * Create folder webhook
         * @description Register a webhook for folder events.
         *
         *     **Events:**
         *     - `file_created` - New file created in folder
         *     - `file_deleted` - File deleted from folder
         *     - `file_moved` - File moved into/out of folder
         *     - `folder_created` - Subfolder created
         *     - `folder_deleted` - Subfolder deleted
         *     - `append` - New append on any file in folder
         *
         *     **Limits:** Maximum 10 webhooks per folder.
         */
        post: operations["createFolderWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/folders/{path}/webhooks/{webhookId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete folder webhook
         * @description Delete a webhook registered for a folder.
         */
        delete: operations["deleteFolderWebhook"];
        options?: never;
        head?: never;
        /**
         * Update folder webhook
         * @description Update a webhook registered for a folder.
         */
        patch: operations["updateFolderWebhook"];
        trace?: never;
    };
    "/a/{key}/folders/{path}/claims": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List claims in folder
         * @description List active claims for an author across all files in a folder.
         *
         *     Useful for agents to track their active work across multiple files.
         *
         *     **Performance:** Claims are indexed by `(author, fileId)` for fast lookups.
         */
        get: operations["listFolderClaims"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List scoped keys
         * @description List all scoped keys for a file. By default, revoked keys are excluded.
         *
         *     Use `?includeRevoked=true` to include revoked keys in the response.
         */
        get: operations["listScopedKeys"];
        put?: never;
        /**
         * Create scoped key
         * @description Create a scoped capability key with specific permissions and restrictions.
         *
         *     Scoped keys can have:
         *     - **boundAuthor**: All appends must use this author name
         *     - **wipLimit**: Override WIP limit for this key
         *     - **allowedTypes**: Restrict which append types this key can create
         *     - **expiresAt**: Key expiration timestamp
         *     - **paths**: Restrict key to specific paths
         *
         *     The response includes the full key (only shown once at creation).
         */
        post: operations["createScopedKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/keys/{keyId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Revoke scoped key
         * @description Revoke a scoped key. The key becomes immediately unusable.
         *
         *     Revoked keys remain in the list (with `revoked: true`) for audit purposes
         *     unless explicitly filtered out.
         */
        delete: operations["revokeScopedKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/capabilities/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Validate capability keys
         * @description Check if given keys are valid and return their permissions.
         *
         *     This endpoint validates up to 100 keys at once and returns:
         *     - Whether each key is valid
         *     - The permission level (read/append/write)
         *     - The scope type and ID
         *     - Error messages for invalid keys
         *
         *     Keys are truncated in responses for security (only first 8 chars shown).
         */
        post: operations["checkCapabilities"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/auth/signin/github": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Sign in with GitHub
         * @description Initiate GitHub OAuth flow.
         *
         *     Redirects to GitHub for authorization. On success, redirects back with
         *     session cookie set automatically.
         *
         *     **When to use:** Only for Tier 2 (nuclear) operations:
         *     - Rotate ALL capability URLs
         *     - Delete workspace
         *     - Transfer ownership
         *
         *     Most operations do NOT require OAuth - use capability URLs instead.
         */
        get: operations["signInWithGitHub"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/auth/signin/google": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Sign in with Google
         * @description Initiate Google OAuth flow.
         *
         *     Redirects to Google for authorization. On success, redirects back with
         *     session cookie set automatically.
         *
         *     **When to use:** Only for Tier 2 (nuclear) operations:
         *     - Rotate ALL capability URLs
         *     - Delete workspace
         *     - Transfer ownership
         *
         *     Most operations do NOT require OAuth - use capability URLs instead.
         */
        get: operations["signInWithGoogle"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get current user
         * @description Get the current authenticated user's information.
         *
         *     Requires a valid OAuth session cookie (from GitHub/Google sign-in).
         */
        get: operations["getCurrentUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout
         * @description Logout and clear the OAuth session cookie.
         */
        post: operations["logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/claim": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Claim workspace
         * @description Claim ownership of a workspace. Requires the workspace's **write key** AND an OAuth session.
         *
         *     **Requirements:**
         *     - Must be logged in via GitHub or Google OAuth
         *     - Must have the workspace's write key
         *
         *     **Claiming rules:**
         *     - A workspace can only be claimed once
         *     - Claiming is optional — workspaces never expire
         *     - The claimer becomes the workspace owner
         *     - OAuth identity is used for ownership (no email verification needed)
         */
        post: operations["claimWorkspace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/workspace": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Rename workspace via write key
         * @description Rename a workspace using a workspace-scoped write capability key.
         *
         *     This endpoint is intended for capability-key workflows that need to
         *     rename workspaces without an OAuth session.
         */
        patch: operations["renameWorkspaceViaWriteKey"];
        trace?: never;
    };
    "/workspaces/{workspaceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete workspace
         * @description Permanently delete a workspace and ALL its contents.
         *
         *     **⚠️ DESTRUCTIVE OPERATION - CANNOT BE UNDONE**
         *
         *     This will delete:
         *     - All files and folders
         *     - All capability URLs (they become invalid)
         *     - All API keys
         *     - All webhooks
         *     - Ownership information
         *
         *     **Requires:** OAuth session (GitHub/Google) and workspace ownership.
         */
        delete: operations["deleteWorkspace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/name": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Rename workspace
         * @description Rename a workspace via OAuth account controls session.
         *
         *     **Requires:** OAuth session (GitHub/Google) and workspace ownership.
         */
        patch: operations["renameWorkspace"];
        trace?: never;
    };
    "/workspaces/{workspaceId}/rotate-all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Rotate all capability URLs
         * @description Regenerate ALL capability URLs for this workspace.
         *
         *     **⚠️ DESTRUCTIVE OPERATION**
         *
         *     This will:
         *     - Generate new read/append/write keys for all files/folders
         *     - Invalidate ALL existing capability URLs
         *     - Break all integrations using old URLs
         *     - Return newly generated root read/append/write keys once in the response
         *
         *     Use this when you suspect keys have been compromised.
         *
         *     **Requires:** OAuth session (GitHub/Google) and workspace ownership.
         */
        post: operations["rotateAllUrls"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/api-keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List API keys
         * @description List all API keys for a workspace.
         *
         *     **Requires:** Session cookie (verified email) and workspace ownership.
         *
         *     **Note:** Full key values are never returned after creation — only the prefix
         *     for identification.
         */
        get: operations["listApiKeys"];
        put?: never;
        /**
         * Create API key
         * @description Create a new API key for programmatic workspace access.
         *
         *     **Requires:** Session cookie (verified email) and workspace ownership.
         *
         *     **Key format:** API keys start with `sk_` prefix:
         *     - `sk_live_...` for production
         *     - `sk_test_...` for test environments
         *
         *     **Important:** The full key is only shown once at creation time. Store it securely.
         *     Keys are hashed before storage — we cannot recover lost keys.
         */
        post: operations["createApiKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/api-keys/{keyId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Revoke API key
         * @description Revoke (delete) an API key.
         *
         *     **Requires:** Session cookie (verified email) and workspace ownership.
         *
         *     Deletion is immediate. Any requests using this key will fail.
         */
        delete: operations["revokeApiKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List webhooks
         * @description List all webhooks registered for this file.
         *
         *     Returns webhook status, success rate, and last trigger time.
         */
        get: operations["listWebhooks"];
        put?: never;
        /**
         * Create webhook
         * @description Register a new webhook to receive events for this file.
         *
         *     Webhook URLs must use HTTPS and resolve to public IP addresses (SSRF protection).
         *     If `secret` is omitted, the server generates a secure 32-byte secret and returns
         *     it in the response (shown only once at creation).
         *
         *     **Events:** Subscribe to specific events like `append`, `claim.expired`, `task.blocked`.
         *     **Filters:** Optionally narrow which events trigger the webhook by append type, labels, or priority.
         */
        post: operations["createWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/webhooks/{webhookId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete webhook
         * @description Delete a webhook. Events will no longer be delivered to this endpoint.
         */
        delete: operations["deleteWebhook"];
        options?: never;
        head?: never;
        /**
         * Update webhook
         * @description Partially update webhook configuration.
         *
         *     Supports secret rotation with optional grace period for seamless key rollover.
         */
        patch: operations["updateWebhook"];
        trace?: never;
    };
    "/w/{key}/webhooks/{webhookId}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get webhook delivery logs
         * @description Get delivery logs for a webhook. Includes status, response code, duration, and any errors.
         *
         *     Logs are retained for 7 days.
         */
        get: operations["getWebhookLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/webhooks/{webhookId}/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test webhook
         * @description Send a test event to the webhook endpoint. Useful for verifying connectivity
         *     and signature validation.
         *
         *     If no event type is specified, defaults to `append.created`.
         */
        post: operations["testWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List workspace webhooks
         * @description List webhooks configured for a workspace from account controls.
         *     Requires an authenticated session and workspace ownership.
         */
        get: operations["listWorkspaceWebhooks"];
        put?: never;
        /**
         * Create workspace webhook
         * @description Create a workspace webhook from account controls.
         *     Requires workspace ownership.
         */
        post: operations["createWorkspaceWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/webhooks/{webhookId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete workspace webhook
         * @description Delete a workspace webhook from account controls.
         *     Requires workspace ownership.
         */
        delete: operations["deleteWorkspaceWebhook"];
        options?: never;
        head?: never;
        /**
         * Update workspace webhook
         * @description Update a workspace webhook from account controls.
         *     Requires workspace ownership.
         */
        patch: operations["updateWorkspaceWebhook"];
        trace?: never;
    };
    "/workspaces/{workspaceId}/webhooks/{webhookId}/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test workspace webhook
         * @description Send a test delivery to a workspace webhook.
         *     Requires workspace ownership.
         */
        post: operations["testWorkspaceWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Scoped search via capability URL
         * @description Search within the scope the capability URL grants access to.
         *
         *     This is **lexical** full-text search (term-based), not semantic/embedding search.
         *     Results include **snippets** (relevant chunks) and highlights.
         *
         *     **Deleted items are excluded**: files with `deleted_at` set are never returned.
         *
         *     **Scoping:**
         *     - **File-scoped key:** Searches that file's content and its appends
         *     - **Folder-scoped key:** Searches file contents and appends within that folder scope
         *     - **Workspace-scoped key:** Searches file contents and appends within the whole workspace
         *
         *     **Query semantics:**
         *     - `q` is treated as plain text (special operator syntax is not supported in v1).
         *
         *     **Filters:**
         *     - `q`: Full-text search query
         *     - `type`: Filter by append type (task, claim, response, comment, etc.)
         *     - `status`: Filter tasks by status (pending, claimed, completed, cancelled)
         *     - `author`: Filter by author name
         *     - `labels`: Filter by labels (comma-separated, OR matching)
         *     - `priority`: Filter by priority levels
         *     - `since`: Return results after this timestamp
         */
        get: operations["searchInFileViaReadKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search entire workspace
         * @description Search across all files in the workspace. Requires API key authentication.
         *
         *     This is **lexical** full-text search (term-based), not semantic/embedding search.
         *     Results include **snippets** (relevant chunks) and highlights.
         *
         *     **Deleted items are excluded**: files with `deleted_at` set are never returned.
         *
         *     Supports all the same filters as file-level search, plus:
         *     - `folder`: Limit search to a specific folder path
         *
         *     **Frontmatter Query:** Use `frontmatter.` prefix to filter by frontmatter fields.
         *     Example: `?frontmatter.skills=security&frontmatter.status=active`
         */
        get: operations["searchWorkspace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/ops/subscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * WebSocket subscription (read-only events)
         * @description Get WebSocket subscription credentials for real-time event streaming.
         *
         *     Read key subscriptions receive file-level events only:
         *     - `append`: Any append added to file
         *     - `file.created`: File created in watched folder
         *     - `file.deleted`: File deleted
         *     - `file.updated`: File content changed
         *
         *     **WebSocket Message Types:**
         *     - `connected`: Initial connection confirmation
         *     - `append`: New append event
         *     - `heartbeat`: Server keepalive ping
         *     - `file.updated`: File content changed
         *     - `error`: Error notification
         *
         *     Returns 101 Switching Protocols for WebSocket upgrade on successful connection.
         */
        get: operations["subscribeReadKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/ops/subscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * WebSocket subscription (append events)
         * @description Get WebSocket subscription credentials for real-time event streaming.
         *
         *     Append key subscriptions receive all read events plus task/claim lifecycle events:
         *     - `append`: Any append added to file
         *     - `file.created`: File created in watched folder
         *     - `file.deleted`: File deleted
         *     - `file.updated`: File content changed
         *     - `task.created`: New task append added
         *     - `task.completed`: Task received response
         *     - `task.cancelled`: Task was cancelled
         *     - `task.blocked`: Agent marked task blocked
         *     - `task.unblocked`: Blocked task received answer
         *     - `task.overdue`: Task passed due date.
         *     - `task.escalated`: Task escalated to human
         *     - `task.recurred`: Recurring task created new instance
         *     - `claim.created`: Task was claimed
         *     - `claim.expired`: Claim not renewed in time
         *     - `claim.renewed`: Claim timer extended
         *     - `heartbeat`: Agent liveness signal
         *
         *     **WebSocket Message Types:**
         *     - `connected`: Initial connection confirmation
         *     - `append`: New append event
         *     - `heartbeat`: Server keepalive ping
         *     - `file.updated`: File content changed
         *     - `error`: Error notification
         *
         *     Returns 101 Switching Protocols for WebSocket upgrade on successful connection.
         */
        get: operations["subscribeAppendKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/ops/subscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * WebSocket subscription (all events including write-level events)
         * @description Get WebSocket subscription credentials for real-time event streaming.
         *
         *     Write key subscriptions receive all events including write-level events:
         *     - All read events (`append`, `file.created`, `file.deleted`, `file.updated`)
         *     - All append events (task/claim lifecycle)
         *     - `webhook.failed`: Webhook delivery failed
         *     - `settings.changed`: File/folder settings modified
         *
         *     **WebSocket Message Types:**
         *     - `connected`: Initial connection confirmation
         *     - `append`: New append event
         *     - `heartbeat`: Server keepalive ping
         *     - `file.updated`: File content changed
         *     - `error`: Error notification
         *
         *     Returns 101 Switching Protocols for WebSocket upgrade on successful connection.
         */
        get: operations["subscribeWriteKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/heartbeat": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Record agent heartbeat
         * @description Record an agent heartbeat to signal liveness. Updates the agent's "last seen"
         *     timestamp without cluttering the file with appends.
         *
         *     Heartbeats are stored separately from regular appends and do not increment
         *     the append counter.
         *
         *     **Author Identity:**
         *     - Default keys (`boundAuthor: null`): Author is self-declared
         *     - Scoped keys (`boundAuthor: "agent-alpha"`): Server validates author matches
         *       `boundAuthor`. Returns 400 AUTHOR_MISMATCH if mismatched.
         *
         *     **Rate limiting:** Subject to standard append rate limits (60 req/min per capability URL).
         */
        post: operations["recordHeartbeat"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/ops/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get file/folder/workspace statistics (write key)
         * @description Returns statistics for the scope of the write key.
         *
         *     Provides scope-aware statistics including:
         *     - Scope info (type and id)
         *     - Counts (files, appends, tasks, claims, agents)
         *     - Activity (last append, appends today/this week)
         */
        get: operations["getStatsViaWriteKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/ops/file/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get file statistics (read key)
         * @description Returns statistics for a specific file including append counts and task statistics.
         *
         *     Provides:
         *     - Total append count
         *     - Task statistics (pending, claimed, completed, active claims)
         */
        get: operations["getFileStatsViaReadKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/a/{key}/ops/file/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get file statistics
         * @description Returns statistics for a specific file including append counts and task statistics.
         *
         *     Provides:
         *     - Total append count
         *     - Task statistics (pending, claimed, completed, active claims)
         */
        get: operations["getFileStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get workspace statistics
         * @description Returns comprehensive statistics for the entire workspace.
         *
         *     Requires API key authentication via Bearer token.
         *
         *     Provides:
         *     - File and folder counts
         *     - Total storage usage and limits
         *     - Append counts and task statistics
         */
        get: operations["getWorkspaceStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/j/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Poll async job status
         * @description Poll the status of an asynchronous job. Job poll URLs use capability keys
         *     (same format as file keys) to prevent job ID guessing.
         *
         *     Jobs complete within 60 seconds or fail.
         *
         *     **Job lifecycle:**
         *     - `pending`: Job is queued, waiting to start
         *     - `processing`: Job is currently running
         *     - `completed`: Job finished successfully, result available
         *     - `failed`: Job encountered an error
         *
         *     Job poll URLs expire after the job completes + 1 hour.
         */
        get: operations["pollJobStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export workspace (synchronous)
         * @description Download all workspace data as a single archive. For workspaces under 500MB.
         *
         *     **Required scope:** API key must have `export` scope.
         *
         *     **Security Note:** All exports are logged with full context (who, when, scope, IP).
         *     Workspace owners receive email notification when exports occur.
         */
        get: operations["exportWorkspace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/export/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create async export job
         * @description Create an asynchronous export job for large workspaces (over 500MB) or by preference.
         *
         *     **Required scope:** API key must have `export` scope.
         *
         *     Download links expire after 24 hours.
         */
        post: operations["createExportJob"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/export/jobs/{jobId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get export job status
         * @description Check the status of an async export job. When complete, includes a download URL.
         *
         *     Download URLs expire after 24 hours.
         */
        get: operations["getExportJobStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/export/jobs/{jobId}/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download export archive
         * @description Download the completed export archive for a specific job.
         *
         *     **Required scope:** API key must have `export` scope.
         *
         *     Download is only available when job status is `ready`. Returns binary stream
         *     of the archive file (ZIP or tar.gz format).
         *
         *     Security note: All downloads are logged with full context for audit purposes.
         */
        get: operations["downloadExportJob"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List deleted files (recoverable)
         * @description List soft-deleted files that are still recoverable. Files are recoverable for 7 days
         *     after deletion.
         *
         *     **Required scope:** API key must have `admin` scope.
         *
         *     Deleted content may contain sensitive data. This endpoint is for compliance/backup
         *     scenarios requiring deleted file recovery.
         */
        get: operations["listDeletedFiles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/agents/liveness": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Agent liveness status
         * @description Returns liveness status for all agents that have sent heartbeats in the workspace.
         *
         *     An agent is considered "stale" if no heartbeat received within the stale threshold
         *     (default: 5 minutes, configurable via query param or workspace settings).
         */
        get: operations["getAgentLiveness"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/agents/liveness": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Scoped agent liveness
         * @description Returns liveness for agents that have sent heartbeats to the specific file or folder.
         *     Same response format as workspace-level endpoint.
         */
        get: operations["getScopedAgentLiveness"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/r/{key}/orchestration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read-only orchestration view
         * @description Get a comprehensive view of all tasks and claims across the accessible scope.
         *     Designed for orchestrators and account controls views that need to monitor agent activity.
         *
         *     Returns pending tasks, active claims, agent liveness, and workload distribution.
         */
        get: operations["getOrchestrationReadOnly"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/orchestration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Write-level orchestration view
         * @description Get a comprehensive view of all tasks and claims with write-level capabilities.
         *
         *     Same response as read-only view, plus ability to force-expire claims
         *     via the returned claim IDs.
         */
        get: operations["getOrchestrationAdmin"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/orchestration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get workspace orchestration board
         * @description Get a comprehensive view of all tasks and claims in a workspace.
         *
         *     Returns the same shape as `/r/{key}/orchestration` for unified client handling.
         *
         *     **Requires:** OAuth session and workspace ownership.
         */
        get: operations["getWorkspaceOrchestration"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/orchestration/claims/{claimId}/renew": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Renew a claim via workspace orchestration
         * @description Extend the expiration time of an active claim.
         *
         *     **Requires:** OAuth session and workspace ownership.
         */
        post: operations["renewClaimWorkspace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/orchestration/claims/{claimId}/complete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete a claim via workspace orchestration
         * @description Mark a claimed task as completed.
         *
         *     **Requires:** OAuth session and workspace ownership.
         */
        post: operations["completeClaimWorkspace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/orchestration/claims/{claimId}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel a claim via workspace orchestration
         * @description Abandon a claim, returning the task to pending status.
         *
         *     **Requires:** OAuth session and workspace ownership.
         */
        post: operations["cancelClaimWorkspace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/orchestration/claims/{claimId}/block": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Block a claim via workspace orchestration
         * @description Mark a claim as blocked with a reason.
         *
         *     **Requires:** OAuth session and workspace ownership.
         */
        post: operations["blockClaimWorkspace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/files/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Read file by path
         * @description Read file content by workspace-relative path.
         *
         *     Requires API key with `read` scope.
         *
         *     The path is URL-encoded (e.g., `/api/v1/files/projects%2Falpha%2Fnotes.md`).
         */
        get: operations["apiReadFileByPath"];
        /**
         * Update file by path
         * @description Replace entire file content at the specified path.
         *
         *     Requires API key with `write` scope.
         *
         *     Use `If-Match` header with ETag for optimistic concurrency control.
         *     If omitted, last-write-wins.
         */
        put: operations["apiUpdateFileByPath"];
        /**
         * Create file by path
         * @description Create a new file at the specified path.
         *
         *     Requires API key with `append` or `write` scope.
         *
         *     If parent folders don't exist, they are created automatically.
         */
        post: operations["apiCreateFileByPath"];
        /**
         * Delete file by path
         * @description Delete a file at the specified path.
         *
         *     Requires API key with `write` scope.
         *
         *     Soft delete by default (recoverable for 7 days).
         *     Use `?permanent=true` for hard delete (irreversible).
         */
        delete: operations["apiDeleteFileByPath"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/files/{path}/append": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Append to file by path
         * @description Append content to a file at the specified path.
         *
         *     Requires API key with `append` or `write` scope.
         *
         *     Supports all append types: task, claim, response, comment, blocked, answer, renew, cancel, vote.
         */
        post: operations["apiAppendToFileByPath"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/folders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List root folder
         * @description List contents of the workspace root folder.
         *
         *     Requires API key with `read` scope.
         *
         *     Returns files and subfolders at the workspace root.
         */
        get: operations["apiListRootFolder"];
        put?: never;
        /**
         * Create folder at root
         * @description Create a new folder at the workspace root.
         *
         *     Requires API key with `write` scope.
         */
        post: operations["apiCreateRootFolder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/folders/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List folder by path
         * @description List contents of a folder at the specified path.
         *
         *     Requires API key with `read` scope.
         *
         *     Returns files and subfolders with their metadata.
         */
        get: operations["apiListFolderByPath"];
        put?: never;
        /**
         * Create folder by path
         * @description Create a new folder at the specified path.
         *
         *     Requires API key with `write` scope.
         *
         *     Parent folders are created automatically if they don't exist.
         */
        post: operations["apiCreateFolderByPath"];
        /**
         * Delete folder by path
         * @description Delete a folder at the specified path.
         *
         *     Requires API key with `write` scope.
         *
         *     Empty folders are deleted directly. For non-empty folders, use cascade delete
         *     with confirmation by setting `cascade: true` and `confirmPath` matching the
         *     folder path exactly.
         *
         *     Cascade delete is soft delete only — all files remain recoverable for 7 days.
         */
        delete: operations["apiDeleteFolderByPath"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health check (liveness probe)
         * @description Simple health check endpoint for load balancer probes, Docker HEALTHCHECK,
         *     and Kubernetes liveness/readiness.
         *
         *     Returns a simple response indicating the service is alive.
         *     For comprehensive system status with subsystem checks, use `/api/v1/status`.
         *
         *     No authentication required.
         */
        get: operations["healthCheck"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/openapi.json": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * OpenAPI specification
         * @description Returns the OpenAPI 3.1 specification for the API in JSON format.
         *
         *     Auto-generated by Elysia from route definitions.
         *
         *     No authentication required.
         */
        get: operations["getOpenApiSpec"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/docs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * API documentation
         * @description Interactive API documentation (Swagger UI or similar).
         *
         *     Uses Elysia's `@elysiajs/swagger` plugin.
         *
         *     No authentication required.
         */
        get: operations["getApiDocs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/changelog": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * API changelog
         * @description Returns the API changelog with version history, release dates, and changes.
         *
         *     Useful for tracking API updates and planning migrations.
         *
         *     No authentication required.
         */
        get: operations["getChangelog"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Service status (comprehensive)
         * @description Returns the current service status for all components.
         *
         *     Useful for programmatic status checks (e.g., agents deciding whether to retry)
         *     and status page integration.
         *
         *     For simple liveness probes, use `/health` instead.
         *
         *     No authentication required.
         */
        get: operations["getServiceStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/capabilities/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Check capabilities for URLs in workspace context
         * @description Check the validity of capability URLs with extended information available
         *     when using a write key.
         *
         *     Returns extended information about keys belonging to the file/workspace,
         *     including path and detailed status.
         *
         *     Keys for other files return minimal response (valid/invalid only).
         *
         *     **Use cases:**
         *     - Agent startup: "Which of my configured keys are still valid?"
         *     - Monitoring: "Have any of our capability URLs been rotated?"
         *     - File owner audit: "What keys exist for my file and what permissions do they have?"
         *
         *     **Rate limiting:** 5 requests/min per IP.
         */
        post: operations["checkCapabilitiesInWorkspace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/w/{key}/audit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get audit logs
         * @description Returns audit logs for the workspace. Requires write key.
         *
         *     Audit logs track all significant actions performed in the workspace,
         *     including file operations, key management, and webhook changes.
         *
         *     Supports filtering by action, resource type, actor, and date range.
         *     Results are paginated with configurable limit and cursor.
         */
        get: operations["getAuditLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/admin/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get system metrics
         * @description Returns system-wide metrics including storage usage, entity counts,
         *     and health indicators.
         *
         *     **Authentication:** Requires `Authorization: Bearer <ADMIN_SECRET>` header.
         *     The ADMIN_SECRET is set via environment variable on the server.
         *
         *     **Security:** This endpoint exposes sensitive operational data.
         *     Only share the ADMIN_SECRET with trusted operators.
         */
        get: operations["getAdminMetrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description Required configuration for workspace bootstrap */
        BootstrapRequest: {
            /** @description Human-friendly workspace name */
            workspaceName: string;
        };
        /** @description Capability keys for the workspace (use these with API or web URLs) */
        BootstrapKeys: {
            /**
             * @description Read capability key - grants read-only access
             * @example m7dXp9lKa2nQe4R8vL5wYt
             */
            read: string;
            /**
             * @description Append capability key - grants read + append access
             * @example a_nK3pL9mQ2xR8vL5wYt
             */
            append: string;
            /**
             * @description Write capability key - grants full access (read + append + write)
             * @example w_vT5yU8wX1zA4vL5wYt
             */
            write: string;
        };
        /** @description API endpoint URLs (for curl/CLI usage) */
        BootstrapApiUrls: {
            /**
             * Format: uri
             * @description Read API base URL
             * @example https://api.mdplane.dev/r/m7dXp9lKa2nQe4R8vL5wYt
             */
            read: string;
            /**
             * Format: uri
             * @description Append API base URL
             * @example https://api.mdplane.dev/a/a_nK3pL9mQ2xR8vL5wYt
             */
            append: string;
            /**
             * Format: uri
             * @description Write API base URL
             * @example https://api.mdplane.dev/w/w_vT5yU8wX1zA4vL5wYt
             */
            write: string;
        };
        /** @description Web UI URLs (for browser access) */
        BootstrapWebUrls: {
            /**
             * Format: uri
             * @description Read-only file browser
             * @example https://app.mdplane.dev/r/m7dXp9lKa2nQe4R8vL5wYt
             */
            read: string;
            /**
             * Format: uri
             * @description Claim workspace page (requires login to complete)
             * @example https://app.mdplane.dev/claim/w_vT5yU8wX1zA4vL5wYt
             */
            claim: string;
        };
        /** @description Pre-built URLs for API and web access */
        BootstrapUrls: {
            api: components["schemas"]["BootstrapApiUrls"];
            web: components["schemas"]["BootstrapWebUrls"];
        };
        /** @description Response from bootstrap endpoint with workspace details */
        BootstrapResponse: {
            /** @constant */
            ok: true;
            data: {
                /**
                 * @description Unique workspace identifier
                 * @example ws_x8k2mP9qL3nR
                 */
                workspaceId: string;
                keys: components["schemas"]["BootstrapKeys"];
                urls: components["schemas"]["BootstrapUrls"];
                /**
                 * Format: date-time
                 * @description Workspace creation timestamp
                 */
                createdAt: string;
            };
        };
        Error: {
            /** @constant */
            ok: false;
            error: {
                /**
                 * @description Machine-readable error code
                 * @enum {string}
                 */
                code: "FILE_NOT_FOUND" | "FOLDER_NOT_FOUND" | "FOLDER_ALREADY_EXISTS" | "FOLDER_EXISTS" | "SOURCE_NOT_FOUND" | "APPEND_NOT_FOUND" | "WEBHOOK_NOT_FOUND" | "WORKSPACE_NOT_FOUND" | "FILE_DELETED" | "FILE_ALREADY_EXISTS" | "FOLDER_NOT_EMPTY" | "INVALID_REQUEST" | "SERVER_ERROR" | "INVALID_APPEND_TYPE" | "INVALID_REF" | "INVALID_VOTE_VALUE" | "INVALID_AUTHOR" | "INVALID_TOKEN" | "INVALID_WEBHOOK_URL" | "INVALID_PATH" | "INVALID_CONTENT" | "INVALID_TARGET" | "INVALID_KEY" | "INVALID_FILENAME" | "INVALID_APPEND_ID" | "SECTION_NOT_FOUND" | "UNSUPPORTED_MEDIA_TYPE" | "TASK_ALREADY_COMPLETE" | "TASK_CANCELLED" | "CLAIM_EXPIRED" | "ALREADY_CLAIMED" | "AUTHOR_MISMATCH" | "CANNOT_RENEW_OTHERS_CLAIM" | "CANNOT_CANCEL_OTHERS_CLAIM" | "TYPE_NOT_ALLOWED" | "KEY_EXPIRED" | "KEY_REVOKED" | "KEY_NOT_FOUND" | "NOT_FOUND" | "PERMISSION_DENIED" | "FORBIDDEN" | "NOT_ASSIGNED" | "CONFLICT" | "PAYLOAD_TOO_LARGE" | "WORKSPACE_TOO_LARGE" | "QUOTA_EXCEEDED" | "RATE_LIMITED" | "WIP_LIMIT_EXCEEDED" | "AUTHOR_RATE_LIMITED" | "BULK_LIMIT_EXCEEDED" | "WEBHOOK_LIMIT_EXCEEDED" | "WEBHOOK_SUSPENDED" | "UNAUTHORIZED" | "CONFIRM_PATH_MISMATCH" | "JOB_NOT_FOUND" | "JOB_NOT_READY" | "INVALID_PATTERN" | "QUERY_TOO_LONG" | "QUERY_TOO_BROAD" | "INVALID_TIMEOUT" | "SCOPE_DENIED";
                /** @description Human-readable error message */
                message: string;
                /** @description Additional error context */
                details?: {
                    [key: string]: unknown;
                };
            };
        };
        /**
         * @description User-facing append types that can be created via API or CLI
         * @enum {string}
         */
        UserAppendType: "task" | "claim" | "response" | "comment" | "blocked" | "answer" | "renew" | "cancel" | "vote";
        /**
         * @description System-only append types (heartbeat, etc.) - not user-creatable
         * @enum {string}
         */
        SystemAppendType: "heartbeat";
        /** @description All possible append types (user + system) */
        AppendType: components["schemas"]["UserAppendType"] | components["schemas"]["SystemAppendType"];
        /**
         * @description Computed status of a task or claim
         * @enum {string}
         */
        AppendStatus: "pending" | "open" | "claimed" | "completed" | "done" | "expired" | "cancelled" | "active";
        /**
         * @description Task priority level
         * @enum {string}
         */
        Priority: "low" | "medium" | "high" | "critical";
        /** @description Full append object returned in parsed file responses */
        Append: {
            /**
             * @description Append ID (sequential per-file)
             * @example a1
             */
            id: string;
            /**
             * @description Author identifier
             * @example jordan
             */
            author: string;
            /**
             * Format: date-time
             * @description ISO 8601 timestamp when append was created
             */
            ts: string;
            type: components["schemas"]["AppendType"];
            status?: components["schemas"]["AppendStatus"];
            /** @description Append content (markdown) */
            content?: string;
            priority?: components["schemas"]["Priority"];
            /** @description Labels array (tasks only) */
            labels?: string[];
            /** @description Referenced append ID */
            ref?: string;
            /**
             * Format: date-time
             * @description Claim expiry timestamp (claims only)
             */
            expiresAt?: string;
            /**
             * Format: date-time
             * @description Due date for tasks
             */
            dueAt?: string;
            /** @description Current claim holder (tasks only, if claimed) */
            claimedBy?: string;
            /**
             * Format: date-time
             * @description Completion timestamp (tasks only, if completed)
             */
            completedAt?: string;
            /**
             * @description Vote value (votes only)
             * @enum {string}
             */
            value?: "+1" | "-1";
            /** @description Informational linkage to other append IDs */
            relatedTo?: string[];
            /** @description True if content hash changed since append was created */
            stale?: boolean;
        };
        TaskStats: {
            /** @description Number of pending tasks */
            pending?: number;
            /** @description Number of claimed tasks */
            claimed?: number;
            /** @description Number of completed tasks */
            completed?: number;
            /** @description Number of currently active claims */
            activeClaims?: number;
        };
        FileStats: {
            /** @description Total number of appends */
            appendCount?: number;
            taskStats?: components["schemas"]["TaskStats"];
        };
        /** @description Workspace metadata included in capability URL responses */
        WorkspaceContext: {
            /** @description Workspace ID */
            id: string;
            /** @description Workspace name (if set) */
            name?: string;
            /** @description Whether workspace has been claimed by a user */
            claimed: boolean;
        };
        FileReadResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @description File name */
                filename: string;
                /** @description File content (markdown) */
                content: string;
                /** @description Content version hash for optimistic concurrency */
                etag: string;
                /**
                 * Format: date-time
                 * @description File creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: date-time
                 * @description Last modification timestamp
                 */
                updatedAt: string;
                /** @description Total number of appends */
                appendCount: number;
                /** @description File size in bytes */
                size: number;
                /** @description Parsed YAML frontmatter (when format=parsed) */
                frontmatter?: {
                    [key: string]: unknown;
                };
                /** @description Parsed appends (when format=parsed or appends param specified) */
                appends?: components["schemas"]["Append"][];
                stats?: components["schemas"]["FileStats"];
                /**
                 * Format: uri
                 * @description URL to view this file in the web app
                 */
                webUrl?: string;
                /** @description Workspace context for capability URL UI */
                workspace?: components["schemas"]["WorkspaceContext"];
            };
        };
        FileUpdateRequest: {
            /** @description New file content (replaces everything) */
            content: string;
        };
        FileUpdateResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @description New content version hash */
                etag: string;
                /**
                 * Format: date-time
                 * @description New modification timestamp
                 */
                updatedAt: string;
                /** @description New file size in bytes */
                size: number;
                /** @description Number of appends marked stale after content replacement */
                appendsStale?: number;
                /**
                 * Format: uri
                 * @description URL to view this file in the web app
                 */
                webUrl?: string;
            };
        };
        FileDeleteResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @constant */
                deleted: true;
                /** @description Whether file can be recovered (soft delete) */
                recoverable?: boolean;
                /**
                 * Format: date-time
                 * @description When soft-deleted file will be permanently deleted
                 */
                expiresAt?: string;
            };
        };
        FileRenameRequest: {
            /** @description New filename */
            filename: string;
        };
        FileRenameResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @description New filename after rename */
                filename: string;
            };
        };
        FileMetaResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @description File name */
                filename: string;
                /** @description Parent folder path */
                folder: string;
                /** @description File size in bytes */
                size: number;
                /**
                 * Format: date-time
                 * @description File creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: date-time
                 * @description Last modification timestamp
                 */
                updatedAt: string;
                /** @description Total number of appends */
                appendCount: number;
                taskStats: components["schemas"]["TaskStats"];
                /** @description Whether file has active webhooks */
                hasWebhook: boolean;
                /**
                 * Format: uri
                 * @description URL to view this file in the web app
                 */
                webUrl?: string;
            };
        };
        FileTailResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Tail content (last N bytes/lines) */
                content: string;
                /** @description Number of bytes returned */
                bytesReturned: number;
                /** @description Whether content was truncated (file larger than requested) */
                truncated: boolean;
            };
        };
        FileStructureResponse: {
            /** @constant */
            ok: true;
            data: {
                headings: {
                    /** @description Heading level (1-6) */
                    level: number;
                    /** @description Heading text content */
                    text: string;
                    /** @description Line number in file */
                    line: number;
                }[];
                /** @description Total number of appends in the file */
                appendCount: number;
                /** @description Whether file has any task appends */
                hasTaskAppends: boolean;
            };
        };
        FileSectionResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Heading text that was matched */
                heading: string;
                /** @description Heading level (1-6) */
                level: number;
                /** @description Section content */
                content: string;
                /** @description Starting line number */
                startLine: number;
                /** @description Ending line number */
                endLine: number;
            };
        };
        AppendGetResponse: {
            /** @constant */
            ok: true;
            data: components["schemas"]["Append"];
        };
        /**
         * @description Capability URLs for different permission levels.
         *     URL fields are nullable - null indicates the current key lacks permission for that tier.
         */
        CapabilityUrls: {
            /**
             * Format: uri
             * @description Read-only capability URL (null if key lacks read permission)
             */
            read: string | null;
            /**
             * Format: uri
             * @description Append capability URL (null if key lacks append permission)
             */
            append: string | null;
            /**
             * Format: uri
             * @description Admin/write capability URL (null if key lacks write permission)
             */
            write: string | null;
        };
        FileRecoverResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @constant */
                recovered: true;
                /** @description File path after recovery */
                path: string;
                urls: components["schemas"]["CapabilityUrls"];
                /**
                 * Format: uri
                 * @description URL to view this file in the web app
                 */
                webUrl?: string;
            };
        };
        FileMoveRequest: {
            /** @description Source file path (absolute from workspace root) */
            source: string;
            /** @description Destination folder path (absolute from workspace root) */
            destination: string;
        };
        FileMoveResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @description Original file path */
                previousPath: string;
                /** @description New file path after move */
                newPath: string;
                /**
                 * Format: uri
                 * @description URL to view this file in the web app at the new path
                 */
                webUrl?: string;
            };
        };
        FileRotateUrlsResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                urls: components["schemas"]["CapabilityUrls"];
                /** @constant */
                previousUrlsInvalidated: true;
                /**
                 * Format: uri
                 * @description URL to view this file in the web app
                 */
                webUrl?: string;
            };
        };
        FileSettings: {
            /** @description Default claim duration in seconds */
            claimDurationSeconds?: number;
            /** @description Maximum append size in bytes */
            maxAppendSize?: number;
            /** @description Allowed append types for this file */
            allowedAppendTypes?: components["schemas"]["UserAppendType"][];
            /** @description Work-in-progress limit for claims */
            wipLimit?: number;
            /** @description Allowed labels for this file */
            labels?: string[];
        };
        FileSettingsResponse: {
            /** @constant */
            ok: true;
            data: components["schemas"]["FileSettings"];
        };
        /** @description Partial update for file settings */
        FileSettingsUpdateRequest: {
            /** @description Default claim duration in seconds */
            claimDurationSeconds?: number;
            /** @description Maximum append size in bytes */
            maxAppendSize?: number;
            /** @description Allowed append types for this file */
            allowedAppendTypes?: components["schemas"]["UserAppendType"][];
            /** @description Work-in-progress limit for claims */
            wipLimit?: number;
            /** @description Allowed labels for this file */
            labels?: string[];
        };
        /** @description Request body for creating a single append */
        AppendRequest: {
            /**
             * @description Target file path for append operations that do not derive file scope from the key.
             *     Required for workspace-scoped and folder-scoped keys when using `/a/{key}/append`.
             */
            path?: string;
            /** @description Author identifier (required for root keys) */
            author?: string;
            type: components["schemas"]["UserAppendType"];
            /** @description Append content */
            content?: string;
            /** @description Referenced append ID (required for claim, response, blocked, answer, renew, cancel, vote) */
            ref?: string;
            priority?: components["schemas"]["Priority"];
            /** @description Labels (tasks only) */
            labels?: string[];
            /**
             * Format: date-time
             * @description Due date (tasks only)
             */
            dueAt?: string;
            /** @description Assigned author (tasks only) */
            assigned?: string;
            /**
             * @description Vote value (votes only)
             * @enum {string}
             */
            value?: "+1" | "-1";
            /** @description Informational linkage to other append IDs */
            relatedTo?: string[];
            /** @description Custom claim expiry in seconds (claims only, default 1800) */
            expiresInSeconds?: number;
        };
        /** @description Single append item for atomic multi-append (author inherited from parent) */
        AppendItem: {
            type: components["schemas"]["UserAppendType"];
            /** @description Append content */
            content?: string;
            /** @description Referenced append ID */
            ref?: string;
            priority?: components["schemas"]["Priority"];
            labels?: string[];
            /** Format: date-time */
            dueAt?: string;
            assigned?: string;
            /** @enum {string} */
            value?: "+1" | "-1";
            relatedTo?: string[];
            /** @description Custom claim expiry in seconds (claims only, default 1800) */
            expiresInSeconds?: number;
        };
        /** @description Request body for atomic multi-append operation */
        MultiAppendRequest: {
            /**
             * @description Target file path for append operations that do not derive file scope from the key.
             *     Required for workspace-scoped and folder-scoped keys when using `/a/{key}/append`.
             */
            path?: string;
            /** @description Author for all appends in this request */
            author: string;
            /** @description Array of append items (max 100) */
            appends: components["schemas"]["AppendItem"][];
        };
        /** @description Result of a single append operation */
        SingleAppendResult: {
            id: string;
            author: string;
            /** Format: date-time */
            ts: string;
            type: components["schemas"]["AppendType"];
            ref?: string;
            /**
             * Format: date-time
             * @description Claim expiry timestamp (for claim type)
             */
            expiresAt?: string;
            /** @description Seconds until claim expires */
            expiresInSeconds?: number;
            /** @description Initial status (e.g., 'open' for tasks) */
            status?: components["schemas"]["AppendStatus"];
            /** @description Task priority level (tasks only) */
            priority?: components["schemas"]["Priority"];
            /** @description Labels array (tasks only) */
            labels?: string[];
            /**
             * Format: date-time
             * @description Due date (tasks only)
             */
            dueAt?: string;
            /**
             * @description Updated task status after operation (for response/cancel)
             * @enum {string}
             */
            taskStatus?: "open" | "done";
            /**
             * @description Vote value (votes only)
             * @enum {string}
             */
            value?: "+1" | "-1";
        };
        /** @description Result of atomic multi-append operation */
        MultiAppendResult: {
            appends: {
                id: string;
                type: components["schemas"]["AppendType"];
                ref?: string;
                /**
                 * Format: date-time
                 * @description Claim expiry timestamp (for claim type)
                 */
                expiresAt?: string;
                /** @description Seconds until claim expires */
                expiresInSeconds?: number;
            }[];
        };
        /** @description Response for append operations */
        AppendResponse: {
            /** @constant */
            ok: true;
            /**
             * Format: date-time
             * @description Server timestamp for synchronization
             */
            serverTime: string;
            data: components["schemas"]["SingleAppendResult"] | components["schemas"]["MultiAppendResult"];
            /**
             * Format: uri
             * @description URL to view this file in the web app
             */
            webUrl?: string;
        };
        /** @description Request body for scoped path-based append */
        ScopedAppendRequest: {
            /** @description Author identifier (may be enforced by boundAuthor on key) */
            author?: string;
            /** @description Append type (may be restricted by allowedTypes on key) */
            type?: string;
            /** @description Append content */
            content?: string;
        };
        /** @description Result of a scoped append operation */
        ScopedAppendResult: {
            /** @description Append ID */
            appendId: string;
            /** @description Append type (if provided) */
            type?: string;
            /** @description Author identifier */
            author?: string;
            /**
             * Format: date-time
             * @description ISO 8601 timestamp when append was created
             */
            createdAt: string;
        };
        /** @description Response for scoped path-based append operations */
        ScopedAppendResponse: {
            /** @constant */
            ok: true;
            data: components["schemas"]["ScopedAppendResult"];
        };
        /**
         * @description Type of item in folder listing
         * @enum {string}
         */
        FolderItemType: "file" | "folder";
        /** @description An item in a folder listing (file or subfolder) */
        FolderItem: {
            /** @description Item name (filename or folder name) */
            name: string;
            type: components["schemas"]["FolderItemType"];
            /** @description File size in bytes (files only) */
            size?: number;
            /**
             * Format: date-time
             * @description Last modification timestamp
             */
            updatedAt?: string;
            /** @description Number of appends (files only) */
            appendCount?: number;
            /** @description Number of child items (folders only) */
            childCount?: number;
            urls?: components["schemas"]["CapabilityUrls"];
            /** @description Nested items when depth > 1 (folders only) */
            items?: components["schemas"]["FolderItem"][];
        };
        PaginatedResponse: {
            /** @description Opaque cursor for next page */
            cursor?: string;
            /** @description Whether more results are available */
            hasMore?: boolean;
            /** @description Total count of items (when available) */
            total?: number;
        };
        FolderListResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Folder path */
                path: string;
                items: components["schemas"]["FolderItem"][];
                /**
                 * Format: uri
                 * @description URL to view this folder in the web interface
                 */
                webUrl?: string;
                /** @description Workspace context for capability URL UI */
                workspace?: components["schemas"]["WorkspaceContext"];
            };
            pagination?: components["schemas"]["PaginatedResponse"];
        };
        CreateFileRequest: {
            /** @description File name */
            filename: string;
            /** @description Initial file content */
            content?: string;
        };
        CreateFileResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @description File name */
                filename: string;
                /** @description Full file path */
                path: string;
                urls: components["schemas"]["CapabilityUrls"];
                /**
                 * Format: date-time
                 * @description Creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: uri
                 * @description URL to view this file in the web interface
                 */
                webUrl?: string;
            };
        };
        /** @description Request body for cascade delete of non-empty folders */
        FolderDeleteRequest: {
            /** @description Delete folder and all contents */
            cascade?: boolean;
            /** @description Must match folder path exactly (without leading slash) */
            confirmPath?: string;
        };
        FolderDeleteResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @constant */
                deleted: true;
                /** @description Deleted folder path */
                path: string;
                /** @description Number of files deleted (cascade only) */
                filesDeleted?: number;
                /** @description Number of subfolders deleted (cascade only) */
                foldersDeleted?: number;
                /** @description Whether deleted content can be recovered */
                recoverable?: boolean;
                /**
                 * Format: date-time
                 * @description When soft-deleted content will be permanently deleted
                 */
                expiresAt?: string;
            };
        };
        FolderRenameRequest: {
            /** @description New folder name */
            name: string;
        };
        FolderMoveResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Original folder path */
                previousPath: string;
                /** @description New folder path after move */
                newPath: string;
                /** @description Number of files affected by the move */
                filesUpdated?: number;
                /**
                 * Format: uri
                 * @description URL to view this folder in the web interface at the new path
                 */
                webUrl?: string;
            };
        };
        FolderCreateRequest: {
            /** @description New folder name */
            name: string;
            /** @description Parent folder path (defaults to root) */
            path?: string;
        };
        FolderCreateResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Full path of created folder */
                path: string;
                urls: components["schemas"]["CapabilityUrls"];
                /**
                 * Format: date-time
                 * @description Creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: uri
                 * @description URL to view this folder in the web interface
                 */
                webUrl?: string;
            };
        };
        /** @description Request body for copying a file into a folder */
        CopyFileToFolderRequest: {
            /** @description Read key of the source file to copy */
            sourceKey: string;
            /** @description Optional new filename (defaults to source filename) */
            filename?: string;
        };
        /** @description Single file to create in bulk operation */
        FolderBulkCreateItem: {
            /** @description File name */
            filename: string;
            /** @description Initial file content */
            content?: string;
        };
        /** @description Request body for bulk file creation */
        FolderBulkCreateRequest: {
            /** @description Array of files to create (max 100) */
            files: components["schemas"]["FolderBulkCreateItem"][];
        };
        /** @description Result for a single file in bulk create */
        FolderBulkCreateResultItem: {
            filename: string;
            id: string;
            urls: components["schemas"]["CapabilityUrls"];
            /**
             * Format: uri
             * @description URL to view this file in the web interface
             */
            webUrl?: string;
        };
        FolderBulkCreateResponse: {
            /** @constant */
            ok: true;
            data: {
                created: components["schemas"]["FolderBulkCreateResultItem"][];
                /**
                 * Format: uri
                 * @description URL to view the parent folder in the web interface
                 */
                webUrl?: string;
            };
        };
        /** @description Response for async bulk file creation (202 Accepted) */
        FolderBulkCreateJobResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Job ID for polling status */
                jobId: string;
            };
        };
        FolderMoveRequest: {
            /** @description Destination folder path */
            destination: string;
        };
        /** @description Folder-level settings */
        FolderSettings: {
            /** @description Whether to inherit settings from parent folder */
            inheritSettings?: boolean;
            /** @description Default labels for files created in this folder */
            defaultLabels?: string[];
            /** @description Allowed append types for files in this folder */
            allowedTypes?: ("task" | "claim" | "response" | "comment" | "blocked" | "answer" | "renew" | "cancel" | "vote")[];
        };
        FolderSettingsResponse: {
            /** @constant */
            ok: true;
            data: components["schemas"]["FolderSettings"];
        };
        /** @description Partial update for folder settings */
        FolderSettingsUpdateRequest: {
            /** @description Whether to inherit settings from parent folder */
            inheritSettings?: boolean;
            /** @description Default labels for files created in this folder */
            defaultLabels?: string[];
            /** @description Allowed append types for files in this folder */
            allowedTypes?: ("task" | "claim" | "response" | "comment" | "blocked" | "answer" | "renew" | "cancel" | "vote")[];
        };
        FolderStatsResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Folder path */
                path: string;
                /** @description Total number of files */
                fileCount: number;
                /** @description Total number of subfolders */
                folderCount: number;
                /** @description Total size in bytes */
                totalSize: number;
                /**
                 * Format: date-time
                 * @description Most recent modification timestamp
                 */
                updatedAt?: string;
                taskStats?: components["schemas"]["TaskStats"];
            };
        };
        /** @description Reference to a file with ID and path */
        FileReference: {
            /** @description Unique file identifier */
            id: string;
            /** @description File path relative to workspace root */
            path: string;
        };
        /** @description Capability URLs for file access (only includes URLs the key has access to) */
        FileUrls: {
            /**
             * Format: uri
             * @description Read-only capability URL
             */
            read?: string;
            /**
             * Format: uri
             * @description Append capability URL
             */
            append?: string;
            /**
             * Format: uri
             * @description Admin/write capability URL
             */
            write?: string;
        };
        /** @description Single match within a file for folder search */
        FolderSearchMatch: {
            /** @description Unique append identifier */
            appendId: string;
            /** @description Type of append (task, comment, etc.) */
            type: string;
            /** @description Content snippet matching the search query */
            content: string;
            /** @description Priority level (if applicable) */
            priority?: string;
            /** @description Status (if applicable) */
            status?: string;
            /** @description Labels attached to this append */
            labels?: string[];
            /** @description Author of the append */
            author?: string;
            /**
             * Format: date-time
             * @description Creation timestamp
             */
            createdAt?: string;
        };
        /** @description Search results grouped by file */
        FolderSearchResult: {
            file: components["schemas"]["FileReference"];
            fileUrls?: components["schemas"]["FileUrls"];
            matches?: components["schemas"]["FolderSearchMatch"][];
        };
        /** @description Response from folder search endpoint */
        FolderSearchResponse: {
            /** @constant */
            ok: true;
            data: {
                results: components["schemas"]["FolderSearchResult"][];
                /** @description Whether search was truncated due to timeout */
                truncated?: boolean;
            };
            pagination?: components["schemas"]["PaginatedResponse"];
        };
        /** @description Task result from task query endpoint */
        TaskQueryResult: {
            /** @description Append ID of the task */
            id: string;
            file: components["schemas"]["FileReference"];
            fileUrls?: components["schemas"]["FileUrls"];
            /** @description Task content */
            content: string;
            /** @description Task author */
            author?: string;
            /**
             * @description Task status
             * @enum {string}
             */
            status: "pending" | "claimed" | "completed" | "cancelled";
            /**
             * @description Task priority
             * @enum {string}
             */
            priority?: "low" | "medium" | "high" | "critical";
            /** @description Labels attached to this task */
            labels?: string[];
            /** @description User who claimed the task (if claimed) */
            claimedBy?: string;
            /**
             * Format: date-time
             * @description Claim expiration time (if claimed)
             */
            expiresAt?: string;
            /**
             * Format: date-time
             * @description Task creation timestamp
             */
            createdAt: string;
        };
        /** @description Summary counts of tasks by status */
        TaskSummary: {
            /** @description Count of pending tasks */
            pending: number;
            /** @description Count of claimed tasks */
            claimed: number;
            /** @description Count of completed tasks */
            completed: number;
        };
        /** @description Response from task query endpoint */
        TaskQueryResponse: {
            /** @constant */
            ok: true;
            data: {
                tasks: components["schemas"]["TaskQueryResult"][];
                summary: components["schemas"]["TaskSummary"];
                /**
                 * Format: uri
                 * @description URL to view tasks in the web interface
                 */
                webUrl: string;
            };
            pagination?: components["schemas"]["PaginatedResponse"];
        };
        /**
         * @description Event types that can trigger webhooks
         * @enum {string}
         */
        WebhookEvent: "append" | "append.created" | "task.created" | "task.claimed" | "task.completed" | "task.cancelled" | "task.blocked" | "task.unblocked" | "task.overdue" | "task.escalated" | "task.recurred" | "task.expired" | "claim.created" | "claim.expired" | "claim.renewed" | "claim.released" | "file.created" | "file.updated" | "file.deleted" | "heartbeat" | "webhook.failed" | "settings.changed";
        /**
         * @description Webhook status
         * @enum {string}
         */
        WebhookStatus: "active" | "paused" | "suspended" | "disabled";
        /** @description Webhook configuration */
        Webhook: {
            /** @description Webhook ID */
            id: string;
            /**
             * Format: uri
             * @description Webhook URL
             */
            url: string;
            events: components["schemas"]["WebhookEvent"][];
            status: components["schemas"]["WebhookStatus"];
            /** @description Whether capability URLs are included in payloads */
            includeUrls?: boolean;
            /**
             * Format: date-time
             * @description Creation timestamp
             */
            createdAt: string;
            /**
             * Format: date-time
             * @description Last successful delivery timestamp
             */
            lastTriggeredAt?: string;
            /** @description Consecutive failure count */
            failureCount?: number;
            /**
             * Format: float
             * @description Success rate (0.0 to 1.0)
             */
            successRate?: number;
        };
        WebhookListResponse: {
            /** @constant */
            ok: true;
            data: components["schemas"]["Webhook"][];
            /**
             * Format: uri
             * @description URL to manage webhooks in the web interface
             */
            webUrl?: string;
        };
        /** @description Request to register a new webhook */
        WebhookCreateRequest: {
            /**
             * Format: uri
             * @description HTTPS URL to receive webhook payloads
             */
            url: string;
            /** @description Events to subscribe to */
            events: components["schemas"]["WebhookEvent"][];
            /** @description HMAC-SHA256 signing secret (min 32 chars). If omitted, server generates one. */
            secret?: string;
            /** @description Custom headers to include in webhook requests */
            headers?: {
                [key: string]: string;
            };
            /**
             * @description Whether to include capability URLs in payloads
             * @default true
             */
            includeUrls: boolean;
            /** @description Optional filters to narrow which events trigger the webhook */
            filters?: {
                /** @description Filter by append types */
                types?: string[];
                /** @description Filter by labels */
                labels?: string[];
                /** @description Filter by priority levels */
                priority?: string[];
            };
            /** @description Whether the webhook should trigger for changes in subfolders (folder webhooks only) */
            recursive?: boolean;
        };
        WebhookCreateResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Webhook ID */
                id: string;
                /**
                 * Format: uri
                 * @description Webhook URL
                 */
                url: string;
                events: components["schemas"]["WebhookEvent"][];
                status: components["schemas"]["WebhookStatus"];
                /** @description Generated secret (only returned once at creation if not provided) */
                secret?: string;
                includeUrls?: boolean;
                /**
                 * Format: date-time
                 * @description Creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: uri
                 * @description URL to manage webhooks in the web interface
                 */
                webUrl?: string;
            };
        };
        WebhookDeleteResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Deleted webhook ID */
                id: string;
                /** @constant */
                deleted: true;
            };
        };
        /** @description Partial update for webhook configuration */
        WebhookUpdateRequest: {
            /**
             * Format: uri
             * @description New webhook URL
             */
            url?: string;
            /** @description Updated event subscriptions */
            events?: components["schemas"]["WebhookEvent"][];
            /** @description Enable/disable webhook */
            active?: boolean;
            /** @description New signing secret */
            secret?: string;
            /** @description Updated custom headers */
            headers?: {
                [key: string]: string;
            };
            /** @description Whether to include capability URLs in payloads */
            includeUrls?: boolean;
            /** @description Updated filters */
            filters?: {
                types?: string[];
                labels?: string[];
                priority?: string[];
            };
            /** @description Whether the webhook should trigger for changes in subfolders (folder webhooks only) */
            recursive?: boolean;
        };
        WebhookUpdateResponse: {
            /** @constant */
            ok: true;
            data: components["schemas"]["Webhook"];
        };
        /** @description File information for a claim */
        FolderClaimFileInfo: {
            /** @description File ID */
            id: string;
            /** @description File path within folder */
            path: string;
        };
        /** @description A single claim in a folder */
        FolderClaimItem: {
            /** @description ID of the claimed task */
            taskId: string;
            /** @description ID of the claim append */
            claimId: string;
            file: components["schemas"]["FolderClaimFileInfo"];
            /** @description Content of the claimed task */
            taskContent: string;
            /**
             * @description Claim status
             * @enum {string}
             */
            status: "active" | "expired";
            /**
             * Format: date-time
             * @description Claim expiry timestamp
             */
            expiresAt: string;
            /** @description Seconds until claim expires */
            expiresInSeconds: number;
        };
        FolderClaimsResponse: {
            /** @constant */
            ok: true;
            data: {
                claims: components["schemas"]["FolderClaimItem"][];
                /** @description Total number of claims */
                count: number;
                /**
                 * Format: uri
                 * @description URL to view claims in the web interface
                 */
                webUrl: string;
            };
        };
        /**
         * @description Permission level for scoped keys
         * @enum {string}
         */
        KeyPermission: "read" | "append" | "write";
        /** @description Scoped key metadata (key itself is partially redacted) */
        ScopedKey: {
            /** @description Key ID for management operations */
            id: string;
            /** @description Partially visible key (e.g., "a_x8k2...nR") */
            key?: string;
            permission: components["schemas"]["KeyPermission"];
            /** @description Bound author if set */
            boundAuthor?: string;
            /** @description Human-readable name */
            displayName?: string;
            /** @description WIP limit for this key */
            wipLimit?: number;
            /** @description Allowed append types */
            allowedTypes?: string[];
            /**
             * Format: date-time
             * @description Key creation timestamp
             */
            createdAt: string;
            /**
             * Format: date-time
             * @description Expiration timestamp if set
             */
            expiresAt?: string;
            /**
             * Format: date-time
             * @description Last usage timestamp
             */
            lastUsedAt?: string;
            /** @description Whether key has been revoked */
            revoked?: boolean;
        };
        ScopedKeyListResponse: {
            /** @constant */
            ok: true;
            data: components["schemas"]["ScopedKey"][];
            /**
             * Format: uri
             * @description URL to manage API keys in the web interface
             */
            webUrl?: string;
        };
        /** @description Request to create a scoped capability key */
        ScopedKeyCreateRequest: {
            permission: components["schemas"]["KeyPermission"];
            /** @description If set, all appends must use this author name */
            boundAuthor?: string;
            /** @description Human-readable name for the key (e.g., "Alpha Research Agent") */
            displayName?: string;
            /** @description Override WIP limit for this key */
            wipLimit?: number;
            /** @description Restrict which append types this key can create */
            allowedTypes?: ("task" | "claim" | "response" | "comment" | "blocked" | "answer" | "renew" | "cancel" | "vote")[];
            /**
             * Format: date-time
             * @description Key expiration timestamp
             */
            expiresAt?: string;
            /** @description Restrict key to specific paths */
            paths?: string[];
        };
        ScopedKeyCreateResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Unique identifier for the key (used for revocation) */
                id: string;
                /** @description The scoped capability key (prefixed with r_/a_/w_) */
                key: string;
                permission: components["schemas"]["KeyPermission"];
                /** @description Bound author if set */
                boundAuthor?: string;
                /** @description Human-readable name */
                displayName?: string;
                /** @description WIP limit for this key */
                wipLimit?: number;
                /** @description Allowed append types */
                allowedTypes?: string[];
                /**
                 * Format: date-time
                 * @description Expiration timestamp if set
                 */
                expiresAt?: string;
                /**
                 * Format: date-time
                 * @description Key creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: uri
                 * @description URL to manage API keys in the web interface
                 */
                webUrl?: string;
            };
        };
        KeyRevokeResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Key ID */
                id: string;
                /** @constant */
                revoked: true;
            };
        };
        CapabilitiesCheckRequest: {
            /** @description Array of capability keys to validate */
            keys: string[];
        };
        CapabilityCheckResult: {
            /** @description Truncated key (first 8 chars + "...") */
            key: string;
            /** @description Whether the key is valid */
            valid: boolean;
            /**
             * @description Permission level (only present if valid)
             * @enum {string}
             */
            permission?: "read" | "append" | "write";
            /**
             * @description Scope type (only present if valid)
             * @enum {string}
             */
            scope?: "file" | "folder" | "workspace";
            /** @description Workspace, folder, or file ID (only present if valid) */
            scopeId?: string;
            /** @description Error code (NOT_FOUND, EXPIRED, REVOKED) - only present if invalid */
            error?: string;
        };
        CapabilitiesCheckResponse: {
            /** @constant */
            ok: true;
            data: {
                results: components["schemas"]["CapabilityCheckResult"][];
            };
        };
        /** @description Workspace summary for user */
        Workspace: {
            /** @description Workspace ID */
            id: string;
            /** @description Workspace name */
            name: string;
        };
        /** @description Current authenticated user information */
        MeResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description User ID */
                id: string;
                /**
                 * Format: email
                 * @description User email address
                 */
                email: string;
                /** @description User display name (from OAuth provider) */
                name?: string;
                /**
                 * Format: uri
                 * @description User avatar URL (from OAuth provider)
                 */
                image?: string;
                /** @description Workspaces the user has access to */
                workspaces: components["schemas"]["Workspace"][];
                /**
                 * Format: date-time
                 * @description Account creation timestamp
                 */
                createdAt?: string;
                /**
                 * Format: uri
                 * @description URL to access the user's control panel
                 */
                webUrl?: string;
            };
        };
        LogoutResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @constant */
                status?: "logged_out";
            };
        };
        /** @description Response from claim workspace endpoint (always instant with OAuth) */
        ClaimWorkspaceResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Workspace identifier */
                workspaceId: string;
                /**
                 * @description Whether the workspace was successfully claimed
                 * @constant
                 */
                claimed: true;
                /**
                 * @description Status message
                 * @example claimed
                 */
                message: string;
                /**
                 * Format: uri
                 * @description URL to access the workspace control panel
                 */
                webUrl?: string;
            };
        };
        WorkspaceRenameRequest: {
            /** @description New workspace name */
            name: string;
        };
        WorkspaceRenameResponse: {
            /** @constant */
            ok: true;
            data: {
                /**
                 * @description Workspace ID
                 * @example ws_x8k2mP9qL3nR
                 */
                workspaceId: string;
                /**
                 * @description Updated workspace name
                 * @example Product Operations
                 */
                name: string;
                /**
                 * Format: date-time
                 * @description Time when the workspace name was updated
                 */
                updatedAt: string;
            };
        };
        SuccessResponse: {
            /** @constant */
            ok: true;
            /** @description Optional success data */
            data?: {
                /** @description Success message */
                message?: string;
            };
        };
        RotateAllResponse: {
            /** @constant */
            ok: true;
            data: {
                /**
                 * @description Workspace ID
                 * @example ws_x8k2mP9qL3nR
                 */
                workspaceId: string;
                /** @example All capability URLs rotated successfully */
                message: string;
                /**
                 * @description Number of files/folders that had URLs rotated
                 * @example 42
                 */
                rotatedCount: number;
                keys: components["schemas"]["BootstrapKeys"];
                urls: components["schemas"]["BootstrapUrls"];
                /**
                 * @description Warning that newly generated keys are shown once and must be stored now
                 * @example Store these keys now. They are shown once and cannot be retrieved again.
                 */
                keyCustodyWarning: string;
            };
        };
        /** @description API key metadata (returned in list operations) */
        ApiKey: {
            /** @description Unique key identifier */
            id: string;
            /** @description Human-readable key name */
            name: string;
            /** @description Key permission scopes */
            permissions: ("read" | "append" | "write" | "export")[];
            /**
             * Format: date-time
             * @description Key creation timestamp
             */
            createdAt: string;
            /**
             * Format: date-time
             * @description Key expiration timestamp (optional)
             */
            expiresAt?: string;
            /**
             * Format: date-time
             * @description Last usage timestamp (optional)
             */
            lastUsedAt?: string;
            /**
             * @description Key prefix for identification (sk_live_ or sk_test_)
             * @example sk_live_x8k2...
             */
            prefix: string;
        };
        /** @description Response containing list of API keys */
        ApiKeyListResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description List of API keys (without full key values) */
                keys: components["schemas"]["ApiKey"][];
                /**
                 * Format: uri
                 * @description URL to manage API keys in the web app
                 */
                webUrl?: string;
            };
        };
        /** @description Request to create a new API key */
        ApiKeyCreateRequest: {
            /** @description Human-readable name for the key */
            name: string;
            /** @description Permission scopes for the key */
            permissions: ("read" | "append" | "write" | "export")[];
            /** @description Time until expiration in seconds (optional) */
            expiresInSeconds?: number;
        };
        /** @description Response from API key creation (key shown only once) */
        ApiKeyCreateResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Unique key identifier */
                id: string;
                /**
                 * @description Full API key (shown only once, store securely)
                 * @example sk_live_demoKey123
                 */
                key: string;
                /** @description Key name */
                name: string;
                permissions: ("read" | "append" | "write" | "export")[];
                /**
                 * Format: date-time
                 * @description Key creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: date-time
                 * @description Key expiration timestamp (optional)
                 */
                expiresAt?: string;
                /**
                 * Format: uri
                 * @description URL to manage API keys in the web app
                 */
                webUrl?: string;
            };
        };
        /** @description Response from API key revocation */
        ApiKeyRevokeResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Key identifier */
                id: string;
                /** @constant */
                revoked: true;
            };
        };
        /**
         * @description Delivery status
         * @enum {string}
         */
        WebhookLogStatus: "ok" | "failed" | "timeout" | "error";
        /** @description Single webhook delivery log entry */
        WebhookLogEntry: {
            /** @description Log entry ID */
            id: string;
            event: components["schemas"]["WebhookEvent"];
            status: components["schemas"]["WebhookLogStatus"];
            /** @description HTTP response code from webhook endpoint */
            responseCode?: number;
            /**
             * Format: date-time
             * @description Delivery attempt timestamp
             */
            timestamp: string;
            /** @description Request duration in milliseconds */
            durationMs?: number;
            /** @description Error message if delivery failed */
            error?: string;
        };
        WebhookLogsResponse: {
            /** @constant */
            ok: true;
            data: {
                logs: components["schemas"]["WebhookLogEntry"][];
                pagination?: components["schemas"]["PaginatedResponse"];
            };
        };
        /** @description Request to send a test webhook */
        WebhookTestRequest: {
            /** @description Event type to simulate (defaults to 'append') */
            event?: components["schemas"]["WebhookEvent"];
        };
        WebhookTestResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Whether test was successfully delivered */
                delivered: boolean;
                /** @description HTTP response code from webhook endpoint */
                responseCode?: number;
                /** @description Request duration in milliseconds */
                durationMs: number;
                /** @description Error message if delivery failed */
                error?: string;
            };
        };
        /**
         * @description Type of search result
         * @enum {string}
         */
        SearchResultType: "file" | "append" | "task";
        /** @description Highlighted match position in content */
        SearchHighlight: {
            /** @description Start position of highlight (0-indexed) */
            start: number;
            /** @description End position of highlight (0-indexed, exclusive) */
            end: number;
        };
        /** @description Single search result item */
        SearchResult: {
            type: components["schemas"]["SearchResultType"];
            /** @description Unique identifier for the result (file ID or append ID) */
            id: string;
            file?: components["schemas"]["FileReference"];
            /** @description Content snippet matching the search query */
            content: string;
            /** @description Array of highlighted match positions */
            highlights: components["schemas"]["SearchHighlight"][];
            /**
             * Format: float
             * @description Relevance score for the result
             */
            score: number;
            /** @description Status (for task/claim types) */
            status?: string;
            /** @description Author of the append */
            author?: string;
            /**
             * Format: date-time
             * @description Creation timestamp
             */
            createdAt?: string;
            /** @description Frontmatter fields (when filtering by frontmatter) */
            frontmatter?: {
                [key: string]: unknown;
            };
        };
        /** @description Response from workspace/scoped search endpoints */
        SearchResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Array of search results */
                results: components["schemas"]["SearchResult"][];
                /** @description Total number of matching results */
                total?: number;
            };
            pagination?: components["schemas"]["PaginatedResponse"];
        };
        /**
         * @description Agent liveness status
         * @enum {string}
         */
        HeartbeatStatus: "alive" | "idle" | "busy" | "error" | "stale";
        /** @description Request to send agent heartbeat */
        HeartbeatRequest: {
            /** @description Agent identifier */
            author: string;
            status: components["schemas"]["HeartbeatStatus"];
            /** @description Currently active task reference (optional) */
            currentTask?: string;
            /** @description Additional agent metadata (optional) */
            metadata?: {
                [key: string]: unknown;
            };
        };
        /** @description Response from heartbeat endpoint */
        HeartbeatResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Heartbeat ID */
                id: string;
                /** @description Agent identifier */
                author: string;
                /**
                 * Format: date-time
                 * @description Heartbeat timestamp
                 */
                ts: string;
                /**
                 * Format: date-time
                 * @description When this heartbeat expires
                 */
                expiresAt: string;
                /**
                 * Format: date-time
                 * @description Deadline for next heartbeat to maintain liveness
                 */
                nextHeartbeatBy: string;
            };
        };
        StatsScope: {
            /**
             * @description The scope type of the write key
             * @enum {string}
             */
            type: "file" | "folder" | "workspace";
            /** @description ID of the scoped resource (file ID, folder path, or workspace ID) */
            id: string;
        };
        StatsCounts: {
            /** @description Number of files in scope */
            files: number;
            /** @description Total number of appends */
            appends: number;
            /** @description Number of task appends */
            tasks: number;
            /** @description Number of claim appends */
            claims: number;
            /** @description Number of unique agents/authors */
            agents: number;
        };
        StatsActivity: {
            /**
             * Format: date-time
             * @description Timestamp of the most recent append
             */
            lastAppendAt: string | null;
            /** @description Number of appends today */
            appendsToday: number;
            /** @description Number of appends in the last 7 days */
            appendsThisWeek: number;
        };
        StatsViaWriteKeyResponse: {
            /** @constant */
            ok: true;
            data: {
                scope: components["schemas"]["StatsScope"];
                counts: components["schemas"]["StatsCounts"];
                activity: components["schemas"]["StatsActivity"];
            };
        };
        StatsErrorResponse: {
            /** @constant */
            ok?: false;
            error?: {
                /** @enum {string} */
                code?: "INVALID_KEY" | "KEY_EXPIRED" | "KEY_REVOKED" | "PERMISSION_DENIED";
            };
        };
        FileStatsResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Total number of appends on this file */
                appendCount: number;
                taskStats: components["schemas"]["TaskStats"];
            };
        };
        WorkspaceStatsResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Total number of files in workspace */
                fileCount: number;
                /** @description Total number of folders in workspace */
                folderCount: number;
                /** @description Total size of all files in bytes */
                totalSize: number;
                /** @description Total number of appends across all files */
                appendCount: number;
                taskStats: components["schemas"]["TaskStats"];
                /** @description Storage used in bytes */
                storageUsed: number;
                /** @description Storage limit in bytes */
                storageLimit: number;
            };
        };
        /**
         * @description Status of an async job
         * @enum {string}
         */
        JobStatus: "pending" | "processing" | "completed" | "failed";
        /** @description Response containing job status and details */
        JobResponse: {
            /** @constant */
            ok: true;
            data: {
                /**
                 * @description Unique job identifier
                 * @example job_xyz
                 */
                id: string;
                status: components["schemas"]["JobStatus"];
                /** @description Progress information (for processing jobs) */
                progress?: {
                    /** @description Items processed so far */
                    current?: number;
                    /** @description Total items to process */
                    total?: number;
                    /** @description Human-readable progress message */
                    message?: string;
                };
                /** @description Job result data (for completed jobs) */
                result?: {
                    [key: string]: unknown;
                };
                /** @description Error details (for failed jobs) */
                error?: {
                    code?: string;
                    message?: string;
                };
                /**
                 * Format: date-time
                 * @description Job creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: date-time
                 * @description Job completion timestamp (optional)
                 */
                completedAt?: string;
            };
        };
        ExportJobCreateResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Export job identifier */
                jobId: string;
                /** @enum {string} */
                status: "queued" | "processing";
                /** @description URL to poll for job status */
                statusUrl: string;
                /** @description Estimated export size */
                estimatedSize?: string;
                /** @description Position in queue (if queued) */
                position?: number;
            };
        };
        ExportJobStatusResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description Export job identifier */
                id: string;
                /** @enum {string} */
                status: "queued" | "processing" | "ready" | "failed" | "expired";
                progress?: {
                    filesProcessed?: number;
                    totalFiles?: number;
                    bytesWritten?: string;
                };
                /** Format: date-time */
                startedAt?: string;
                /** @description URL to download export (only when status is ready) */
                downloadUrl?: string;
                /**
                 * Format: date-time
                 * @description When the download URL expires
                 */
                expiresAt?: string;
                /** @description SHA-256 checksum (only when status is ready) */
                checksum?: string;
                /** @description Final export size (only when status is ready) */
                size?: string;
                /** @description Error details (only when status is failed) */
                error?: {
                    code?: string;
                    message?: string;
                };
            };
        };
        DeletedFileEntry: {
            /** @description File identifier */
            id: string;
            /** @description Original file path */
            path: string;
            /**
             * Format: date-time
             * @description When the file was deleted
             */
            deletedAt: string;
            /**
             * Format: date-time
             * @description When the file becomes unrecoverable
             */
            expiresAt: string;
            /** @description Author who deleted the file (if known) */
            deletedBy?: string;
            /** @description File size in bytes */
            size?: number;
        };
        DeletedFilesListResponse: {
            /** @constant */
            ok: true;
            data: {
                files: components["schemas"]["DeletedFileEntry"][];
            };
            pagination?: {
                cursor?: string;
                hasMore?: boolean;
                total?: number;
            };
        };
        /** @description Current liveness state of an agent */
        AgentLiveness: {
            /** @description Agent identifier */
            author: string;
            status: components["schemas"]["HeartbeatStatus"];
            /**
             * Format: date-time
             * @description Last heartbeat timestamp
             */
            lastSeen: string;
            /** @description Whether agent is considered stale */
            stale?: boolean;
            /** @description Currently active task reference (optional) */
            currentTask?: string;
            /** @description Additional agent metadata (optional) */
            metadata?: {
                [key: string]: unknown;
            };
        };
        /** @description Response containing agent liveness information */
        AgentLivenessResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description List of agents with their liveness status */
                agents: components["schemas"]["AgentLiveness"][];
                /**
                 * @description Seconds after which an agent is considered stale
                 * @example 30
                 */
                staleThresholdSeconds: number;
                /**
                 * Format: uri
                 * @description URL to view agents in the web interface
                 */
                webUrl?: string;
            };
        };
        OrchestrationSummary: {
            pending: number;
            claimed: number;
            completed: number;
            stalled: number;
            cancelled: number;
        };
        OrchestrationTask: {
            /** @description Task append ID */
            id: string;
            file: {
                id: string;
                path: string;
            };
            /** @description Task content/description */
            content: string;
            /** @description Task creator */
            author: string;
            /**
             * @description Current orchestration status for this task
             * @enum {string}
             */
            status: "pending" | "claimed" | "stalled" | "completed" | "cancelled";
            /** @enum {string} */
            priority?: "low" | "medium" | "high" | "critical";
            labels?: string[];
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            due?: string;
            /** @description Current claim info (if claimed) */
            claim?: {
                id?: string;
                author?: string;
                /** Format: date-time */
                expiresAt?: string;
                blocked?: boolean;
                blockReason?: string;
            };
        };
        OrchestrationClaim: {
            /** @description Claim append ID */
            id: string;
            /** @description Task being claimed */
            taskId: string;
            file: {
                id: string;
                path: string;
            };
            /** @description Claiming agent */
            author: string;
            /** Format: date-time */
            expiresAt: string;
            expiresInSeconds?: number;
            /** @enum {string} */
            status: "active" | "blocked" | "expired";
            blocked?: boolean;
            blockReason?: string;
        };
        OrchestrationAgentStatus: {
            author?: string;
            /** @enum {string} */
            status?: "alive" | "idle" | "busy" | "stale";
            /** Format: date-time */
            lastSeen?: string;
            currentTask?: string;
        };
        OrchestrationWorkload: {
            activeClaims?: number;
            completedToday?: number;
        };
        OrchestrationReadOnlyResponse: {
            /** @constant */
            ok: true;
            data: {
                summary: components["schemas"]["OrchestrationSummary"];
                /** @description Flat orchestration tasks list; group by task.status in consumers */
                tasks: components["schemas"]["OrchestrationTask"][];
                /** @description Active claims across all files */
                claims: components["schemas"]["OrchestrationClaim"][];
                /** @description Agent liveness status */
                agents: components["schemas"]["OrchestrationAgentStatus"][];
                /** @description Workload distribution across agents */
                workload: {
                    [key: string]: components["schemas"]["OrchestrationWorkload"];
                };
                pagination?: {
                    cursor?: string;
                    hasMore?: boolean;
                };
                /**
                 * Format: uri
                 * @description URL to view orchestration in the web interface
                 */
                webUrl?: string;
            };
        };
        OrchestrationAdminResponse: {
            /** @constant */
            ok: true;
            data: {
                summary: components["schemas"]["OrchestrationSummary"];
                /** @description Flat orchestration tasks list; group by task.status in consumers */
                tasks: components["schemas"]["OrchestrationTask"][];
                /** @description Active claims with write-level actions */
                claims: (components["schemas"]["OrchestrationClaim"] & {
                    /**
                     * @description Whether this claim can be force-expired
                     * @constant
                     */
                    canForceExpire?: true;
                })[];
                agents: components["schemas"]["OrchestrationAgentStatus"][];
                workload: {
                    [key: string]: components["schemas"]["OrchestrationWorkload"];
                };
                pagination?: {
                    cursor?: string;
                    hasMore?: boolean;
                };
                /**
                 * Format: uri
                 * @description URL to view orchestration in the web interface
                 */
                webUrl?: string;
            };
        };
        RenewClaimRequest: {
            /**
             * @description New TTL in seconds (default 300)
             * @default 300
             */
            expiresInSeconds: number;
        };
        /** @description Claim data formatted for control view display */
        ControlClaim: {
            /** @description Claim append ID */
            id: string;
            /** @description The task being claimed */
            taskId: string;
            /** @description Task title/content preview for display */
            taskTitle?: string;
            /** @description File path where the task lives */
            path: string;
            /** @description Append capability key for the file (for direct append access) */
            appendKey?: string;
            /** @description Claiming agent/user */
            author: string;
            /**
             * @description Current claim status
             * @enum {string}
             */
            status: "active" | "expired" | "completed" | "cancelled" | "blocked";
            /**
             * Format: date-time
             * @description When the claim was created
             */
            claimedAt?: string;
            /**
             * Format: date-time
             * @description When the claim expires
             */
            expiresAt: string;
            /** @description Seconds until expiry (convenience field) */
            expiresInSeconds?: number;
            /**
             * Format: date-time
             * @description When the task was completed (if completed)
             */
            completedAt?: string;
            /** @description Why the claim is blocked (if blocked) */
            blockedReason?: string;
        };
        ClaimMutationResponse: {
            /** @constant */
            ok: true;
            data: {
                claim: components["schemas"]["ControlClaim"];
                /** @description ID of the append created by this mutation */
                appendId?: string;
                /**
                 * Format: uri
                 * @description URL to view claims in the web interface
                 */
                webUrl?: string;
            };
        };
        CompleteClaimRequest: {
            /** @description Completion message/content */
            content?: string;
        };
        CancelClaimRequest: {
            /** @description Why the claim is being cancelled */
            reason?: string;
        };
        BlockClaimRequest: {
            /** @description Why the claim is blocked */
            reason: string;
        };
        FileCreateResponse: {
            /** @constant */
            ok: true;
            data: {
                /** @description File ID */
                id: string;
                /** @description Full file path */
                path: string;
                urls: components["schemas"]["CapabilityUrls"];
                /**
                 * Format: date-time
                 * @description Creation timestamp
                 */
                createdAt: string;
                /**
                 * Format: uri
                 * @description URL to view this file in the web app
                 */
                webUrl?: string;
            };
        };
        /** @description Simple health check response for liveness probes */
        HealthCheckSimpleResponse: {
            /** @constant */
            ok: true;
            /**
             * @description Always "healthy" when responding
             * @enum {string}
             */
            status: "healthy";
            /**
             * Format: date-time
             * @description Current server time
             */
            timestamp?: string;
            /** @description Server uptime in seconds */
            uptimeSeconds?: number;
            /**
             * @description API version
             * @example 0.1.0
             */
            version?: string;
        };
        /**
         * @description Type of changelog entry
         * @enum {string}
         */
        ChangeType: "added" | "changed" | "deprecated" | "removed" | "fixed" | "security";
        /** @description Single changelog entry */
        ChangelogEntry: {
            /**
             * @description Version number
             * @example 1.2.0
             */
            version: string;
            /**
             * Format: date
             * @description Release date
             * @example 2024-01-15
             */
            date: string;
            /** @description List of changes in this version */
            changes: {
                type: components["schemas"]["ChangeType"];
                /** @description Change description */
                description: string;
            }[];
        };
        /** @description Response containing changelog entries */
        ChangelogResponse: {
            /** @constant */
            ok: true;
            data: {
                /**
                 * @description Current API version
                 * @example 1.5.2
                 */
                currentVersion: string;
                /**
                 * Format: date-time
                 * @description Release date of current version
                 * @example 2025-12-15T00:00:00Z
                 */
                releasedAt: string;
                /** @description List of changelog entries (newest first) */
                entries: components["schemas"]["ChangelogEntry"][];
            };
        };
        /** @description Status of a deployment region */
        RegionStatus: {
            /**
             * @description Region name
             * @example us-east-1
             */
            name: string;
            /**
             * @description Region status
             * @enum {string}
             */
            status: "operational" | "degraded" | "down";
        };
        /** @description Response from status endpoint with system information */
        StatusResponse: {
            /** @constant */
            ok: true;
            data: {
                /**
                 * @description Overall service status
                 * @enum {string}
                 */
                status: "operational" | "degraded" | "partial_outage" | "major_outage";
                /**
                 * Format: date-time
                 * @description Current server time in ISO-8601 format
                 */
                timestamp: string;
                /**
                 * @description Runtime environment
                 * @enum {string}
                 */
                environment: "development" | "test" | "production";
                /** @description Server uptime in seconds */
                uptimeSeconds: number;
                /**
                 * @description API version
                 * @example 0.1.0
                 */
                version: string;
                /** @description Database status */
                database: {
                    /**
                     * @description Database status
                     * @enum {string}
                     */
                    status: "operational" | "degraded" | "down";
                    /** @description Database latency in milliseconds */
                    latencyMs?: number;
                };
                /** @description Storage status */
                storage: {
                    /**
                     * @description Storage service status
                     * @enum {string}
                     */
                    status: "operational" | "degraded" | "down";
                    /** @description Storage check latency in milliseconds */
                    latencyMs?: number;
                };
                /** @description WebSocket subsystem status */
                websocket: {
                    /**
                     * @description WebSocket service status
                     * @enum {string}
                     */
                    status: "operational" | "degraded" | "down";
                    /** @description WebSocket check latency in milliseconds */
                    latencyMs?: number;
                    /** @description Number of active WebSocket connections */
                    activeConnections?: number;
                };
                /** @description Available regions and their status */
                regions: components["schemas"]["RegionStatus"][];
            };
        };
        CapabilityCheckInWorkspaceResult: {
            /** @description Truncated key (first 8 chars + "...") */
            key: string;
            /** @description Whether the key is valid */
            valid: boolean;
            /**
             * @description Permission level (only present if valid)
             * @enum {string}
             */
            permission?: "read" | "append" | "write";
            /**
             * @description Scope type (only present if valid)
             * @enum {string}
             */
            scope?: "file" | "folder" | "workspace";
            /** @description Workspace, folder, or file ID (only present if valid) */
            scopeId?: string;
            /** @description Resource path (only present if valid and belongs to workspace) */
            path?: string;
            /**
             * @description Key status (only present if valid and belongs to workspace)
             * @enum {string}
             */
            status?: "active" | "expired" | "revoked";
            /** @description Error code (NOT_FOUND, EXPIRED, REVOKED) - only present if invalid */
            error?: string;
        };
        CapabilitiesCheckInWorkspaceResponse: {
            /** @constant */
            ok: true;
            data: {
                results: components["schemas"]["CapabilityCheckInWorkspaceResult"][];
            };
        };
        AuditLogEntry: {
            /** @description Unique audit log ID */
            id: string;
            /** @description The action that was performed */
            action: string;
            /** @description Type of resource affected */
            resourceType: string;
            /** @description ID of the affected resource */
            resourceId?: string;
            /** @description Path of the affected resource */
            resourcePath?: string;
            /** @description Actor who performed the action */
            actor?: string;
            /**
             * @description Type of actor
             * @enum {string}
             */
            actorType?: "capability_url" | "api_key" | "session";
            /** @description Additional action-specific metadata */
            metadata?: {
                [key: string]: unknown;
            };
            /** @description IP address of the request */
            ipAddress?: string;
            /** @description User agent of the request */
            userAgent?: string;
            /**
             * Format: date-time
             * @description When the action occurred
             */
            createdAt: string;
        };
        AuditLogPagination: {
            /** @description Total number of matching logs */
            total: number;
            /** @description Maximum logs per page */
            limit: number;
            /** @description Cursor for next page (opaque), null when no more results */
            cursor: string | null;
            /** @description Whether more results are available */
            hasMore: boolean;
        };
        AuditLogsResponse: {
            /** @constant */
            ok: true;
            data: components["schemas"]["AuditLogEntry"][];
            pagination: components["schemas"]["AuditLogPagination"];
        };
        AdminMetricsResponse: {
            /** @enum {boolean} */
            ok: true;
            data: {
                storage: {
                    /** @description Current database file size in bytes */
                    databaseSizeBytes: number;
                    /**
                     * Format: float
                     * @description Current database file size in megabytes
                     */
                    databaseSizeMB: number;
                    /** @description Maximum allowed database size (from config or volume) */
                    maxSizeBytes?: number;
                    /**
                     * Format: float
                     * @description Maximum allowed database size in megabytes
                     */
                    maxSizeMB?: number;
                    /**
                     * Format: float
                     * @description Percentage of storage used (0-100)
                     */
                    usagePercent: number;
                };
                counts: {
                    /** @description Total number of workspaces (excluding deleted) */
                    workspaces: number;
                    /** @description Total number of files (excluding deleted) */
                    files: number;
                    /** @description Total number of folders (excluding deleted) */
                    folders: number;
                    /** @description Total number of registered users */
                    users: number;
                    /** @description Number of active user sessions */
                    activeSessions: number;
                    /** @description Total number of capability keys (excluding revoked) */
                    capabilityKeys: number;
                };
                quotas: {
                    /** @description Maximum storage per workspace in bytes */
                    maxWorkspaceStorageBytes: number;
                    /** @description Maximum file size in bytes */
                    maxFileSizeBytes: number;
                };
                uptime: {
                    /** @description Server uptime in seconds */
                    seconds: number;
                    /** @description Human-readable uptime (e.g., "1d 2h 30m") */
                    formatted: string;
                };
            };
        };
        FolderUrls: {
            /** @description Folder path */
            path: string;
            urls: components["schemas"]["CapabilityUrls"];
        };
        /** @description User information */
        User: {
            /** @description User ID */
            id: string;
            /**
             * Format: email
             * @description User email address
             */
            email: string;
            /**
             * Format: date-time
             * @description Account creation timestamp
             */
            createdAt?: string;
        };
        /** @description Request to claim a workspace (OAuth session provides identity) */
        ClaimWorkspaceRequest: Record<string, never>;
        /**
         * @description Type of WebSocket message type
         * @enum {string}
         */
        SubscribeMessageType: "connected" | "error";
        /** @description WebSocket control message */
        SubscribeMessage: {
            type: components["schemas"]["SubscribeMessageType"];
            /** @description Control message payload (structure varies by type) */
            data: {
                [key: string]: unknown;
            };
        };
        /**
         * @description Overall system health status
         * @enum {string}
         */
        HealthStatus: "healthy" | "degraded" | "unhealthy";
        /** @description Response from health check endpoint */
        HealthResponse: {
            /** @constant */
            ok: true;
            status: components["schemas"]["HealthStatus"];
            /**
             * @description API version
             * @example 1.0.0
             */
            version: string;
            /** @description Individual health check results */
            checks: {
                [key: string]: {
                    status?: components["schemas"]["HealthStatus"];
                    /** @description Check latency in milliseconds */
                    latencyMs?: number;
                    /** @description Additional status message */
                    message?: string;
                };
            };
        };
        TransferWorkspaceRequest: {
            /**
             * Format: email
             * @description Email of the new owner (must have an OAuth account)
             * @example new-owner@example.com
             */
            newOwnerEmail: string;
        };
        FolderClaimEntry: {
            id: string;
            fileId: string;
            path: string;
            taskId: string;
            taskContent?: string;
            /** @description Author who made the claim */
            author: string;
            /** Format: date-time */
            expiresAt: string;
            expiresInSeconds?: number;
            /** @enum {string} */
            status: "active" | "blocked" | "expired";
            /** Format: date-time */
            blockedAt?: string;
            blockReason?: string;
        };
        FolderClaimsViaAppendKeyResponse: {
            /** @constant */
            ok: true;
            data: {
                claims: components["schemas"]["FolderClaimEntry"][];
                count: number;
                /**
                 * Format: uri
                 * @description URL to view claims in the web interface
                 */
                webUrl?: string;
            };
        };
        ListWorkspaceClaimsResponse: {
            /** @constant */
            ok: true;
            data: {
                claims: components["schemas"]["ControlClaim"][];
                /**
                 * Format: uri
                 * @description URL to view claims in the web interface
                 */
                webUrl?: string;
            };
        };
    };
    responses: {
        /** @description Invalid request */
        BadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "INVALID_REQUEST",
                 *         "message": "Request validation failed",
                 *         "details": {
                 *           "field": "content",
                 *           "reason": "Content exceeds maximum length"
                 *         }
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Resource not found */
        NotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "FILE_NOT_FOUND",
                 *         "message": "File not found"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Resource deleted (recoverable) */
        Gone: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "FILE_DELETED",
                 *         "message": "File is soft-deleted",
                 *         "details": {
                 *           "recoverable": true,
                 *           "expiresAt": "2024-01-15T11:00:00Z"
                 *         }
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Rate limit exceeded */
        RateLimited: {
            headers: {
                /** @description Seconds to wait before retrying */
                "Retry-After"?: number;
                /** @description Request limit per window */
                "X-RateLimit-Limit"?: number;
                /** @description Remaining requests in current window */
                "X-RateLimit-Remaining"?: number;
                /** @description Unix timestamp when limit resets */
                "X-RateLimit-Reset"?: number;
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "RATE_LIMITED",
                 *         "message": "Too many requests",
                 *         "details": {
                 *           "retryAfterSeconds": 60
                 *         }
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Authentication required */
        Unauthorized: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "UNAUTHORIZED",
                 *         "message": "Authentication required"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Conflict (e.g., concurrent edit, already claimed) */
        Conflict: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "CONFLICT",
                 *         "message": "File was modified since last read",
                 *         "details": {
                 *           "currentEtag": "x9y0z1a2",
                 *           "providedEtag": "a1b2c3d4"
                 *         }
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Permission denied */
        Forbidden: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "PERMISSION_DENIED",
                 *         "message": "You do not have permission to access this resource"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Internal server error */
        ServerError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "SERVER_ERROR",
                 *         "message": "Internal server error"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Request payload exceeds size limit */
        PayloadTooLarge: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "ok": false,
                 *       "error": {
                 *         "code": "PAYLOAD_TOO_LARGE",
                 *         "message": "Request body exceeds maximum size of 10MB",
                 *         "details": {
                 *           "maxSize": 10485760,
                 *           "receivedSize": 15728640
                 *         }
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["Error"];
            };
        };
    };
    parameters: {
        /** @description Capability key (20+ chars, base62 with underscore) */
        capabilityKey: string;
        /** @description Response format */
        format: "raw" | "parsed" | "structure";
        /** @description Return items modified after this timestamp (ISO 8601) */
        since: string;
        /** @description Append identifier (e.g., a1, a42) */
        appendId: string;
        /** @description URL-encoded folder path */
        folderPath: string;
        /** @description Maximum number of items to return */
        limit: number;
        /** @description Pagination cursor for fetching next page */
        cursor: string;
        /** @description URL-encoded folder path (omit for workspace root) */
        folderPathQuery: string;
        /** @description Filter by author identifier */
        author: string;
        /** @description Scoped key identifier */
        keyId: string;
        /** @description Workspace identifier */
        workspaceId: string;
        /** @description Webhook identifier */
        webhookId: string;
        /** @description Background job identifier */
        jobId: string;
        /**
         * @description The claim's append ID
         * @example a_x8k2mP9qL3nR7mQ2pN4x
         */
        claimId: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    createWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Required workspace bootstrap configuration */
        requestBody: {
            content: {
                "application/json": components["schemas"]["BootstrapRequest"];
            };
        };
        responses: {
            /** @description Workspace created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "workspaceId": "ws_x8k2mP9qL3nR",
                     *         "keys": {
                     *           "read": "m7dXp9lKa2nQe4R8vL5wYt",
                     *           "append": "a_nK3pL9mQ2xR8vL5wYt",
                     *           "write": "w_vT5yU8wX1zA4vL5wYt"
                     *         },
                     *         "urls": {
                     *           "api": {
                     *             "read": "https://api.mdplane.dev/r/m7dXp9lKa2nQe4R8vL5wYt",
                     *             "append": "https://api.mdplane.dev/a/a_nK3pL9mQ2xR8vL5wYt",
                     *             "write": "https://api.mdplane.dev/w/w_vT5yU8wX1zA4vL5wYt"
                     *           },
                     *           "web": {
                     *             "read": "https://app.mdplane.dev/r/m7dXp9lKa2nQe4R8vL5wYt",
                     *             "claim": "https://app.mdplane.dev/claim/w_vT5yU8wX1zA4vL5wYt"
                     *           }
                     *         },
                     *         "createdAt": "2024-01-08T09:00:00Z"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["BootstrapResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    /** @description Seconds to wait before retrying */
                    "Retry-After"?: number;
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "RATE_LIMITED",
                     *         "message": "Too many workspace creation requests. Please try again later.",
                     *         "details": {
                     *           "retryAfterSeconds": 3600
                     *         }
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    readFile: {
        parameters: {
            query?: {
                /** @description Response format */
                format?: components["parameters"]["format"];
                /** @description Return items modified after this timestamp (ISO 8601) */
                since?: components["parameters"]["since"];
                /** @description Number of recent appends to include */
                appends?: number;
                /** @description Include additional data (e.g., stats) */
                include?: "stats";
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File content retrieved successfully */
            200: {
                headers: {
                    /** @description Content version hash for optimistic concurrency */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileReadResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    readFileViaWriteKey: {
        parameters: {
            query?: {
                /** @description Response format */
                format?: components["parameters"]["format"];
                /** @description Return items modified after this timestamp (ISO 8601) */
                since?: components["parameters"]["since"];
                /** @description Number of recent appends to include */
                appends?: number;
                /** @description Include additional data (e.g., stats) */
                include?: "stats";
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File content retrieved successfully */
            200: {
                headers: {
                    /** @description Content version hash for optimistic concurrency */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileReadResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    updateFile: {
        parameters: {
            query?: never;
            header?: {
                /** @description ETag from previous read for optimistic concurrency */
                "If-Match"?: string;
            };
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FileUpdateRequest"];
            };
        };
        responses: {
            /** @description File updated successfully */
            200: {
                headers: {
                    /** @description New content version hash */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileUpdateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
            410: components["responses"]["Gone"];
            /** @description ETag mismatch - file was modified since last read */
            412: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    deleteFile: {
        parameters: {
            query?: {
                /** @description Hard delete (irreversible) */
                permanent?: boolean;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileDeleteResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    renameFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FileRenameRequest"];
            };
        };
        responses: {
            /** @description File renamed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileRenameResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    readFileRaw: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Raw markdown content */
            200: {
                headers: {
                    /** @description Content version hash */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "text/markdown": string;
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    readFileMeta: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File metadata retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileMetaResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    readFileTail: {
        parameters: {
            query?: {
                /** @description Last N bytes to return (default 10000, max 100000) */
                bytes?: number;
                /** @description Last N lines to return (approximate) */
                lines?: number;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Tail content retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileTailResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    readFileStructure: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File structure retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileStructureResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    readFileSection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description Heading text to find (URL-encoded) */
                heading: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Section content retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileSectionResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    readAppend: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description Append identifier (e.g., a1, a42) */
                appendId: components["parameters"]["appendId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Append retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppendGetResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    recoverFile: {
        parameters: {
            query?: {
                /** @description Generate new capability URLs (invalidates old ones) */
                rotateUrls?: boolean;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File recovered successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileRecoverResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    moveFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FileMoveRequest"];
            };
        };
        responses: {
            /** @description File moved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileMoveResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    rotateCapabilityUrls: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description URLs rotated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileRotateUrlsResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    getFileSettings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File settings retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileSettingsResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    updateFileSettings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FileSettingsUpdateRequest"];
            };
        };
        responses: {
            /** @description File settings updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileSettingsResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    createAppend: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AppendRequest"] | components["schemas"]["MultiAppendRequest"];
            };
        };
        responses: {
            /** @description Append created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppendResponse"];
                };
            };
            /**
             * @description Invalid request. Possible error codes:
             *     - `INVALID_APPEND_TYPE`: Unknown type value
             *     - `INVALID_REF`: ref points to wrong append type or doesn't exist
             *     - `INVALID_VOTE_VALUE`: vote type with value other than +1 or -1
             *     - `INVALID_AUTHOR`: Author field fails validation
             *     - `TASK_ALREADY_COMPLETE`: Trying to claim a completed task
             *     - `TASK_CANCELLED`: Trying to claim, respond to, or renew a cancelled task
             *     - `CLAIM_EXPIRED`: Trying to renew, respond to, or mark blocked a claim that has expired
             *     - `AUTHOR_MISMATCH`: Append author doesn't match key's boundAuthor
             *     - `TYPE_NOT_ALLOWED`: Append type not in key's allowedTypes
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            404: components["responses"]["NotFound"];
            /**
             * @description Conflict. Possible error codes:
             *     - `ALREADY_CLAIMED`: Task already has active claim
             */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            410: components["responses"]["Gone"];
            /**
             * @description Rate limited. Possible error codes:
             *     - `RATE_LIMITED`: Too many requests
             *     - `WIP_LIMIT_EXCEEDED`: Author at max concurrent claims
             *     - `AUTHOR_RATE_LIMITED`: Author exceeded per-file or per-workspace append limit
             */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createScopedAppend: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /**
                 * @description Path to the file within the workspace (relative to scopePath if set)
                 * @example tasks/backlog.md
                 */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ScopedAppendRequest"];
            };
        };
        responses: {
            /** @description Append created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "appendId": "a1704700200000",
                     *         "type": "comment",
                     *         "author": "agent-01",
                     *         "createdAt": "2024-01-08T10:30:00Z"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["ScopedAppendResponse"];
                };
            };
            /**
             * @description Invalid request. Possible error codes:
             *     - `AUTHOR_MISMATCH`: Author does not match key's boundAuthor
             *     - `TYPE_NOT_ALLOWED`: Append type not in key's allowedTypes
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /**
             * @description Not found. Possible error codes:
             *     - `KEY_NOT_FOUND`: Invalid capability key
             *     - `FILE_NOT_FOUND`: File does not exist at the specified path
             *     - `PERMISSION_DENIED`: Path outside of key's scopePath
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listFolderContents: {
        parameters: {
            query?: {
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
                /**
                 * @description Special action to perform. When set to `export`, returns folder contents as
                 *     a downloadable archive instead of JSON listing.
                 */
                action?: "export";
                /** @description Archive format (only used when action=export) */
                format?: "zip" | "tar.gz";
                /** @description Include all nested contents recursively */
                recursive?: boolean;
                /** @description Sort field */
                sort?: "name" | "modified" | "size";
                /** @description Sort order */
                order?: "asc" | "desc";
                /** @description Include append history in export metadata (only used when action=export) */
                includeAppends?: boolean;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /**
             * @description Folder contents retrieved successfully.
             *
             *     When `action=export`, returns binary archive with Content-Disposition header.
             */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderListResponse"];
                    "application/zip": string;
                    "application/gzip": string;
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    listFolderContentsViaAppendKey: {
        parameters: {
            query?: {
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
                /** @description Include all nested contents recursively */
                recursive?: boolean;
                /** @description Sort field */
                sort?: "name" | "modified" | "size";
                /** @description Sort order */
                order?: "asc" | "desc";
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Folder contents retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderListResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    createFileInFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateFileRequest"];
            };
        };
        responses: {
            /** @description File created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateFileResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
            429: components["responses"]["RateLimited"];
        };
    };
    listFolderContentsViaWriteKey: {
        parameters: {
            query?: {
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
                /** @description Include all nested contents recursively */
                recursive?: boolean;
                /** @description Sort field */
                sort?: "name" | "modified" | "size";
                /** @description Sort order */
                order?: "asc" | "desc";
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Folder contents retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderListResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    deleteFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["FolderDeleteRequest"];
            };
        };
        responses: {
            /** @description Folder deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderDeleteResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            /** @description Folder not empty (use cascade delete) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    renameFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FolderRenameRequest"];
            };
        };
        responses: {
            /** @description Folder renamed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderMoveResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
            429: components["responses"]["RateLimited"];
        };
    };
    createFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FolderCreateRequest"];
            };
        };
        responses: {
            /** @description Folder created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderCreateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            409: components["responses"]["Conflict"];
            429: components["responses"]["RateLimited"];
        };
    };
    copyFileToFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CopyFileToFolderRequest"];
            };
        };
        responses: {
            /** @description File copied successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateFileResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
            429: components["responses"]["RateLimited"];
        };
    };
    bulkCreateFiles: {
        parameters: {
            query?: {
                /** @description Return immediately with job ID for async processing */
                async?: boolean;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FolderBulkCreateRequest"];
            };
        };
        responses: {
            /** @description Files created successfully (sync mode) */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderBulkCreateResponse"];
                };
            };
            /** @description Job accepted (async mode) */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderBulkCreateJobResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    moveFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FolderMoveRequest"];
            };
        };
        responses: {
            /** @description Folder moved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderMoveResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
            429: components["responses"]["RateLimited"];
        };
    };
    getFolderSettings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Folder settings retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderSettingsResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    updateFolderSettings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FolderSettingsUpdateRequest"];
            };
        };
        responses: {
            /** @description Folder settings updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderSettingsResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    getFolderStats: {
        parameters: {
            query?: {
                /** @description URL-encoded folder path (omit for workspace root) */
                path?: components["parameters"]["folderPathQuery"];
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Folder statistics retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderStatsResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    searchInFolder: {
        parameters: {
            query?: {
                /** @description URL-encoded folder path (omit for workspace root) */
                path?: components["parameters"]["folderPathQuery"];
                /** @description Full-text search query */
                q?: string;
                /** @description Filter by append type */
                type?: "task" | "comment" | "response" | "claim";
                /** @description Filter by task status (comma-separated for multiple) */
                status?: "pending" | "claimed" | "completed" | "failed";
                /** @description Filter by author identifier */
                author?: components["parameters"]["author"];
                /** @description Filter by labels (comma-separated, OR matching) */
                labels?: string;
                /** @description Filter by priority (comma-separated for multiple) */
                priority?: string;
                /** @description Modified after this date (ISO 8601) */
                since?: string;
                /** @description Max search duration (default 5s, max 30s) */
                timeout?: string;
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Search results */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderSearchResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    queryFolderTasks: {
        parameters: {
            query?: {
                /** @description URL-encoded folder path (omit for workspace root) */
                path?: components["parameters"]["folderPathQuery"];
                /** @description Filter by task status (comma-separated for multiple) */
                status?: "pending" | "claimed" | "completed" | "cancelled";
                /** @description Filter by author identifier */
                author?: components["parameters"]["author"];
                /** @description Filter by priority (comma-separated for multiple) */
                priority?: string;
                /** @description Filter by labels (comma-separated, OR matching) */
                labels?: string;
                /** @description Filter by claiming agent identifier */
                claimedBy?: string;
                /** @description Only return unclaimed tasks when true */
                claimable?: boolean;
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Tasks retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TaskQueryResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    subscribeFolderEvents: {
        parameters: {
            query?: {
                /** @description URL-encoded folder path (omit for workspace root) */
                path?: components["parameters"]["folderPathQuery"];
                /** @description Include append events for files in folder */
                includeAppends?: boolean;
                /** @description Include events from nested subfolders */
                recursive?: boolean;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description WebSocket connection established (Switching Protocols) */
            101: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebSocket upgrade successful (for OpenAPI compliance) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
        };
    };
    subscribeFolderEventsViaAppendKey: {
        parameters: {
            query?: {
                /** @description URL-encoded folder path (omit for workspace root) */
                path?: components["parameters"]["folderPathQuery"];
                /** @description Include append events for files in folder */
                includeAppends?: boolean;
                /** @description Include events from nested subfolders */
                recursive?: boolean;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description WebSocket connection established (Switching Protocols) */
            101: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebSocket upgrade successful (for OpenAPI compliance) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
        };
    };
    subscribeFolderEventsViaWriteKey: {
        parameters: {
            query?: {
                /** @description URL-encoded folder path (omit for workspace root) */
                path?: components["parameters"]["folderPathQuery"];
                /** @description Include append events for files in folder */
                includeAppends?: boolean;
                /** @description Include events from nested subfolders */
                recursive?: boolean;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description WebSocket connection established (Switching Protocols) */
            101: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebSocket upgrade successful (for OpenAPI compliance) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
        };
    };
    listFolderWebhooks: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhooks retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookListResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    createFolderWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCreateRequest"];
            };
        };
        responses: {
            /** @description Webhook created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookCreateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            /** @description Webhook limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteFolderWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
                /** @description Webhook ID to delete */
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookDeleteResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    updateFolderWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
                /** @description Webhook ID to update */
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookUpdateRequest"];
            };
        };
        responses: {
            /** @description Webhook updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookUpdateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    listFolderClaims: {
        parameters: {
            query?: {
                /** @description Filter by author identifier */
                author?: components["parameters"]["author"];
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description URL-encoded folder path */
                path: components["parameters"]["folderPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Claims retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderClaimsResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    listScopedKeys: {
        parameters: {
            query?: {
                /** @description Include revoked keys in the response */
                includeRevoked?: boolean;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Scoped keys retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": [
                     *         {
                     *           "id": "key_1",
                     *           "key": "a_x8k2...nR",
                     *           "permission": "append",
                     *           "boundAuthor": "agent-alpha",
                     *           "displayName": "Alpha Research Agent",
                     *           "wipLimit": 2,
                     *           "createdAt": "2024-01-10T10:00:00Z",
                     *           "lastUsedAt": "2024-01-10T11:30:00Z"
                     *         }
                     *       ]
                     *     }
                     */
                    "application/json": components["schemas"]["ScopedKeyListResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    createScopedKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "permission": "append",
                 *       "boundAuthor": "agent-alpha",
                 *       "displayName": "Alpha Research Agent",
                 *       "wipLimit": 2,
                 *       "allowedTypes": [
                 *         "claim",
                 *         "response"
                 *       ],
                 *       "expiresAt": "2024-02-01T00:00:00Z"
                 *     }
                 */
                "application/json": components["schemas"]["ScopedKeyCreateRequest"];
            };
        };
        responses: {
            /** @description Scoped key created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "id": "key_abc123def456",
                     *         "key": "a_x8k2mP9qL3nR7mQ2pN4x",
                     *         "permission": "append",
                     *         "boundAuthor": "agent-alpha",
                     *         "displayName": "Alpha Research Agent",
                     *         "wipLimit": 2,
                     *         "allowedTypes": [
                     *           "claim",
                     *           "response"
                     *         ],
                     *         "expiresAt": "2024-02-01T00:00:00Z",
                     *         "createdAt": "2024-01-10T10:00:00Z"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["ScopedKeyCreateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    revokeScopedKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description Scoped key identifier */
                keyId: components["parameters"]["keyId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Scoped key revoked successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "id": "key_1",
                     *         "revoked": true
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["KeyRevokeResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    checkCapabilities: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "keys": [
                 *         "keyX8k2mP9qL3nR7mQ2pN4",
                 *         "a_x8k2mP9qL3nR7mQ2pN4x"
                 *       ]
                 *     }
                 */
                "application/json": components["schemas"]["CapabilitiesCheckRequest"];
            };
        };
        responses: {
            /** @description Capabilities checked */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "results": [
                     *           {
                     *             "key": "keyX8k2m...",
                     *             "valid": true,
                     *             "permission": "write",
                     *             "scope": "workspace",
                     *             "scopeId": "ws_123"
                     *           },
                     *           {
                     *             "key": "a_x8k2mP...",
                     *             "valid": false,
                     *             "error": "EXPIRED"
                     *           }
                     *         ]
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["CapabilitiesCheckResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
        };
    };
    signInWithGitHub: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OAuth flow initiated (for OpenAPI compliance - actual response is 302 redirect) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            /** @description Redirect to GitHub OAuth */
            302: {
                headers: {
                    /** @description GitHub OAuth authorization URL */
                    Location?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimited"];
        };
    };
    signInWithGoogle: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OAuth flow initiated (for OpenAPI compliance - actual response is 302 redirect) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            /** @description Redirect to Google OAuth */
            302: {
                headers: {
                    /** @description Google OAuth authorization URL */
                    Location?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimited"];
        };
    };
    getCurrentUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User information retrieved */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "id": "user_x8k2mP9qL3nR",
                     *         "email": "user@example.com",
                     *         "name": "Alex Developer",
                     *         "image": "https://avatars.githubusercontent.com/u/12345",
                     *         "workspaces": [
                     *           {
                     *             "id": "ws_x8k2mP9qL3nR",
                     *             "name": "My Project"
                     *           }
                     *         ],
                     *         "createdAt": "2024-01-08T09:00:00Z",
                     *         "webUrl": "https://app.mdplane.dev/control"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["MeResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
        };
    };
    logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Logged out successfully */
            200: {
                headers: {
                    /** @description Clears session cookie */
                    "Set-Cookie"?: string;
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "status": "logged_out"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["LogoutResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
        };
    };
    claimWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {} */
                "application/json": Record<string, never>;
            };
        };
        responses: {
            /** @description Workspace claimed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "workspaceId": "ws_x8k2mP9qL3nR",
                     *         "claimed": true,
                     *         "message": "claimed"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["ClaimWorkspaceResponse"];
                };
            };
            /** @description Workspace already claimed */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "ALREADY_CLAIMED",
                     *         "message": "Workspace is already claimed by another user"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description OAuth session required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "UNAUTHORIZED",
                     *         "message": "OAuth session required. Login via GitHub or Google first."
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    renameWorkspaceViaWriteKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkspaceRenameRequest"];
            };
        };
        responses: {
            /** @description Workspace renamed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkspaceRenameResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            /** @description Key is not allowed to rename workspace */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "FORBIDDEN",
                     *         "message": "Only workspace-scoped write keys can rename workspaces"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    deleteWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Workspace deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "message": "Workspace deleted successfully"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["SuccessResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    renameWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkspaceRenameRequest"];
            };
        };
        responses: {
            /** @description Workspace renamed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkspaceRenameResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    rotateAllUrls: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description All URLs rotated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RotateAllResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    listApiKeys: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description API keys retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "keys": [
                     *           {
                     *             "id": "key_1",
                     *             "name": "CI Pipeline",
                     *             "prefix": "sk_live_x8k2...",
                     *             "permissions": [
                     *               "read",
                     *               "append"
                     *             ],
                     *             "createdAt": "2024-01-08T09:00:00Z",
                     *             "expiresAt": "2025-01-08T09:00:00Z",
                     *             "lastUsedAt": "2024-01-10T14:30:00Z"
                     *           }
                     *         ]
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["ApiKeyListResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    createApiKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "name": "CI Pipeline",
                 *       "permissions": [
                 *         "read",
                 *         "append"
                 *       ],
                 *       "expiresInSeconds": 31536000
                 *     }
                 */
                "application/json": components["schemas"]["ApiKeyCreateRequest"];
            };
        };
        responses: {
            /** @description API key created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "id": "key_1",
                     *         "key": "sk_live_demoKey123",
                     *         "name": "CI Pipeline",
                     *         "permissions": [
                     *           "read",
                     *           "append"
                     *         ],
                     *         "createdAt": "2024-01-08T09:00:00Z",
                     *         "expiresAt": "2025-01-08T09:00:00Z"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["ApiKeyCreateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["ServerError"];
        };
    };
    revokeApiKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
                /** @description Scoped key identifier */
                keyId: components["parameters"]["keyId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description API key revoked successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "id": "key_1",
                     *         "revoked": true
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["ApiKeyRevokeResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    listWebhooks: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhooks retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": [
                     *         {
                     *           "id": "wh_1",
                     *           "url": "https://example.com/webhook",
                     *           "events": [
                     *             "append"
                     *           ],
                     *           "status": "active",
                     *           "lastTriggeredAt": "2024-01-08T10:30:00Z",
                     *           "successRate": 0.98,
                     *           "createdAt": "2024-01-08T09:00:00Z"
                     *         }
                     *       ]
                     *     }
                     */
                    "application/json": components["schemas"]["WebhookListResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    createWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "url": "https://example.com/webhook",
                 *       "events": [
                 *         "append",
                 *         "claim.expired",
                 *         "task.blocked"
                 *       ],
                 *       "secret": "my-secure-secret-at-least-32-chars",
                 *       "includeUrls": false,
                 *       "filters": {
                 *         "types": [
                 *           "task",
                 *           "response"
                 *         ],
                 *         "labels": [
                 *           "urgent"
                 *         ],
                 *         "priority": [
                 *           "high",
                 *           "critical"
                 *         ]
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["WebhookCreateRequest"];
            };
        };
        responses: {
            /** @description Webhook created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "id": "wh_1",
                     *         "url": "https://example.com/webhook",
                     *         "events": [
                     *           "append",
                     *           "claim.expired",
                     *           "task.blocked"
                     *         ],
                     *         "status": "active",
                     *         "createdAt": "2024-01-08T09:00:00Z"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["WebhookCreateResponse"];
                };
            };
            /**
             * @description Invalid request. Possible error codes:
             *     - `INVALID_WEBHOOK_URL`: URL must use HTTPS and resolve to public IP
             *     - `INVALID_REQUEST`: Malformed request body
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            401: components["responses"]["Unauthorized"];
            /** @description Webhook limit exceeded */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "WEBHOOK_LIMIT_EXCEEDED",
                     *         "message": "Free tier allows 3 webhook endpoints per file",
                     *         "details": {
                     *           "current": 3,
                     *           "limit": 3,
                     *           "tier": "free"
                     *         }
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    deleteWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description Webhook identifier */
                webhookId: components["parameters"]["webhookId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "id": "wh_1",
                     *         "deleted": true
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["WebhookDeleteResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    updateWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description Webhook identifier */
                webhookId: components["parameters"]["webhookId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "events": [
                 *         "append",
                 *         "task.blocked"
                 *       ],
                 *       "active": true
                 *     }
                 */
                "application/json": components["schemas"]["WebhookUpdateRequest"];
            };
        };
        responses: {
            /** @description Webhook updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookUpdateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    getWebhookLogs: {
        parameters: {
            query?: {
                /** @description Maximum number of log entries to return */
                limit?: number;
                /** @description Return logs after this timestamp (ISO 8601) */
                since?: string;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description Webhook identifier */
                webhookId: components["parameters"]["webhookId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook logs retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "logs": [
                     *           {
                     *             "id": "log_1",
                     *             "event": "append",
                     *             "status": "ok",
                     *             "responseCode": 200,
                     *             "timestamp": "2024-01-08T10:30:00Z",
                     *             "durationMs": 145
                     *           },
                     *           {
                     *             "id": "log_2",
                     *             "event": "task.blocked",
                     *             "status": "failed",
                     *             "responseCode": 500,
                     *             "timestamp": "2024-01-08T10:25:00Z",
                     *             "durationMs": 2500,
                     *             "error": "Server returned 500 Internal Server Error"
                     *           }
                     *         ]
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["WebhookLogsResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    testWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
                /** @description Webhook identifier */
                webhookId: components["parameters"]["webhookId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /**
                 * @example {
                 *       "event": "append.created"
                 *     }
                 */
                "application/json": components["schemas"]["WebhookTestRequest"];
            };
        };
        responses: {
            /** @description Test webhook delivered (or attempted) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookTestResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    listWorkspaceWebhooks: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhooks retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookListResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    createWorkspaceWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCreateRequest"];
            };
        };
        responses: {
            /** @description Webhook created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookCreateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    deleteWorkspaceWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
                /** @description Webhook identifier */
                webhookId: components["parameters"]["webhookId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookDeleteResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    updateWorkspaceWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
                /** @description Webhook identifier */
                webhookId: components["parameters"]["webhookId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookUpdateRequest"];
            };
        };
        responses: {
            /** @description Webhook updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookUpdateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    testWorkspaceWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
                /** @description Webhook identifier */
                webhookId: components["parameters"]["webhookId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["WebhookTestRequest"];
            };
        };
        responses: {
            /** @description Test delivery attempted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookTestResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    searchInFileViaReadKey: {
        parameters: {
            query?: {
                /** @description Full-text search query */
                q?: string;
                /** @description Filter by append type */
                type?: "task" | "claim" | "response" | "blocked" | "answer" | "renew" | "cancel" | "comment" | "vote";
                /** @description Filter by task status */
                status?: "pending" | "claimed" | "completed" | "cancelled";
                /** @description Filter by author name */
                author?: string;
                /** @description Filter by labels (comma-separated, OR matching) */
                labels?: string;
                /** @description Filter by priority levels (comma-separated) */
                priority?: string;
                /** @description Return results after this timestamp (ISO 8601) */
                since?: string;
                /** @description Maximum number of results to return */
                limit?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Search results retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    searchWorkspace: {
        parameters: {
            query?: {
                /** @description Full-text search query */
                q?: string;
                /** @description Filter by append type */
                type?: "task" | "claim" | "response" | "blocked" | "answer" | "renew" | "cancel" | "comment" | "vote";
                /** @description Limit search to a specific folder path */
                folder?: string;
                /** @description Filter by task status */
                status?: "pending" | "claimed" | "completed" | "cancelled";
                /** @description Filter by author name */
                author?: string;
                /** @description Filter by labels (comma-separated, OR matching) */
                labels?: string;
                /** @description Filter by priority levels (comma-separated) */
                priority?: string;
                /** @description Return results after this timestamp (ISO 8601) */
                since?: string;
                /** @description Maximum number of results to return */
                limit?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Search results retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "results": [
                     *           {
                     *             "type": "file",
                     *             "id": "file_1",
                     *             "file": {
                     *               "id": "file_1",
                     *               "path": "/projects/alpha/tasks.md"
                     *             },
                     *             "content": "Project Alpha task list",
                     *             "highlights": [
                     *               {
                     *                 "start": 8,
                     *                 "end": 13
                     *               }
                     *             ],
                     *             "score": 0.92
                     *           },
                     *           {
                     *             "type": "task",
                     *             "id": "a1",
                     *             "file": {
                     *               "id": "file_1",
                     *               "path": "/projects/alpha/tasks.md"
                     *             },
                     *             "content": "Review API design",
                     *             "highlights": [
                     *               {
                     *                 "start": 7,
                     *                 "end": 10
                     *               }
                     *             ],
                     *             "score": 0.88
                     *           }
                     *         ],
                     *         "total": 42
                     *       },
                     *       "pagination": {
                     *         "cursor": "xyz789",
                     *         "hasMore": true
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    subscribeReadKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description WebSocket connection established (Switching Protocols) */
            101: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebSocket upgrade successful (for OpenAPI compliance) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    subscribeAppendKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description WebSocket connection established (Switching Protocols) */
            101: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebSocket upgrade successful (for OpenAPI compliance) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    subscribeWriteKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description WebSocket connection established (Switching Protocols) */
            101: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description WebSocket upgrade successful (for OpenAPI compliance) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    recordHeartbeat: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "author": "agent-alpha",
                 *       "status": "alive",
                 *       "currentTask": "a42",
                 *       "metadata": {
                 *         "version": "1.2.0",
                 *         "lastAction": "processing"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["HeartbeatRequest"];
            };
        };
        responses: {
            /** @description Heartbeat recorded successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "id": "hb_x8k2mP9qL3nR",
                     *         "author": "agent-alpha",
                     *         "ts": "2024-01-10T10:30:00Z",
                     *         "expiresAt": "2024-01-10T10:35:00Z",
                     *         "nextHeartbeatBy": "2024-01-10T10:34:30Z"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["HeartbeatResponse"];
                };
            };
            /**
             * @description Invalid request. Possible error codes:
             *     - `INVALID_AUTHOR`: Author field fails validation
             *     - `AUTHOR_MISMATCH`: Heartbeat author doesn't match scoped key's boundAuthor
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    getStatsViaWriteKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Statistics retrieved */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatsViaWriteKeyResponse"];
                };
            };
            /** @description Invalid or insufficient permissions */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatsErrorResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    getFileStatsViaReadKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File statistics retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileStatsResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    getFileStats: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File statistics retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileStatsResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    getWorkspaceStats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Workspace statistics retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkspaceStatsResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    pollJobStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Job capability key (same format as file keys) */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Job status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobResponse"];
                };
            };
            /** @description Job not found or expired */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "JOB_NOT_FOUND",
                     *         "message": "Job not found or expired"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    exportWorkspace: {
        parameters: {
            query?: {
                /** @description Archive format */
                format?: "zip" | "tar.gz";
                /** @description Include append history in metadata */
                includeAppends?: boolean;
                /** @description Include soft-deleted files */
                includeDeleted?: boolean;
                /** @description Comma-separated folder paths to export (exports all if omitted) */
                paths?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Binary file download */
            200: {
                headers: {
                    /** @description Attachment filename */
                    "Content-Disposition"?: string;
                    /** @description SHA-256 checksum for integrity verification */
                    "X-Export-Checksum"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/zip": string;
                    "application/gzip": string;
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description Workspace too large for synchronous export */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "WORKSPACE_TOO_LARGE",
                     *         "message": "Workspace exceeds 500MB sync export limit. Use async export.",
                     *         "details": {
                     *           "currentSize": "750MB",
                     *           "syncLimit": "500MB"
                     *         }
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    createExportJob: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * @default zip
                     * @enum {string}
                     */
                    format?: "zip" | "tar.gz";
                    /**
                     * @description Include append history in metadata
                     * @default false
                     */
                    includeAppends?: boolean;
                    /**
                     * @description Include soft-deleted files
                     * @default false
                     */
                    includeDeleted?: boolean;
                    /** @description Folder paths to export (exports all if omitted) */
                    paths?: string[];
                    /**
                     * Format: email
                     * @description Email to notify when export is ready
                     */
                    notifyEmail?: string;
                };
            };
        };
        responses: {
            /** @description Export job created */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "jobId": "exp_abc123",
                     *         "status": "queued",
                     *         "statusUrl": "/api/v1/export/jobs/exp_abc123",
                     *         "estimatedSize": "2.3GB",
                     *         "position": 3
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["ExportJobCreateResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            /** @description Workspace exceeds maximum export size */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "WORKSPACE_TOO_LARGE",
                     *         "message": "Workspace exceeds 10GB export limit",
                     *         "details": {
                     *           "currentSize": "12.4GB",
                     *           "limit": "10GB",
                     *           "suggestion": "Use folder-level export for individual folders"
                     *         }
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    getExportJobStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Background job identifier */
                jobId: components["parameters"]["jobId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Export job status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExportJobStatusResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    downloadExportJob: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Background job identifier */
                jobId: components["parameters"]["jobId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Binary file download */
            200: {
                headers: {
                    /** @description Attachment filename */
                    "Content-Disposition"?: string;
                    /** @description SHA-256 checksum for integrity verification */
                    "X-Export-Checksum"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/zip": string;
                    "application/gzip": string;
                };
            };
            401: components["responses"]["Unauthorized"];
            /** @description Job not ready for download */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "JOB_NOT_READY",
                     *         "message": "Export job is not ready for download yet",
                     *         "details": {
                     *           "status": "processing"
                     *         }
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Export job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": false,
                     *       "error": {
                     *         "code": "JOB_NOT_FOUND",
                     *         "message": "Export job not found"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    listDeletedFiles: {
        parameters: {
            query?: {
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of recoverable deleted files */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "files": [
                     *           {
                     *             "id": "x8k2m",
                     *             "path": "/projects/alpha/old-notes.md",
                     *             "deletedAt": "2026-01-08T10:00:00Z",
                     *             "expiresAt": "2026-01-15T10:00:00Z",
                     *             "size": 2048
                     *           },
                     *           {
                     *             "id": "y9m3n",
                     *             "path": "/archive/deprecated.md",
                     *             "deletedAt": "2026-01-07T14:30:00Z",
                     *             "expiresAt": "2026-01-14T14:30:00Z",
                     *             "deletedBy": "admin",
                     *             "size": 4096
                     *           }
                     *         ]
                     *       },
                     *       "pagination": {
                     *         "hasMore": false,
                     *         "total": 2
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["DeletedFilesListResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["RateLimited"];
        };
    };
    getAgentLiveness: {
        parameters: {
            query?: {
                /** @description Seconds before an agent is considered stale (default 300 = 5 minutes) */
                staleThresholdSeconds?: number;
                /** @description Limit to agents active in a specific folder */
                folder?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Agent liveness data retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "agents": [
                     *           {
                     *             "author": "kai",
                     *             "status": "alive",
                     *             "lastSeen": "2024-01-10T10:30:00Z",
                     *             "stale": false,
                     *             "currentTask": "t42"
                     *           },
                     *           {
                     *             "author": "worker-1",
                     *             "status": "alive",
                     *             "lastSeen": "2024-01-10T09:00:00Z",
                     *             "stale": true
                     *           }
                     *         ],
                     *         "staleThresholdSeconds": 300,
                     *         "webUrl": "https://app.mdplane.dev/control/ws_xxx/agents"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["AgentLivenessResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    getScopedAgentLiveness: {
        parameters: {
            query?: {
                /** @description Seconds before an agent is considered stale (default 300 = 5 minutes) */
                staleThresholdSeconds?: number;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Agent liveness data retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AgentLivenessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    getOrchestrationReadOnly: {
        parameters: {
            query?: {
                /**
                 * @description Filter by task status (comma-separated; pending, claimed, stalled, completed, cancelled)
                 * @example pending,claimed
                 */
                status?: string;
                /** @description Filter by claiming agent */
                agent?: string;
                /** @description Filter by filename (partial match) */
                file?: string;
                /** @description Filter by folder path */
                folder?: string;
                /**
                 * @description Filter by priority (comma-separated; low, medium, high, critical)
                 * @example high,critical
                 */
                priority?: string;
                /** @description Return items modified after this timestamp (ISO 8601) */
                since?: components["parameters"]["since"];
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Orchestration data retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrchestrationReadOnlyResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    getOrchestrationAdmin: {
        parameters: {
            query?: {
                /**
                 * @description Filter by task status (comma-separated; pending, claimed, stalled, completed, cancelled)
                 * @example pending,claimed
                 */
                status?: string;
                /** @description Filter by claiming agent */
                agent?: string;
                /** @description Filter by filename (partial match) */
                file?: string;
                /** @description Filter by folder path */
                folder?: string;
                /**
                 * @description Filter by priority (comma-separated; low, medium, high, critical)
                 * @example high,critical
                 */
                priority?: string;
                /** @description Return items modified after this timestamp (ISO 8601) */
                since?: components["parameters"]["since"];
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Orchestration data retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrchestrationAdminResponse"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    getWorkspaceOrchestration: {
        parameters: {
            query?: {
                /**
                 * @description Filter by task status (comma-separated; pending, claimed, stalled, completed, cancelled)
                 * @example pending,claimed
                 */
                status?: string;
                /** @description Filter by claiming agent */
                agent?: string;
                /** @description Filter by filename (partial match) */
                file?: string;
                /** @description Filter by folder path */
                folder?: string;
                /**
                 * @description Filter by priority (comma-separated; low, medium, high, critical)
                 * @example high,critical
                 */
                priority?: string;
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
            };
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Orchestration data retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrchestrationReadOnlyResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    renewClaimWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
                /**
                 * @description The claim's append ID
                 * @example a_x8k2mP9qL3nR7mQ2pN4x
                 */
                claimId: components["parameters"]["claimId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RenewClaimRequest"];
            };
        };
        responses: {
            /** @description Claim renewed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClaimMutationResponse"];
                };
            };
            /** @description Cannot renew claim */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    completeClaimWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
                /**
                 * @description The claim's append ID
                 * @example a_x8k2mP9qL3nR7mQ2pN4x
                 */
                claimId: components["parameters"]["claimId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CompleteClaimRequest"];
            };
        };
        responses: {
            /** @description Task completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClaimMutationResponse"];
                };
            };
            /** @description Cannot complete claim */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    cancelClaimWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
                /**
                 * @description The claim's append ID
                 * @example a_x8k2mP9qL3nR7mQ2pN4x
                 */
                claimId: components["parameters"]["claimId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CancelClaimRequest"];
            };
        };
        responses: {
            /** @description Claim cancelled successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClaimMutationResponse"];
                };
            };
            /** @description Cannot cancel claim */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    blockClaimWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Workspace identifier */
                workspaceId: components["parameters"]["workspaceId"];
                /**
                 * @description The claim's append ID
                 * @example a_x8k2mP9qL3nR7mQ2pN4x
                 */
                claimId: components["parameters"]["claimId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BlockClaimRequest"];
            };
        };
        responses: {
            /** @description Claim marked as blocked */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClaimMutationResponse"];
                };
            };
            /** @description Cannot block claim (missing reason or not active) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    apiReadFileByPath: {
        parameters: {
            query?: {
                /** @description Response format */
                format?: components["parameters"]["format"];
            };
            header?: never;
            path: {
                /** @description URL-encoded file path (e.g., projects/alpha/notes.md) */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File content retrieved successfully */
            200: {
                headers: {
                    /** @description Content version hash for optimistic concurrency */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileReadResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    apiUpdateFileByPath: {
        parameters: {
            query?: never;
            header?: {
                /** @description ETag from previous read for optimistic concurrency */
                "If-Match"?: string;
            };
            path: {
                /** @description URL-encoded file path */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FileUpdateRequest"];
            };
        };
        responses: {
            /** @description File updated successfully */
            200: {
                headers: {
                    /** @description New content version hash */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileUpdateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            /** @description ETag mismatch - file was modified since last read */
            412: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    apiCreateFileByPath: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description URL-encoded file path for the new file */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Initial file content (markdown) */
                    content: string;
                    /** @description Optional initial appends to add after file creation */
                    initialAppends?: components["schemas"]["AppendRequest"][];
                };
            };
        };
        responses: {
            /** @description File created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileCreateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            409: components["responses"]["Conflict"];
            429: components["responses"]["RateLimited"];
        };
    };
    apiDeleteFileByPath: {
        parameters: {
            query?: {
                /** @description Hard delete (irreversible) */
                permanent?: boolean;
            };
            header?: never;
            path: {
                /** @description URL-encoded file path */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileDeleteResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            429: components["responses"]["RateLimited"];
        };
    };
    apiAppendToFileByPath: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description URL-encoded file path */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AppendRequest"];
            };
        };
        responses: {
            /** @description Append created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppendResponse"];
                };
            };
            /**
             * @description Invalid request. Possible error codes:
             *     - `INVALID_APPEND_TYPE`: Unknown type value
             *     - `INVALID_REF`: ref points to wrong append type or doesn't exist
             *     - `INVALID_AUTHOR`: Author field fails validation
             *     - `TASK_ALREADY_COMPLETE`: Trying to claim a completed task
             *     - `ALREADY_CLAIMED`: Task already has active claim
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            410: components["responses"]["Gone"];
            /**
             * @description Rate limited. Possible error codes:
             *     - `RATE_LIMITED`: Too many requests
             *     - `WIP_LIMIT_EXCEEDED`: Author at max concurrent claims
             */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    apiListRootFolder: {
        parameters: {
            query?: {
                /** @description Include all nested contents recursively */
                recursive?: boolean;
                /** @description Return nested tree structure up to N levels deep (default 1, max 5) */
                depth?: number;
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Folder contents retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderListResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["RateLimited"];
        };
    };
    apiCreateRootFolder: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description New folder name */
                    name: string;
                };
            };
        };
        responses: {
            /** @description Folder created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderCreateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            409: components["responses"]["Conflict"];
            429: components["responses"]["RateLimited"];
        };
    };
    apiListFolderByPath: {
        parameters: {
            query?: {
                /** @description Include all nested contents recursively */
                recursive?: boolean;
                /** @description Return nested tree structure up to N levels deep (default 1, max 5) */
                depth?: number;
                /** @description Maximum number of items to return */
                limit?: components["parameters"]["limit"];
                /** @description Pagination cursor for fetching next page */
                cursor?: components["parameters"]["cursor"];
            };
            header?: never;
            path: {
                /** @description URL-encoded folder path (use empty string or "/" for root) */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Folder contents retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderListResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    apiCreateFolderByPath: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description URL-encoded parent folder path */
                path: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description New folder name */
                    name: string;
                };
            };
        };
        responses: {
            /** @description Folder created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderCreateResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            409: components["responses"]["Conflict"];
            429: components["responses"]["RateLimited"];
        };
    };
    apiDeleteFolderByPath: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description URL-encoded folder path */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Delete folder and all contents */
                    cascade?: boolean;
                    /** @description Must match folder path exactly (without leading slash) for cascade delete */
                    confirmPath?: string;
                };
            };
        };
        responses: {
            /** @description Folder deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderDeleteResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            /** @description Folder not empty (use cascade delete) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    healthCheck: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Service is healthy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "status": "healthy",
                     *       "timestamp": "2024-01-08T10:30:00Z",
                     *       "uptimeSeconds": 3600,
                     *       "version": "0.1.0"
                     *     }
                     */
                    "application/json": components["schemas"]["HealthCheckSimpleResponse"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    getOpenApiSpec: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OpenAPI specification */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    getApiDocs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description API documentation page */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/html": string;
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    getChangelog: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description API changelog */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "currentVersion": "1.5.2",
                     *         "releasedAt": "2025-12-15T00:00:00Z",
                     *         "entries": [
                     *           {
                     *             "version": "1.5.2",
                     *             "date": "2025-12-15",
                     *             "changes": [
                     *               {
                     *                 "type": "added",
                     *                 "description": "Added bulk append endpoint"
                     *               },
                     *               {
                     *                 "type": "fixed",
                     *                 "description": "Fixed race condition in claim renewal"
                     *               }
                     *             ]
                     *           }
                     *         ]
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["ChangelogResponse"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    getServiceStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Service status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "status": "operational",
                     *         "timestamp": "2026-02-22T19:01:10.304Z",
                     *         "environment": "production",
                     *         "uptimeSeconds": 86400,
                     *         "version": "0.1.0",
                     *         "database": {
                     *           "status": "operational",
                     *           "latencyMs": 15
                     *         },
                     *         "storage": {
                     *           "status": "operational",
                     *           "latencyMs": 8
                     *         },
                     *         "websocket": {
                     *           "status": "operational",
                     *           "latencyMs": 31,
                     *           "activeConnections": 42
                     *         },
                     *         "regions": [
                     *           {
                     *             "name": "us-east-1",
                     *             "status": "operational"
                     *           }
                     *         ]
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    checkCapabilitiesInWorkspace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "keys": [
                 *         "x8k2mP9qL3nR",
                 *         "3kL9mQ2pN7xR",
                 *         "invalidKey123"
                 *       ]
                 *     }
                 */
                "application/json": components["schemas"]["CapabilitiesCheckRequest"];
            };
        };
        responses: {
            /** @description Capability check results with extended information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "results": [
                     *           {
                     *             "key": "x8k2mP9q...",
                     *             "valid": true,
                     *             "permission": "read",
                     *             "scope": "file",
                     *             "path": "/projects/alpha/tasks.md",
                     *             "status": "active"
                     *           },
                     *           {
                     *             "key": "3kL9mQ2p...",
                     *             "valid": true,
                     *             "permission": "append",
                     *             "scope": "file",
                     *             "path": "/projects/alpha/tasks.md",
                     *             "status": "active"
                     *           },
                     *           {
                     *             "key": "invalidK...",
                     *             "valid": false,
                     *             "error": "NOT_FOUND"
                     *           }
                     *         ]
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["CapabilitiesCheckInWorkspaceResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    getAuditLogs: {
        parameters: {
            query?: {
                /** @description Filter by action type */
                action?: "file.create" | "file.update" | "file.delete" | "append" | "claim" | "key.create" | "key.revoke" | "webhook.create" | "webhook.update" | "webhook.delete" | "workspace.claim";
                /** @description Filter by resource type */
                resourceType?: "file" | "folder" | "key" | "webhook" | "workspace";
                /** @description Filter by actor (key prefix or identifier) */
                actor?: string;
                /** @description Filter logs from this date (ISO 8601 format) */
                since?: string;
                /** @description Filter logs until this date (ISO 8601 format) */
                until?: string;
                /** @description Maximum number of logs to return (default 50, max 100) */
                limit?: number;
                /** @description Cursor for pagination (opaque) */
                cursor?: string;
            };
            header?: never;
            path: {
                /** @description Capability key (20+ chars, base62 with underscore) */
                key: components["parameters"]["capabilityKey"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Audit logs retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": [
                     *         {
                     *           "id": "audit_x8k2mP9qL3nR",
                     *           "action": "file.create",
                     *           "resourceType": "file",
                     *           "resourceId": "file_y9m3n",
                     *           "resourcePath": "/projects/alpha/tasks.md",
                     *           "actor": "w_abc...",
                     *           "actorType": "capability_url",
                     *           "metadata": {},
                     *           "createdAt": "2024-01-08T10:30:00Z"
                     *         }
                     *       ],
                     *       "pagination": {
                     *         "total": 150,
                     *         "limit": 50,
                     *         "cursor": "audit_x8k2mP9qL3nR",
                     *         "hasMore": true
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["AuditLogsResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    getAdminMetrics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description System metrics retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "ok": true,
                     *       "data": {
                     *         "storage": {
                     *           "databaseSizeBytes": 52428800,
                     *           "databaseSizeMB": 50,
                     *           "maxSizeBytes": 5368709120,
                     *           "maxSizeMB": 5120,
                     *           "usagePercent": 0.98
                     *         },
                     *         "counts": {
                     *           "workspaces": 42,
                     *           "files": 1250,
                     *           "folders": 180,
                     *           "users": 15,
                     *           "activeSessions": 8,
                     *           "capabilityKeys": 126
                     *         },
                     *         "quotas": {
                     *           "maxWorkspaceStorageBytes": 104857600,
                     *           "maxFileSizeBytes": 10485760
                     *         },
                     *         "uptime": {
                     *           "seconds": 86400,
                     *           "formatted": "1d 0h 0m"
                     *         }
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["AdminMetricsResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
        };
    };
}
